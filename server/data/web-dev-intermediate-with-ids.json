[
  {
    "domains": [
      {
        "level": "Intermediate",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Explore advanced frontend performance and architecture techniques, including SSR, SSG, ISR, edge rendering, design systems, and mono-repos for scalable web applications.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f11"
      }
    ],
    "courses": [
      {
        "title": "Advanced Frontend Performance & Architecture",
        "slug": "advanced-frontend-performance-architecture",
        "shortDescription": "An intermediate course on optimizing frontend performance and architecture with Next.js, covering SSR/SSG/ISR, edge rendering, and design systems.",
        "longDescription": "This course dives into advanced frontend performance and architecture, focusing on Next.js for server-side rendering (SSR), static site generation (SSG), and incremental static regeneration (ISR). You’ll explore edge rendering, streaming, partial hydration, design systems, and mono-repos for scalable applications. Through hands-on exercises, real-world examples, and quizzes, you’ll build a design system with Storybook and integrate it into a Next.js app. The course also covers debugging, optimization, and deployment, preparing you for building high-performance web applications.",
        "tags": [
          "javascript",
          "nextjs",
          "performance",
          "architecture",
          "design-systems",
          "mono-repos",
          "frontend"
        ],
        "thumbnail": "https://example.com/thumbnails/advanced-frontend.jpg",
        "levelSummary": [
          {
            "level": "Intermediate",
            "overview": "Master advanced frontend techniques with Next.js, design systems, and modern architecture for performant, scalable apps.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f12",
        "domainId": "68cf5c5036b0c3df3e9f9f11"
      }
    ],
    "modules": [
      {
        "level": "Intermediate",
        "title": "Module 1 — Advanced Frontend Performance & Architecture",
        "slug": "advanced-frontend-performance-architecture",
        "description": "Learn SSR, SSG, ISR, edge rendering, design systems, and mono-repos to build scalable, performant frontend applications.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f13",
        "courseId": "68cf5c5036b0c3df3e9f9f12",
        "lessonIds": [
          "68cf5c5036b0c3df3e9f9f14",
          "68cf5c5036b0c3df3e9f9f15",
          "68cf5c5036b0c3df3e9f9f16",
          "68cf5c5036b0c3df3e9f9f17",
          "68cf5c5036b0c3df3e9f9f18",
          "68cf5c5036b0c3df3e9f9f19"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Intermediate",
        "title": "Introduction to Frontend Performance & Architecture",
        "slug": "intro-frontend-performance",
        "description": "Understand the principles of advanced frontend performance and scalable architecture in modern web development.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f14",
        "moduleId": "68cf5c5036b0c3df3e9f9f13",
        "contentId": "68cf5c5036b0c3df3e9f9f1a"
      },
      {
        "level": "Intermediate",
        "title": "SSR, SSG, and ISR with Next.js",
        "slug": "ssr-ssg-isr",
        "description": "Explore server-side rendering, static site generation, and incremental static regeneration in Next.js.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f15",
        "moduleId": "68cf5c5036b0c3df3e9f9f13",
        "contentId": "68cf5c5036b0c3df3e9f9f1b"
      },
      {
        "level": "Intermediate",
        "title": "Edge Rendering and Streaming",
        "slug": "edge-rendering-streaming",
        "description": "Learn edge rendering, streaming, and partial hydration for optimized frontend performance.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f16",
        "moduleId": "68cf5c5036b0c3df3e9f9f13",
        "contentId": "68cf5c5036b0c3df3e9f9f1c"
      },
      {
        "level": "Intermediate",
        "title": "Building a Design System with Storybook",
        "slug": "design-system-storybook",
        "description": "Create a reusable design system using Storybook for component-driven development.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f17",
        "moduleId": "68cf5c5036b0c3df3e9f9f13",
        "contentId": "68cf5c5036b0c3df3e9f9f1d"
      },
      {
        "level": "Intermediate",
        "title": "Mono-repos and Package Sharing",
        "slug": "mono-repos-packages",
        "description": "Understand mono-repos and package sharing for scalable frontend architecture.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f18",
        "moduleId": "68cf5c5036b0c3df3e9f9f13",
        "contentId": "68cf5c5036b0c3df3e9f9f1e"
      },
      {
        "level": "Intermediate",
        "title": "Integrating and Deploying a Next.js App",
        "slug": "nextjs-integration-deploy",
        "description": "Integrate a design system into a Next.js app and deploy it with optimized performance.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f19",
        "moduleId": "68cf5c5036b0c3df3e9f9f13",
        "contentId": "68cf5c5036b0c3df3e9f9f1f"
      }
    ],
    "learningContents": [
      {
        "level": "Intermediate",
        "explanation": "Advanced frontend performance and architecture focus on optimizing web apps for speed, scalability, and maintainability. Techniques like SSR, SSG, ISR, edge rendering, and design systems streamline development. This lesson introduces these concepts, their trade-offs, and their role in modern frameworks like Next.js. You’ll learn to plan performance-driven projects and set up a development environment for scalability.",
        "examples": [
          "Next.js SSR: export async function getServerSideProps() { return { props: { data } } }",
          "Run: npm create next-app // Initialize a Next.js project"
        ],
        "realWorldApplication": "These techniques power fast, scalable apps like e-commerce platforms, dashboards, and content-heavy sites.",
        "expertInsights": "Balance performance and complexity by choosing the right rendering strategy. Use tools like Lighthouse for optimization.",
        "commonMistakes": [
          "Overusing SSR, slowing down responses.",
          "Ignoring performance metrics, leading to poor UX."
        ],
        "exercises": [
          {
            "title": "Plan a Performance-Driven App",
            "prompt": "Outline a Next.js app structure with SSR and a design system.",
            "difficulty": "easy",
            "hints": [
              "Include pages and components",
              "Plan for API data fetching"
            ],
            "solution": "pages/index.js: export async function getServerSideProps() { return { props: { data: 'Hello' } } }\ncomponents/Button.js: export const Button = () => <button>Click</button>;"
          }
        ],
        "quiz": [
          {
            "question": "What improves frontend performance?",
            "options": [
              "SSR",
              "SSG",
              "ISR",
              "All of the above"
            ],
            "correctOption": [
              3
            ]
          },
          {
            "question": "Why use a design system?",
            "options": [
              "Faster deployment",
              "Consistent UI",
              "Smaller bundles",
              "Better SEO"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 30,
        "resources": [
          {
            "title": "Next.js Documentation",
            "url": "https://nextjs.org/docs",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f1a",
        "lessonId": "68cf5c5036b0c3df3e9f9f14"
      },
      {
        "level": "Intermediate",
        "explanation": "Server-side rendering (SSR), static site generation (SSG), and incremental static regeneration (ISR) are Next.js rendering strategies with distinct trade-offs. SSR renders pages on each request, SSG pre-renders at build time, and ISR updates static pages incrementally. This lesson covers implementing these in Next.js, analyzing their use cases, and testing performance. You’ll learn to create pages with each method and verify them in a browser.",
        "examples": [
          "SSG: export async function getStaticProps() { return { props: { data } } }",
          "ISR: export async function getStaticProps() { return { props: { data }, revalidate: 10 } }"
        ],
        "realWorldApplication": "SSR is used for dynamic dashboards, SSG for blogs, and ISR for e-commerce product pages.",
        "expertInsights": "Use SSG for static content, ISR for frequent updates, and SSR for real-time data. Monitor revalidation times for ISR.",
        "commonMistakes": [
          "Using SSR for static content, increasing server load.",
          "Setting short ISR revalidation, causing frequent rebuilds."
        ],
        "exercises": [
          {
            "title": "Implement SSG in Next.js",
            "prompt": "Create a Next.js page using SSG to display static data.",
            "difficulty": "medium",
            "hints": [
              "Use getStaticProps",
              "Return props object"
            ],
            "solution": "pages/index.js: export async function getStaticProps() { return { props: { message: 'Hello SSG' } } } export default function Home({ message }) { return <p>{message}</p> }"
          }
        ],
        "quiz": [
          {
            "question": "What does ISR do?",
            "options": [
              "Renders on request",
              "Pre-renders at build",
              "Updates static pages",
              "Streams data"
            ],
            "correctOption": [
              2
            ]
          },
          {
            "question": "When is SSR most suitable?",
            "options": [
              "Static blogs",
              "Dynamic data",
              "Infrequent updates",
              "Small apps"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 45,
        "resources": [
          {
            "title": "Next.js — Data Fetching",
            "url": "https://nextjs.org/docs/basic-features/data-fetching",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f1b",
        "lessonId": "68cf5c5036b0c3df3e9f9f15"
      },
      {
        "level": "Intermediate",
        "explanation": "Edge rendering, streaming, and partial hydration optimize performance by reducing server load and improving load times. Edge rendering processes pages at CDN edges, streaming delivers content incrementally, and partial hydration minimizes client-side JavaScript. This lesson covers implementing these in Next.js, focusing on performance gains. You’ll learn to set up a streaming page and test it with DevTools’ Network tab.",
        "examples": [
          "Streaming: export const dynamic = 'force-dynamic'; export default function Page() { return <Suspense fallback={<p>Loading...</p>}><Component /></Suspense> }",
          "Partial hydration: import dynamic from 'next/dynamic'; const Component = dynamic(() => import('./Component'), { ssr: false });"
        ],
        "realWorldApplication": "These techniques are used in high-traffic apps like news sites or social platforms for fast, scalable rendering.",
        "expertInsights": "Use streaming for large pages and partial hydration for heavy components. Monitor edge latency for optimal performance.",
        "commonMistakes": [
          "Overusing dynamic imports, slowing initial loads.",
          "Not providing fallbacks for Suspense, breaking UX."
        ],
        "exercises": [
          {
            "title": "Implement Streaming in Next.js",
            "prompt": "Create a Next.js page with streaming and a loading fallback.",
            "difficulty": "medium",
            "hints": [
              "Use Suspense component",
              "Add dynamic rendering"
            ],
            "solution": "pages/index.js: import { Suspense } from 'react'; export const dynamic = 'force-dynamic'; export default function Page() { return <Suspense fallback={<p>Loading...</p>}><p>Data loaded</p></Suspense> }"
          }
        ],
        "quiz": [
          {
            "question": "What does edge rendering use?",
            "options": [
              "Local server",
              "CDN edges",
              "Client browser",
              "Database"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What does partial hydration reduce?",
            "options": [
              "Server load",
              "Client-side JS",
              "API calls",
              "CSS size"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Next.js — Streaming",
            "url": "https://nextjs.org/docs/app/building-your-application/routing/loading-ui-and-streaming",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f1c",
        "lessonId": "68cf5c5036b0c3df3e9f9f16"
      },
      {
        "level": "Intermediate",
        "explanation": "Design systems provide reusable, consistent UI components to streamline development. Storybook is a tool for building, testing, and documenting components in isolation. This lesson covers creating a design system with Storybook, defining components like buttons or inputs, and documenting their states. You’ll learn to set up Storybook and test components interactively in a browser.",
        "examples": [
          "// Button.stories.js: export default { title: 'Button' }; export const Primary = () => <button>Click</button>;",
          "Run: npx storybook init // Initialize Storybook"
        ],
        "realWorldApplication": "Design systems are used in large-scale apps like Airbnb or Shopify for consistent, reusable UI components.",
        "expertInsights": "Define clear component states in Storybook. Use CSS-in-JS or Tailwind for styling consistency.",
        "commonMistakes": [
          "Not documenting component states, reducing reusability.",
          "Overcomplicating Storybook setup, slowing development."
        ],
        "exercises": [
          {
            "title": "Create a Storybook Design System",
            "prompt": "Set up Storybook and create a button component with primary and secondary states.",
            "difficulty": "medium",
            "hints": [
              "Use npx storybook init",
              "Define stories with different props"
            ],
            "solution": "Run: npx storybook init\ncomponents/Button.js: export const Button = ({ type }) => <button className={type}>{type}</button>;\nButton.stories.js: export default { title: 'Button' }; export const Primary = () => <Button type='primary' />; export const Secondary = () => <Button type='secondary' />;"
          }
        ],
        "quiz": [
          {
            "question": "What is Storybook used for?",
            "options": [
              "Bundling",
              "Component testing",
              "API fetching",
              "Deployment"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why use a design system?",
            "options": [
              "Faster builds",
              "Consistent UI",
              "Smaller code",
              "Better SEO"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Storybook Documentation",
            "url": "https://storybook.js.org/docs/react/get-started/introduction",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f1d",
        "lessonId": "68cf5c5036b0c3df3e9f9f17"
      },
      {
        "level": "Intermediate",
        "explanation": "Mono-repos manage multiple packages in a single repository, enabling package sharing and streamlined workflows. Tools like Yarn Workspaces or Turborepo support mono-repo setups. This lesson covers setting up a mono-repo, sharing a design system package, and integrating it into a project. You’ll learn to configure a mono-repo and test package imports for modularity.",
        "examples": [
          "// package.json: { 'workspaces': ['packages/*'] }",
          "// packages/design-system/package.json: { 'name': '@myapp/design-system' }"
        ],
        "realWorldApplication": "Mono-repos are used by companies like Google and Meta for managing large-scale frontend and backend packages.",
        "expertInsights": "Use Yarn Workspaces for simplicity or Turborepo for performance. Version shared packages carefully to avoid conflicts.",
        "commonMistakes": [
          "Misconfiguring workspaces, breaking package imports.",
          "Not versioning packages, causing dependency issues."
        ],
        "exercises": [
          {
            "title": "Set Up a Mono-repo",
            "prompt": "Create a mono-repo with a shared button component package.",
            "difficulty": "medium",
            "hints": [
              "Use Yarn Workspaces",
              "Export component in a package"
            ],
            "solution": "package.json: { 'workspaces': ['packages/*'] }\npackages/button/package.json: { 'name': '@myapp/button' }\npackages/button/index.js: export const Button = () => <button>Click</button>;"
          }
        ],
        "quiz": [
          {
            "question": "What is a mono-repo?",
            "options": [
              "Single file",
              "Multiple packages in one repo",
              "Single package",
              "Multiple repos"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What tool supports mono-repos?",
            "options": [
              "ESLint",
              "Yarn Workspaces",
              "Vite",
              "DevTools"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Yarn Workspaces Documentation",
            "url": "https://classic.yarnpkg.com/en/docs/workspaces/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f1e",
        "lessonId": "68cf5c5036b0c3df3e9f9f18"
      },
      {
        "level": "Intermediate",
        "explanation": "Integrating a design system into a Next.js app and deploying it combines all learned skills for a production-ready project. This lesson guides you through importing a Storybook design system into a Next.js app, optimizing performance with ISR or SSG, and deploying with Vercel or GitHub Pages. You’ll learn to debug with DevTools, test across browsers, and ensure scalability.",
        "examples": [
          "Next.js: import { Button } from '@myapp/design-system'; export default function Page() { return <Button /> }",
          "Deploy: vercel deploy // Deploy to Vercel"
        ],
        "realWorldApplication": "Integrated design systems power consistent, scalable apps like e-commerce sites or SaaS platforms.",
        "expertInsights": "Test design system integration early. Optimize Next.js builds with ISR for dynamic content and Vercel for fast deploys.",
        "commonMistakes": [
          "Deploying without testing integration, causing UI breaks.",
          "Not optimizing builds, leading to slow load times."
        ],
        "exercises": [
          {
            "title": "Deploy a Next.js App with Design System",
            "prompt": "Integrate a Storybook button into a Next.js app and deploy to Vercel.",
            "difficulty": "hard",
            "hints": [
              "Import design system package",
              "Use Vercel CLI for deployment"
            ],
            "solution": "packages/button/index.js: export const Button = () => <button>Click</button>;\npages/index.js: import { Button } from '@myapp/button'; export async function getStaticProps() { return { props: {} } } export default function Home() { return <Button /> }\nRun: vercel deploy"
          }
        ],
        "quiz": [
          {
            "question": "What optimizes Next.js performance?",
            "options": [
              "Inline scripts",
              "ISR",
              "Global variables",
              "No modules"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Which platform supports Next.js deployment?",
            "options": [
              "MySQL",
              "Vercel",
              "MongoDB",
              "Redis"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 60,
        "resources": [
          {
            "title": "Next.js — Deployment",
            "url": "https://nextjs.org/docs/deployment",
            "type": "doc"
          },
          {
            "title": "Vercel Documentation",
            "url": "https://vercel.com/docs",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f1f",
        "lessonId": "68cf5c5036b0c3df3e9f9f19"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Intermediate",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master advanced TypeScript patterns, including generics, conditional types, mapped types, type-safe API contracts, and domain-driven types for robust full-stack applications.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f20"
      }
    ],
    "courses": [
      {
        "title": "Advanced TypeScript Patterns",
        "slug": "advanced-typescript-patterns",
        "shortDescription": "An intermediate course on leveraging advanced TypeScript patterns, including generics, type-safe APIs with TRPC/gRPC, and domain-driven types for full-stack apps.",
        "longDescription": "This course explores advanced TypeScript patterns to build robust, type-safe full-stack applications. You’ll dive into advanced generics, conditional and mapped types, type-safe API contracts with TRPC and gRPC, and domain-driven type design. Through hands-on exercises, real-world examples, and quizzes, you’ll create a fully type-safe CRUD app with shared types between frontend and backend. The course also covers utility libraries and best practices for scalable TypeScript development, preparing you for professional full-stack projects.",
        "tags": [
          "typescript",
          "generics",
          "api-contracts",
          "trpc",
          "grpc",
          "domain-driven",
          "full-stack"
        ],
        "thumbnail": "https://example.com/thumbnails/advanced-typescript.jpg",
        "levelSummary": [
          {
            "level": "Intermediate",
            "overview": "Master advanced TypeScript techniques for building type-safe, scalable full-stack applications with shared types and modern APIs.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f21",
        "domainId": "68cf5c5036b0c3df3e9f9f20"
      }
    ],
    "modules": [
      {
        "level": "Intermediate",
        "title": "Module 1 — Advanced TypeScript Patterns",
        "slug": "advanced-typescript-patterns",
        "description": "Learn advanced generics, conditional and mapped types, type-safe APIs, and domain-driven types to build robust TypeScript applications.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f22",
        "courseId": "68cf5c5036b0c3df3e9f9f21",
        "lessonIds": [
          "68cf5c5036b0c3df3e9f9f23",
          "68cf5c5036b0c3df3e9f9f24",
          "68cf5c5036b0c3df3e9f9f25",
          "68cf5c5036b0c3df3e9f9f26",
          "68cf5c5036b0c3df3e9f9f27",
          "68cf5c5036b0c3df3e9f9f28"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Intermediate",
        "title": "Introduction to Advanced TypeScript Patterns",
        "slug": "intro-advanced-typescript",
        "description": "Understand advanced TypeScript concepts like generics, conditional types, and their role in building type-safe applications.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f23",
        "moduleId": "68cf5c5036b0c3df3e9f9f22",
        "contentId": "68cf5c5036b0c3df3e9f9f29"
      },
      {
        "level": "Intermediate",
        "title": "Advanced Generics in TypeScript",
        "slug": "advanced-generics",
        "description": "Explore advanced generics for flexible, reusable, and type-safe code structures.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f24",
        "moduleId": "68cf5c5036b0c3df3e9f9f22",
        "contentId": "68cf5c5036b0c3df3e9f9f2a"
      },
      {
        "level": "Intermediate",
        "title": "Conditional and Mapped Types",
        "slug": "conditional-mapped-types",
        "description": "Learn conditional and mapped types to create dynamic, type-safe utilities.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f25",
        "moduleId": "68cf5c5036b0c3df3e9f9f22",
        "contentId": "68cf5c5036b0c3df3e9f9f2b"
      },
      {
        "level": "Intermediate",
        "title": "Type-Safe API Contracts with TRPC",
        "slug": "trpc-api-contracts",
        "description": "Implement type-safe API contracts using TRPC for seamless frontend-backend integration.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f26",
        "moduleId": "68cf5c5036b0c3df3e9f9f22",
        "contentId": "68cf5c5036b0c3df3e9f9f2c"
      },
      {
        "level": "Intermediate",
        "title": "Type-Safe APIs with gRPC and TypeScript",
        "slug": "grpc-typescript",
        "description": "Use gRPC with TypeScript to build type-safe, high-performance APIs.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f27",
        "moduleId": "68cf5c5036b0c3df3e9f9f22",
        "contentId": "68cf5c5036b0c3df3e9f9f2d"
      },
      {
        "level": "Intermediate",
        "title": "Domain-Driven Types and Building a CRUD App",
        "slug": "domain-driven-crud",
        "description": "Create a fully type-safe full-stack CRUD app using domain-driven types and shared type definitions.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f28",
        "moduleId": "68cf5c5036b0c3df3e9f9f22",
        "contentId": "68cf5c5036b0c3df3e9f9f2e"
      }
    ],
    "learningContents": [
      {
        "level": "Intermediate",
        "explanation": "Advanced TypeScript patterns enable developers to create robust, type-safe applications with reusable and maintainable code. Generics, conditional types, and mapped types provide flexibility, while type-safe APIs and domain-driven types ensure consistency across full-stack apps. This lesson introduces these concepts, their benefits, and how to set up a TypeScript project for advanced development.",
        "examples": [
          "Generic: function identity<T>(value: T): T { return value; }",
          "Run: npx tsc --init // Initialize TypeScript project"
        ],
        "realWorldApplication": "These patterns are used in large-scale apps like financial platforms or SaaS products for type safety and scalability.",
        "expertInsights": "Leverage generics for reusable components and conditional types for dynamic utilities. Always define strict types for APIs.",
        "commonMistakes": [
          "Overcomplicating generics, reducing readability.",
          "Ignoring type inference, leading to verbose code."
        ],
        "exercises": [
          {
            "title": "Plan a TypeScript Project",
            "prompt": "Outline a TypeScript app structure with a generic utility function.",
            "difficulty": "easy",
            "hints": [
              "Use a generic type",
              "Define a simple function"
            ],
            "solution": "utils.ts: function mapData<T>(data: T): T { return data; }\nmain.ts: import { mapData } from './utils'; console.log(mapData<string>('Hello'));"
          }
        ],
        "quiz": [
          {
            "question": "What do advanced TypeScript patterns improve?",
            "options": [
              "Performance",
              "Type safety",
              "Bundling",
              "Deployment"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why use generics?",
            "options": [
              "Faster runtime",
              "Reusable types",
              "Smaller code",
              "Better SEO"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 30,
        "resources": [
          {
            "title": "TypeScript Documentation",
            "url": "https://www.typescriptlang.org/docs/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f29",
        "lessonId": "68cf5c5036b0c3df3e9f9f23"
      },
      {
        "level": "Intermediate",
        "explanation": "Advanced generics allow flexible, reusable, and type-safe code by parameterizing types. They enable functions, interfaces, and classes to work with any data type while maintaining type safety. This lesson covers creating and using advanced generics, constraining them, and applying them in real-world scenarios. You’ll learn to write a generic utility and test it in a TypeScript project.",
        "examples": [
          "interface Box<T> { content: T; } const stringBox: Box<string> = { content: 'Hello' };",
          "function merge<T, U>(a: T, b: U): T & U { return { ...a, ...b }; }"
        ],
        "realWorldApplication": "Generics are used in libraries like React or Redux for type-safe components and state management.",
        "expertInsights": "Use type constraints to limit generics. Combine with utility types for powerful abstractions.",
        "commonMistakes": [
          "Using any instead of generics, losing type safety.",
          "Overconstraining generics, reducing flexibility."
        ],
        "exercises": [
          {
            "title": "Create a Generic Function",
            "prompt": "Write a generic function to wrap a value in an object with a type-safe key.",
            "difficulty": "medium",
            "hints": [
              "Use a generic type parameter",
              "Return an object with the value"
            ],
            "solution": "function wrap<T>(value: T): { data: T } { return { data: value }; }\nconsole.log(wrap<string>('Test')); // { data: 'Test' }"
          }
        ],
        "quiz": [
          {
            "question": "What do generics provide?",
            "options": [
              "Type safety",
              "Runtime speed",
              "Smaller bundles",
              "Dynamic routes"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "How do you constrain a generic?",
            "options": [
              "extends",
              "implements",
              "typeof",
              "instanceof"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 45,
        "resources": [
          {
            "title": "TypeScript — Generics",
            "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f2a",
        "lessonId": "68cf5c5036b0c3df3e9f9f24"
      },
      {
        "level": "Intermediate",
        "explanation": "Conditional and mapped types allow dynamic type creation based on conditions or existing types, enabling powerful type utilities. Conditional types select types based on conditions, while mapped types transform object types. This lesson covers creating and using these types to build flexible utilities, testing them in a TypeScript project for type safety.",
        "examples": [
          "type IsString<T> = T extends string ? true : false;",
          "type Mapped<T> = { [K in keyof T]: T[K] };"
        ],
        "realWorldApplication": "These types are used in libraries like TypeScript’s built-in utilities or API clients for dynamic type safety.",
        "expertInsights": "Combine conditional and mapped types for complex utilities. Use keyof and in for robust mappings.",
        "commonMistakes": [
          "Misusing conditions, causing type errors.",
          "Overcomplicating mapped types, reducing clarity."
        ],
        "exercises": [
          {
            "title": "Create a Conditional Type",
            "prompt": "Write a conditional type to check if a type is a string and return a boolean.",
            "difficulty": "medium",
            "hints": [
              "Use extends with a condition",
              "Return true or false"
            ],
            "solution": "type IsString<T> = T extends string ? true : false;\ntype Test = IsString<string>; // true"
          }
        ],
        "quiz": [
          {
            "question": "What do conditional types do?",
            "options": [
              "Map objects",
              "Select types",
              "Bundle code",
              "Deploy apps"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What operator is used in mapped types?",
            "options": [
              "extends",
              "in",
              "typeof",
              "as"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "TypeScript — Conditional Types",
            "url": "https://www.typescriptlang.org/docs/handbook/2/conditional-types.html",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f2b",
        "lessonId": "68cf5c5036b0c3df3e9f9f25"
      },
      {
        "level": "Intermediate",
        "explanation": "TRPC provides type-safe API contracts by generating types from backend procedures, ensuring seamless frontend-backend integration. It eliminates manual type definitions for APIs. This lesson covers setting up TRPC in a TypeScript project, defining procedures, and consuming them in a frontend app. You’ll learn to create a type-safe endpoint and test it in a browser.",
        "examples": [
          "TRPC router: export const router = t.router({ hello: t.procedure.input(z.string()).query(({ input }) => `Hello ${input}`) });",
          "Client: const result = await trpc.hello.query('World');"
        ],
        "realWorldApplication": "TRPC is used in full-stack apps for type-safe APIs, like dashboards or e-commerce platforms.",
        "expertInsights": "Keep TRPC routers simple and use Zod for input validation. Test endpoints thoroughly for type accuracy.",
        "commonMistakes": [
          "Not validating inputs, causing runtime errors.",
          "Ignoring client-side type inference, reducing safety."
        ],
        "exercises": [
          {
            "title": "Set Up a TRPC Endpoint",
            "prompt": "Create a TRPC router with a type-safe query endpoint.",
            "difficulty": "medium",
            "hints": [
              "Use t.procedure with input",
              "Test with a client query"
            ],
            "solution": "server.ts: import { initTRPC } from '@trpc/server'; import { z } from 'zod'; const t = initTRPC.create(); export const router = t.router({ hello: t.procedure.input(z.string()).query(({ input }) => `Hello ${input}`) });\nclient.ts: import { createTRPCProxyClient } from '@trpc/client'; const trpc = createTRPCProxyClient({ links: [] }); const result = await trpc.hello.query('World');"
          }
        ],
        "quiz": [
          {
            "question": "What does TRPC ensure?",
            "options": [
              "Type safety",
              "Performance",
              "Bundling",
              "SEO"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What validates TRPC inputs?",
            "options": [
              "ESLint",
              "Zod",
              "Vite",
              "Jest"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "TRPC Documentation",
            "url": "https://trpc.io/docs",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f2c",
        "lessonId": "68cf5c5036b0c3df3e9f9f26"
      },
      {
        "level": "Intermediate",
        "explanation": "gRPC with TypeScript enables high-performance, type-safe APIs using protocol buffers. It ensures strict contracts between services, ideal for microservices or full-stack apps. This lesson covers defining gRPC services, generating TypeScript types, and integrating them into a project. You’ll learn to create a gRPC service and test it with a client.",
        "examples": [
          "proto: service Greeter { rpc SayHello (HelloRequest) returns (HelloReply); }",
          "Client: const client = new GreeterClient(); client.sayHello({ name: 'World' }, (err, res) => console.log(res));"
        ],
        "realWorldApplication": "gRPC is used in microservices for apps like streaming platforms or financial systems.",
        "expertInsights": "Use proto files for clear contracts. Generate types with protoc to ensure type safety.",
        "commonMistakes": [
          "Misdefining proto files, causing type mismatches.",
          "Not handling gRPC errors, breaking clients."
        ],
        "exercises": [
          {
            "title": "Create a gRPC Service",
            "prompt": "Define a gRPC service in a proto file and generate TypeScript types.",
            "difficulty": "medium",
            "hints": [
              "Use protoc to generate types",
              "Define a simple service"
            ],
            "solution": "greeter.proto: syntax = 'proto3'; service Greeter { rpc SayHello (HelloRequest) returns (HelloReply); } message HelloRequest { string name = 1; } message HelloReply { string message = 1; }\nRun: protoc --ts_out=. greeter.proto"
          }
        ],
        "quiz": [
          {
            "question": "What defines gRPC contracts?",
            "options": [
              "JSON",
              "Proto files",
              "TypeScript",
              "YAML"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What tool generates gRPC types?",
            "options": [
              "ESLint",
              "protoc",
              "Vite",
              "Zod"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "gRPC TypeScript Documentation",
            "url": "https://grpc.io/docs/languages/node/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f2d",
        "lessonId": "68cf5c5036b0c3df3e9f9f27"
      },
      {
        "level": "Intermediate",
        "explanation": "Domain-driven types align TypeScript types with business logic, ensuring consistency across full-stack apps. Shared types enable type-safe CRUD operations between frontend and backend. This lesson guides you through designing domain-driven types, building a full-stack CRUD app, and deploying it. You’ll learn to share types, implement CRUD, and test the app for type safety.",
        "examples": [
          "type User = { id: string; name: string; }; type Result<T> = { data: T; };",
          "CRUD: async function createUser(user: User): Promise<Result<User>> { return { data: user }; }"
        ],
        "realWorldApplication": "Domain-driven types power consistent APIs in apps like CRMs or e-commerce platforms.",
        "expertInsights": "Define types in a shared package for reuse. Use utility types to simplify CRUD operations.",
        "commonMistakes": [
          "Duplicating types, causing inconsistencies.",
          "Not testing CRUD operations, leading to runtime errors."
        ],
        "exercises": [
          {
            "title": "Build a Type-Safe CRUD App",
            "prompt": "Create a full-stack CRUD app with shared User types for create and read operations.",
            "difficulty": "hard",
            "hints": [
              "Define types in a shared file",
              "Implement create/read endpoints"
            ],
            "solution": "types.ts: export type User = { id: string; name: string; };\nserver.ts: import { User } from './types'; async function createUser(user: User) { return { data: user }; }\nclient.ts: import { User } from './types'; async function addUser() { const user: User = { id: '1', name: 'Alice' }; const result = await fetch('/api/user', { method: 'POST', body: JSON.stringify(user) }); console.log(await result.json()); }"
          }
        ],
        "quiz": [
          {
            "question": "What do domain-driven types align with?",
            "options": [
              "UI components",
              "Business logic",
              "Bundling",
              "SEO"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why share types in a CRUD app?",
            "options": [
              "Faster builds",
              "Type consistency",
              "Smaller code",
              "Better UX"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 60,
        "resources": [
          {
            "title": "TypeScript — Utility Types",
            "url": "https://www.typescriptlang.org/docs/handbook/utility-types.html",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f2e",
        "lessonId": "68cf5c5036b0c3df3e9f9f28"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Intermediate",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master advanced backend architecture techniques, including hexagonal and clean architecture, domain-driven design, and event sourcing for scalable systems.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f2f"
      }
    ],
    "courses": [
      {
        "title": "Advanced Backend Architecture",
        "slug": "advanced-backend-architecture",
        "shortDescription": "An intermediate course on designing scalable backend systems using hexagonal architecture, DDD, and event sourcing versus traditional CRUD.",
        "longDescription": "This course dives into advanced backend architecture, focusing on hexagonal (ports and adapters) and clean architecture principles, domain-driven design (DDD) concepts, and event sourcing compared to traditional CRUD approaches. Through hands-on exercises, real-world examples, and quizzes, you’ll refactor a monolithic application into a layered hexagonal architecture. The course covers designing maintainable, testable systems and implementing domain-driven patterns, preparing you for building robust backend applications.",
        "tags": [
          "backend",
          "hexagonal-architecture",
          "clean-architecture",
          "ddd",
          "event-sourcing",
          "crud",
          "software-design"
        ],
        "thumbnail": "https://example.com/thumbnails/advanced-backend.jpg",
        "levelSummary": [
          {
            "level": "Intermediate",
            "overview": "Master advanced backend techniques like hexagonal architecture, DDD, and event sourcing for scalable, maintainable systems.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f30",
        "domainId": "68cf5c5036b0c3df3e9f9f2f"
      }
    ],
    "modules": [
      {
        "level": "Intermediate",
        "title": "Module 1 — Advanced Backend Architecture",
        "slug": "advanced-backend-architecture",
        "description": "Learn hexagonal and clean architecture, DDD concepts, and event sourcing to design scalable, maintainable backend systems.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f31",
        "courseId": "68cf5c5036b0c3df3e9f9f30",
        "lessonIds": [
          "68cf5c5036b0c3df3e9f9f32",
          "68cf5c5036b0c3df3e9f9f33",
          "68cf5c5036b0c3df3e9f9f34",
          "68cf5c5036b0c3df3e9f9f35",
          "68cf5c5036b0c3df3e9f9f36",
          "68cf5c5036b0c3df3e9f9f37"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Intermediate",
        "title": "Introduction to Advanced Backend Architecture",
        "slug": "intro-backend-architecture",
        "description": "Understand the principles of advanced backend architecture, including hexagonal and clean architecture for scalable systems.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f32",
        "moduleId": "68cf5c5036b0c3df3e9f9f31",
        "contentId": "68cf5c5036b0c3df3e9f9f38"
      },
      {
        "level": "Intermediate",
        "title": "Hexagonal Architecture (Ports and Adapters)",
        "slug": "hexagonal-architecture",
        "description": "Explore hexagonal architecture to create loosely coupled, testable backend systems.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f33",
        "moduleId": "68cf5c5036b0c3df3e9f9f31",
        "contentId": "68cf5c5036b0c3df3e9f9f39"
      },
      {
        "level": "Intermediate",
        "title": "Clean Architecture Principles",
        "slug": "clean-architecture",
        "description": "Apply clean architecture principles to design maintainable and independent backend layers.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f34",
        "moduleId": "68cf5c5036b0c3df3e9f9f31",
        "contentId": "68cf5c5036b0c3df3e9f9f3a"
      },
      {
        "level": "Intermediate",
        "title": "Domain-Driven Design (DDD) Concepts",
        "slug": "ddd-concepts",
        "description": "Learn domain-driven design to align backend systems with business logic and requirements.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f35",
        "moduleId": "68cf5c5036b0c3df3e9f9f31",
        "contentId": "68cf5c5036b0c3df3e9f9f3b"
      },
      {
        "level": "Intermediate",
        "title": "Event Sourcing vs Traditional CRUD",
        "slug": "event-sourcing-vs-crud",
        "description": "Compare event sourcing and traditional CRUD approaches for data persistence and system design.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f36",
        "moduleId": "68cf5c5036b0c3df3e9f9f31",
        "contentId": "68cf5c5036b0c3df3e9f9f3c"
      },
      {
        "level": "Intermediate",
        "title": "Refactoring to Hexagonal Architecture",
        "slug": "refactor-hexagonal",
        "description": "Refactor a monolithic backend into a layered hexagonal architecture for scalability and maintainability.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f37",
        "moduleId": "68cf5c5036b0c3df3e9f9f31",
        "contentId": "68cf5c5036b0c3df3e9f9f3d"
      }
    ],
    "learningContents": [
      {
        "level": "Intermediate",
        "explanation": "Advanced backend architecture focuses on designing scalable, maintainable systems using principles like hexagonal and clean architecture, domain-driven design, and event sourcing. These approaches decouple business logic from infrastructure, improving testability and flexibility. This lesson introduces these concepts, their benefits, and how to set up a backend project for advanced architecture.",
        "examples": [
          "Hexagonal port: interface UserPort { save(user: User): Promise<void>; }",
          "Run: npm init -y // Initialize a Node.js project"
        ],
        "realWorldApplication": "These architectures are used in enterprise systems like e-commerce, banking, or logistics platforms for scalability and maintainability.",
        "expertInsights": "Start with clear domain boundaries in DDD. Use dependency inversion in hexagonal architecture for flexibility.",
        "commonMistakes": [
          "Tightly coupling business logic to infrastructure, reducing testability.",
          "Ignoring domain modeling, leading to misaligned systems."
        ],
        "exercises": [
          {
            "title": "Plan a Backend Architecture",
            "prompt": "Outline a backend project structure with hexagonal architecture principles.",
            "difficulty": "easy",
            "hints": [
              "Define ports and adapters",
              "Separate domain logic"
            ],
            "solution": "src/domain/user.ts: export interface User { id: string; name: string; }\nsrc/ports/user-port.ts: export interface UserPort { save(user: User): Promise<void>; }\nsrc/adapters/user-adapter.ts: export class UserAdapter implements UserPort { async save(user: User) { console.log('Saved:', user); } }"
          }
        ],
        "quiz": [
          {
            "question": "What improves backend scalability?",
            "options": [
              "Monoliths",
              "Hexagonal architecture",
              "Inline logic",
              "Global state"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why use DDD?",
            "options": [
              "Faster builds",
              "Align with business logic",
              "Smaller code",
              "Better UI"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 30,
        "resources": [
          {
            "title": "Domain-Driven Design Fundamentals",
            "url": "https://martinfowler.com/bliki/DomainDrivenDesign.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f38",
        "lessonId": "68cf5c5036b0c3df3e9f9f32"
      },
      {
        "level": "Intermediate",
        "explanation": "Hexagonal architecture, also known as ports and adapters, decouples business logic from external systems, enabling testability and flexibility. Ports define interfaces, while adapters implement them for specific technologies. This lesson covers designing a hexagonal architecture, creating ports and adapters, and testing them in a backend project.",
        "examples": [
          "Port: interface RepositoryPort { find(id: string): Promise<Entity>; }",
          "Adapter: class DatabaseAdapter implements RepositoryPort { async find(id: string) { return { id, name: 'Test' }; } }"
        ],
        "realWorldApplication": "Hexagonal architecture is used in microservices for systems like payment gateways or inventory management.",
        "expertInsights": "Define clear interfaces for ports. Use dependency injection to swap adapters easily.",
        "commonMistakes": [
          "Mixing business logic with adapters, reducing decoupling.",
          "Not mocking ports in tests, complicating validation."
        ],
        "exercises": [
          {
            "title": "Create a Hexagonal Port and Adapter",
            "prompt": "Define a port and adapter for a user repository in a TypeScript backend.",
            "difficulty": "medium",
            "hints": [
              "Create an interface for the port",
              "Implement an adapter with mock data"
            ],
            "solution": "src/ports/user-port.ts: export interface UserPort { find(id: string): Promise<User>; }\nsrc/domain/user.ts: export interface User { id: string; name: string; }\nsrc/adapters/user-adapter.ts: import { UserPort, User } from '../ports/user-port'; export class UserAdapter implements UserPort { async find(id: string): Promise<User> { return { id, name: 'Alice' }; } }"
          }
        ],
        "quiz": [
          {
            "question": "What does a port define in hexagonal architecture?",
            "options": [
              "Business logic",
              "Interface",
              "Database",
              "API routes"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What implements a port?",
            "options": [
              "Adapter",
              "Service",
              "Entity",
              "Controller"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 45,
        "resources": [
          {
            "title": "Hexagonal Architecture Explained",
            "url": "https://alistair.cockburn.us/hexagonal-architecture/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f39",
        "lessonId": "68cf5c5036b0c3df3e9f9f33"
      },
      {
        "level": "Intermediate",
        "explanation": "Clean architecture emphasizes separation of concerns, with independent layers for entities, use cases, and interfaces. It ensures business logic remains independent of frameworks or databases. This lesson covers structuring a backend with clean architecture, defining use cases, and testing them for independence.",
        "examples": [
          "Entity: class User { constructor(public id: string, public name: string) {} }",
          "Use case: class CreateUser { async execute(data: User) { return repository.save(data); } }"
        ],
        "realWorldApplication": "Clean architecture is used in enterprise apps like CRMs or ERP systems for maintainable, testable codebases.",
        "expertInsights": "Keep entities framework-agnostic. Use dependency inversion to isolate use cases from external systems.",
        "commonMistakes": [
          "Coupling use cases to databases, reducing flexibility.",
          "Skipping unit tests for use cases, missing logic errors."
        ],
        "exercises": [
          {
            "title": "Implement a Clean Architecture Use Case",
            "prompt": "Create a use case for creating a user in a clean architecture structure.",
            "difficulty": "medium",
            "hints": [
              "Define an entity and use case",
              "Inject a repository dependency"
            ],
            "solution": "src/domain/user.ts: export class User { constructor(public id: string, public name: string) {} }\nsrc/use-cases/create-user.ts: import { User } from '../domain/user'; export class CreateUser { constructor(private repository: { save: (user: User) => Promise<void> }) {} async execute(data: User) { await this.repository.save(data); } }"
          }
        ],
        "quiz": [
          {
            "question": "What does clean architecture prioritize?",
            "options": [
              "Database design",
              "Separation of concerns",
              "API endpoints",
              "UI logic"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What remains framework-agnostic?",
            "options": [
              "Adapters",
              "Entities",
              "Controllers",
              "Routes"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 45,
        "resources": [
          {
            "title": "Clean Architecture by Robert C. Martin",
            "url": "https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f3a",
        "lessonId": "68cf5c5036b0c3df3e9f9f34"
      },
      {
        "level": "Intermediate",
        "explanation": "Domain-driven design (DDD) aligns software with business domains by modeling entities, aggregates, and services around business logic. It ensures systems reflect real-world requirements. This lesson covers applying DDD concepts, defining domain models, and integrating them into a backend system for consistency and clarity.",
        "examples": [
          "Aggregate: class Order { constructor(public id: string, public items: Item[]) {} }",
          "Service: class OrderService { createOrder(data: Order) { return repository.save(data); } }"
        ],
        "realWorldApplication": "DDD is used in complex domains like e-commerce or logistics for clear, maintainable business logic.",
        "expertInsights": "Focus on bounded contexts to limit complexity. Use aggregates to enforce consistency.",
        "commonMistakes": [
          "Overcomplicating domain models, reducing clarity.",
          "Ignoring bounded contexts, causing domain overlap."
        ],
        "exercises": [
          {
            "title": "Define a DDD Aggregate",
            "prompt": "Create an Order aggregate with items in a DDD-based backend.",
            "difficulty": "medium",
            "hints": [
              "Define an entity and aggregate",
              "Include business logic"
            ],
            "solution": "src/domain/item.ts: export class Item { constructor(public id: string, public name: string) {} }\nsrc/domain/order.ts: export class Order { constructor(public id: string, public items: Item[]) {} addItem(item: Item) { this.items.push(item); } }"
          }
        ],
        "quiz": [
          {
            "question": "What does DDD align software with?",
            "options": [
              "UI design",
              "Business logic",
              "Database schema",
              "API routes"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What is a bounded context?",
            "options": [
              "Database",
              "Domain scope",
              "API layer",
              "Frontend"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Domain-Driven Design by Eric Evans",
            "url": "https://www.domainlanguage.com/ddd/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f3b",
        "lessonId": "68cf5c5036b0c3df3e9f9f35"
      },
      {
        "level": "Intermediate",
        "explanation": "Event sourcing stores state as a sequence of events, unlike traditional CRUD, which uses direct state updates. It enables auditing, replayability, and complex workflows. This lesson compares event sourcing with CRUD, covering implementation and trade-offs. You’ll learn to design an event-sourced system and test it for consistency.",
        "examples": [
          "Event: { type: 'UserCreated', data: { id: '1', name: 'Alice' } }",
          "Event store: class EventStore { save(event: Event) { console.log('Stored:', event); } }"
        ],
        "realWorldApplication": "Event sourcing is used in banking, e-commerce, or audit-heavy systems for tracking changes and rebuilding state.",
        "expertInsights": "Use event sourcing for audit trails or complex workflows. Combine with CQRS for scalability.",
        "commonMistakes": [
          "Overusing event sourcing for simple apps, adding complexity.",
          "Not versioning events, causing replay issues."
        ],
        "exercises": [
          {
            "title": "Implement an Event-Sourced System",
            "prompt": "Create a simple event-sourced system for user creation events.",
            "difficulty": "medium",
            "hints": [
              "Define an event type",
              "Store events in an array"
            ],
            "solution": "src/domain/event.ts: export interface Event { type: string; data: any; }\nsrc/event-store.ts: export class EventStore { private events: Event[] = []; save(event: Event) { this.events.push(event); } getEvents() { return this.events; } }\nsrc/main.ts: const store = new EventStore(); store.save({ type: 'UserCreated', data: { id: '1', name: 'Alice' } });"
          }
        ],
        "quiz": [
          {
            "question": "What does event sourcing store?",
            "options": [
              "Database rows",
              "Event sequence",
              "API routes",
              "UI state"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "When is event sourcing useful?",
            "options": [
              "Simple CRUD",
              "Audit trails",
              "Static sites",
              "UI rendering"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Event Sourcing by Martin Fowler",
            "url": "https://martinfowler.com/eaaDev/EventSourcing.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f3c",
        "lessonId": "68cf5c5036b0c3df3e9f9f36"
      },
      {
        "level": "Intermediate",
        "explanation": "Refactoring a monolith into a hexagonal architecture involves separating business logic into ports and adapters, improving scalability and testability. This lesson guides you through refactoring a monolithic backend into a layered hexagonal structure, testing each layer, and ensuring maintainability. You’ll learn to modularize code and deploy a refactored system.",
        "examples": [
          "Monolith: app.post('/user', (req, res) => db.save(req.body));",
          "Hexagonal: class UserService { constructor(private port: UserPort) {} async create(user: User) { await this.port.save(user); } }"
        ],
        "realWorldApplication": "Refactored hexagonal architectures are used in legacy systems or microservices for improved maintainability and scalability.",
        "expertInsights": "Refactor incrementally, testing each layer. Use dependency injection to isolate dependencies.",
        "commonMistakes": [
          "Refactoring without tests, introducing bugs.",
          "Not isolating business logic, reducing decoupling."
        ],
        "exercises": [
          {
            "title": "Refactor to Hexagonal Architecture",
            "prompt": "Refactor a monolithic user creation endpoint into a hexagonal architecture.",
            "difficulty": "hard",
            "hints": [
              "Define a port and adapter",
              "Move logic to a service"
            ],
            "solution": "src/domain/user.ts: export interface User { id: string; name: string; }\nsrc/ports/user-port.ts: export interface UserPort { save(user: User): Promise<void>; }\nsrc/services/user-service.ts: import { UserPort, User } from '../ports/user-port'; export class UserService { constructor(private port: UserPort) {} async create(user: User) { await this.port.save(user); } }\nsrc/adapters/user-adapter.ts: import { UserPort, User } from '../ports/user-port'; export class UserAdapter implements UserPort { async save(user: User) { console.log('Saved:', user); } }\nsrc/main.ts: import { UserService } from './services/user-service'; import { UserAdapter } from './adapters/user-adapter'; const service = new UserService(new UserAdapter()); service.create({ id: '1', name: 'Alice' });"
          }
        ],
        "quiz": [
          {
            "question": "What improves after refactoring to hexagonal?",
            "options": [
              "UI speed",
              "Testability",
              "Database size",
              "API routes"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What isolates dependencies in hexagonal architecture?",
            "options": [
              "Controllers",
              "Dependency injection",
              "Routes",
              "Entities"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 60,
        "resources": [
          {
            "title": "Refactoring to Hexagonal Architecture",
            "url": "https://herbertograca.com/2017/11/16/explicit-architecture-ports-and-adapters-hexagonal-architecture/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f3d",
        "lessonId": "68cf5c5036b0c3df3e9f9f37"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Intermediate",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Explore the fundamentals of distributed systems, including CAP theorem, consensus algorithms, and messaging systems for building scalable, reliable applications.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f3e"
      }
    ],
    "courses": [
      {
        "title": "Distributed Systems Fundamentals",
        "slug": "distributed-systems-fundamentals",
        "shortDescription": "An intermediate course on designing distributed systems, covering CAP theorem, consensus algorithms like Raft/Paxos, and messaging systems like Kafka and RabbitMQ.",
        "longDescription": "This course introduces the core concepts of distributed systems, focusing on the CAP theorem, consistency models, leader election, consensus algorithms (Raft/Paxos), and messaging systems (Kafka, RabbitMQ, NATS). Through hands-on exercises, real-world examples, and quizzes, you’ll design a scalable order system using message queues. The course covers fault tolerance, scalability, and reliability, preparing you for building robust distributed applications.",
        "tags": [
          "distributed-systems",
          "cap-theorem",
          "consensus",
          "messaging",
          "kafka",
          "rabbitmq",
          "nats"
        ],
        "thumbnail": "https://example.com/thumbnails/distributed-systems.jpg",
        "levelSummary": [
          {
            "level": "Intermediate",
            "overview": "Master distributed systems concepts like CAP theorem, consensus, and messaging for scalable, reliable applications.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f3f",
        "domainId": "68cf5c5036b0c3df3e9f9f3e"
      }
    ],
    "modules": [
      {
        "level": "Intermediate",
        "title": "Module 1 — Distributed Systems Fundamentals",
        "slug": "distributed-systems-fundamentals",
        "description": "Learn CAP theorem, consistency models, consensus algorithms, and messaging systems to design scalable, reliable distributed systems.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f40",
        "courseId": "68cf5c5036b0c3df3e9f9f3f",
        "lessonIds": [
          "68cf5c5036b0c3df3e9f9f41",
          "68cf5c5036b0c3df3e9f9f42",
          "68cf5c5036b0c3df3e9f9f43",
          "68cf5c5036b0c3df3e9f9f44",
          "68cf5c5036b0c3df3e9f9f45",
          "68cf5c5036b0c3df3e9f9f46"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Intermediate",
        "title": "Introduction to Distributed Systems",
        "slug": "intro-distributed-systems",
        "description": "Understand the core principles of distributed systems, their challenges, and their role in scalable applications.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f41",
        "moduleId": "68cf5c5036b0c3df3e9f9f40",
        "contentId": "68cf5c5036b0c3df3e9f9f47"
      },
      {
        "level": "Intermediate",
        "title": "CAP Theorem and Consistency Models",
        "slug": "cap-theorem-consistency",
        "description": "Explore the CAP theorem and different consistency models for distributed systems design.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f42",
        "moduleId": "68cf5c5036b0c3df3e9f9f40",
        "contentId": "68cf5c5036b0c3df3e9f9f48"
      },
      {
        "level": "Intermediate",
        "title": "Leader Election and Consensus Basics",
        "slug": "leader-election-consensus",
        "description": "Learn leader election and consensus algorithms like Raft and Paxos for distributed coordination.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f43",
        "moduleId": "68cf5c5036b0c3df3e9f9f40",
        "contentId": "68cf5c5036b0c3df3e9f9f49"
      },
      {
        "level": "Intermediate",
        "title": "Messaging Systems: Kafka",
        "slug": "messaging-kafka",
        "description": "Understand Apache Kafka for building scalable, fault-tolerant messaging systems.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f44",
        "moduleId": "68cf5c5036b0c3df3e9f9f40",
        "contentId": "68cf5c5036b0c3df3e9f9f4a"
      },
      {
        "level": "Intermediate",
        "title": "Messaging Systems: RabbitMQ and NATS",
        "slug": "messaging-rabbitmq-nats",
        "description": "Explore RabbitMQ and NATS for lightweight, flexible messaging in distributed systems.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f45",
        "moduleId": "68cf5c5036b0c3df3e9f9f40",
        "contentId": "68cf5c5036b0c3df3e9f9f4b"
      },
      {
        "level": "Intermediate",
        "title": "Designing a Scalable Order System",
        "slug": "scalable-order-system",
        "description": "Design a scalable order system using message queues for distributed processing.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f46",
        "moduleId": "68cf5c5036b0c3df3e9f9f40",
        "contentId": "68cf5c5036b0c3df3e9f9f4c"
      }
    ],
    "learningContents": [
      {
        "level": "Intermediate",
        "explanation": "Distributed systems enable scalable, reliable applications by distributing computation across multiple nodes. Key concepts include the CAP theorem, consensus algorithms, and messaging systems. This lesson introduces these fundamentals, their trade-offs, and how to set up a project for distributed system development.",
        "examples": [
          "CAP trade-off: Prioritize consistency or availability in a partitioned system.",
          "Run: docker run -d kafka // Start a Kafka container"
        ],
        "realWorldApplication": "Distributed systems power applications like e-commerce platforms, streaming services, and financial systems.",
        "expertInsights": "Understand CAP trade-offs early to guide system design. Use monitoring tools to detect failures in distributed setups.",
        "commonMistakes": [
          "Ignoring network partitions, leading to unreliable systems.",
          "Overcomplicating designs with unnecessary distributed components."
        ],
        "exercises": [
          {
            "title": "Plan a Distributed System",
            "prompt": "Outline a distributed system architecture for an order processing app.",
            "difficulty": "easy",
            "hints": [
              "Include services and message queues",
              "Consider CAP trade-offs"
            ],
            "solution": "services/order-service.ts: class OrderService { process(order: Order) { console.log('Processing:', order); } }\nservices/queue.ts: class MessageQueue { publish(message: any) { console.log('Published:', message); } }\nmain.ts: const queue = new MessageQueue(); queue.publish({ id: '1', item: 'Book' });"
          }
        ],
        "quiz": [
          {
            "question": "What does CAP theorem define?",
            "options": [
              "Scalability",
              "Trade-offs",
              "Security",
              "UI design"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why use distributed systems?",
            "options": [
              "Simpler code",
              "Scalability",
              "Smaller apps",
              "Better UI"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 30,
        "resources": [
          {
            "title": "Distributed Systems Overview",
            "url": "https://www.distributedsystemscourse.com/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f47",
        "lessonId": "68cf5c5036b0c3df3e9f9f41"
      },
      {
        "level": "Intermediate",
        "explanation": "The CAP theorem states that a distributed system can only guarantee two out of three properties: consistency, availability, and partition tolerance. Consistency models like eventual or strong consistency define how data is synchronized. This lesson covers the CAP theorem, consistency models, and their application in system design, with practical examples.",
        "examples": [
          "Eventual consistency: Cassandra prioritizes availability over immediate consistency.",
          "Strong consistency: SQL databases ensure all reads reflect the latest write."
        ],
        "realWorldApplication": "CAP theorem guides database choices in systems like NoSQL databases (MongoDB) or SQL databases (PostgreSQL).",
        "expertInsights": "Choose consistency models based on use case. Use eventual consistency for high-availability apps like social media.",
        "commonMistakes": [
          "Assuming strong consistency in partitioned systems, causing failures.",
          "Ignoring latency trade-offs in consistency models."
        ],
        "exercises": [
          {
            "title": "Apply CAP Theorem",
            "prompt": "Design a system prioritizing availability over consistency for an e-commerce app.",
            "difficulty": "medium",
            "hints": [
              "Choose a NoSQL database",
              "Define data synchronization"
            ],
            "solution": "design.ts: class OrderSystem { constructor(private db: { save: (order: any) => Promise<void> }) {} async saveOrder(order: any) { await this.db.save(order); console.log('Order saved with eventual consistency'); } }\nmain.ts: const system = new OrderSystem({ save: async (order) => {} }); system.saveOrder({ id: '1', item: 'Book' });"
          }
        ],
        "quiz": [
          {
            "question": "What does CAP theorem limit?",
            "options": [
              "Security",
              "Consistency/Availability",
              "UI design",
              "Code size"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What is eventual consistency?",
            "options": [
              "Immediate updates",
              "Delayed synchronization",
              "Static data",
              "No replication"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 45,
        "resources": [
          {
            "title": "CAP Theorem Explained",
            "url": "https://www.ibm.com/cloud/learn/cap-theorem",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f48",
        "lessonId": "68cf5c5036b0c3df3e9f9f42"
      },
      {
        "level": "Intermediate",
        "explanation": "Leader election and consensus algorithms like Raft and Paxos ensure coordinated behavior in distributed systems. Leader election selects a node to coordinate tasks, while consensus ensures agreement on data. This lesson covers the basics of Raft and Paxos, their implementation, and testing for fault tolerance.",
        "examples": [
          "Raft leader election: Nodes vote for a leader based on term and log index.",
          "Paxos: Proposers, acceptors, and learners agree on a value."
        ],
        "realWorldApplication": "Consensus algorithms are used in distributed databases like ZooKeeper or etcd for coordination.",
        "expertInsights": "Use Raft for simpler implementations. Monitor election timeouts to avoid split-brain scenarios.",
        "commonMistakes": [
          "Ignoring network delays, causing election failures.",
          "Not handling leader crashes, disrupting consensus."
        ],
        "exercises": [
          {
            "title": "Simulate Leader Election",
            "prompt": "Create a simple leader election simulation with nodes voting for a leader.",
            "difficulty": "medium",
            "hints": [
              "Use a basic voting mechanism",
              "Track node states"
            ],
            "solution": "leader-election.ts: class Node { constructor(public id: string, public isLeader: boolean = false) {} vote() { this.isLeader = true; console.log(`${this.id} elected as leader`); } }\nmain.ts: const nodes = [new Node('1'), new Node('2')]; nodes[0].vote();"
          }
        ],
        "quiz": [
          {
            "question": "What does leader election select?",
            "options": [
              "Database",
              "Coordinating node",
              "API endpoint",
              "UI component"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What is Raft used for?",
            "options": [
              "Consensus",
              "Styling",
              "Bundling",
              "Routing"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Raft Consensus Algorithm",
            "url": "https://raft.github.io/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f49",
        "lessonId": "68cf5c5036b0c3df3e9f9f43"
      },
      {
        "level": "Intermediate",
        "explanation": "Apache Kafka is a distributed streaming platform for high-throughput, fault-tolerant messaging. It uses topics and partitions to handle large-scale data streams. This lesson covers setting up Kafka, producing and consuming messages, and testing for reliability in a distributed system.",
        "examples": [
          "Producer: producer.send({ topic: 'orders', messages: [{ value: 'Order 1' }] });",
          "Consumer: consumer.subscribe({ topic: 'orders' }); consumer.on('message', msg => console.log(msg));"
        ],
        "realWorldApplication": "Kafka is used in streaming platforms, log aggregation, or real-time analytics for e-commerce and IoT.",
        "expertInsights": "Use partitions for scalability and consumer groups for parallel processing. Monitor lag to ensure performance.",
        "commonMistakes": [
          "Not configuring partitions, limiting scalability.",
          "Ignoring message retention, causing data loss."
        ],
        "exercises": [
          {
            "title": "Set Up a Kafka Topic",
            "prompt": "Create a Kafka producer and consumer for an order topic.",
            "difficulty": "medium",
            "hints": [
              "Use kafka-node or kafkajs",
              "Define a topic and message"
            ],
            "solution": "producer.ts: const { Kafka } = require('kafkajs'); const kafka = new Kafka({ clientId: 'app', brokers: ['localhost:9092'] }); const producer = kafka.producer(); async function send() { await producer.connect(); await producer.send({ topic: 'orders', messages: [{ value: 'Order 1' }] }); } send();\nconsumer.ts: const consumer = kafka.consumer({ groupId: 'group' }); async function consume() { await consumer.connect(); await consumer.subscribe({ topic: 'orders' }); await consumer.run({ eachMessage: async ({ message }) => console.log(message.value) }); } consume();"
          }
        ],
        "quiz": [
          {
            "question": "What does Kafka use for messaging?",
            "options": [
              "Files",
              "Topics",
              "Databases",
              "Routes"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What improves Kafka scalability?",
            "options": [
              "Single topic",
              "Partitions",
              "Single consumer",
              "Small messages"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Kafka Documentation",
            "url": "https://kafka.apache.org/documentation/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f4a",
        "lessonId": "68cf5c5036b0c3df3e9f9f44"
      },
      {
        "level": "Intermediate",
        "explanation": "RabbitMQ and NATS are lightweight messaging systems for distributed applications. RabbitMQ uses queues for reliable message delivery, while NATS focuses on simplicity and speed. This lesson covers setting up RabbitMQ and NATS, publishing and subscribing to messages, and testing for fault tolerance.",
        "examples": [
          "RabbitMQ: channel.sendToQueue('orders', Buffer.from('Order 1'));",
          "NATS: nc.publish('orders', 'Order 1');"
        ],
        "realWorldApplication": "RabbitMQ and NATS are used in microservices, IoT, or real-time apps for lightweight messaging.",
        "expertInsights": "Use RabbitMQ for guaranteed delivery and NATS for low-latency pub/sub. Monitor queue backlogs for performance.",
        "commonMistakes": [
          "Not handling connection failures, causing message loss.",
          "Using NATS for heavy workloads, reducing reliability."
        ],
        "exercises": [
          {
            "title": "Set Up a RabbitMQ Queue",
            "prompt": "Create a RabbitMQ producer and consumer for an order queue.",
            "difficulty": "medium",
            "hints": [
              "Use amqplib for RabbitMQ",
              "Define a queue and message"
            ],
            "solution": "producer.ts: const amqp = require('amqplib'); async function send() { const conn = await amqp.connect('amqp://localhost'); const channel = await conn.createChannel(); await channel.assertQueue('orders'); channel.sendToQueue('orders', Buffer.from('Order 1')); } send();\nconsumer.ts: async function consume() { const conn = await amqp.connect('amqp://localhost'); const channel = await conn.createChannel(); await channel.assertQueue('orders'); channel.consume('orders', msg => console.log(msg.content.toString())); } consume();"
          }
        ],
        "quiz": [
          {
            "question": "What is RabbitMQ best for?",
            "options": [
              "Low latency",
              "Guaranteed delivery",
              "Static sites",
              "UI rendering"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What does NATS prioritize?",
            "options": [
              "Reliability",
              "Speed",
              "Consistency",
              "Security"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "RabbitMQ Documentation",
            "url": "https://www.rabbitmq.com/documentation.html",
            "type": "doc"
          },
          {
            "title": "NATS Documentation",
            "url": "https://docs.nats.io/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f4b",
        "lessonId": "68cf5c5036b0c3df3e9f9f45"
      },
      {
        "level": "Intermediate",
        "explanation": "Designing a scalable order system involves using message queues to handle asynchronous processing, ensuring fault tolerance and scalability. This lesson guides you through designing an order system with Kafka or RabbitMQ, implementing producers and consumers, and deploying it. You’ll learn to test the system for reliability and performance.",
        "examples": [
          "Order producer: producer.send({ topic: 'orders', messages: [{ value: JSON.stringify({ id: '1', item: 'Book' }) }] });",
          "Order consumer: consumer.run({ eachMessage: async ({ message }) => processOrder(JSON.parse(message.value)) });"
        ],
        "realWorldApplication": "Scalable order systems are used in e-commerce, logistics, or ticketing platforms for reliable order processing.",
        "expertInsights": "Use idempotent consumers to handle duplicate messages. Monitor queue latency and throughput for performance.",
        "commonMistakes": [
          "Not handling message failures, causing data loss.",
          "Overloading queues, reducing system throughput."
        ],
        "exercises": [
          {
            "title": "Design a Scalable Order System",
            "prompt": "Create an order system with a Kafka producer and consumer for processing orders.",
            "difficulty": "hard",
            "hints": [
              "Define an order schema",
              "Use Kafka for messaging"
            ],
            "solution": "order.ts: export interface Order { id: string; item: string; }\nproducer.ts: const { Kafka } = require('kafkajs'); const kafka = new Kafka({ clientId: 'app', brokers: ['localhost:9092'] }); const producer = kafka.producer(); async function sendOrder(order: Order) { await producer.connect(); await producer.send({ topic: 'orders', messages: [{ value: JSON.stringify(order) }] }); } sendOrder({ id: '1', item: 'Book' });\nconsumer.ts: const consumer = kafka.consumer({ groupId: 'group' }); async function consumeOrders() { await consumer.connect(); await consumer.subscribe({ topic: 'orders' }); await consumer.run({ eachMessage: async ({ message }) => console.log(JSON.parse(message.value)) }); } consumeOrders();"
          }
        ],
        "quiz": [
          {
            "question": "What ensures scalability in an order system?",
            "options": [
              "Monolith",
              "Message queues",
              "Single server",
              "Global state"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why use idempotent consumers?",
            "options": [
              "Faster builds",
              "Handle duplicates",
              "Smaller code",
              "Better UI"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 60,
        "resources": [
          {
            "title": "Kafka for Scalable Systems",
            "url": "https://kafka.apache.org/intro",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f4c",
        "lessonId": "68cf5c5036b0c3df3e9f9f46"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Intermediate",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Explore polyglot persistence and advanced database techniques, including CQRS, sharding, replication, and multi-model databases for scalable applications.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f4d"
      }
    ],
    "courses": [
      {
        "title": "Polyglot Persistence & Advanced Databases",
        "slug": "polyglot-persistence-databases",
        "shortDescription": "An intermediate course on polyglot persistence, CQRS, sharding, replication, and multi-model databases like Postgres, Elastic, Redis, and Neo4j.",
        "longDescription": "This course dives into polyglot persistence strategies for handling diverse data needs in scalable systems, covering Command Query Responsibility Segregation (CQRS), sharding, replication, partitioning, and multi-model databases (Redis, Elasticsearch, Neo4j alongside SQL). Through hands-on exercises, real-world examples, and quizzes, you’ll implement CQRS for a sample project using Postgres and Elasticsearch. The course focuses on optimizing data storage, query performance, and system reliability, preparing you for advanced database architectures in full-stack applications.",
        "tags": [
          "databases",
          "polyglot-persistence",
          "cqrs",
          "sharding",
          "replication",
          "multi-model",
          "postgres",
          "elastic",
          "redis",
          "neo4j"
        ],
        "thumbnail": "https://example.com/thumbnails/polyglot-persistence.jpg",
        "levelSummary": [
          {
            "level": "Intermediate",
            "overview": "Master polyglot persistence and advanced database techniques for scalable, performant applications using CQRS and multi-model DBs.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f4e",
        "domainId": "68cf5c5036b0c3df3e9f9f4d"
      }
    ],
    "modules": [
      {
        "level": "Intermediate",
        "title": "Module 1 — Polyglot Persistence & Advanced Databases",
        "slug": "polyglot-persistence-databases",
        "description": "Learn CQRS, sharding, replication, partitioning, and multi-model databases to design scalable data architectures.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f4f",
        "courseId": "68cf5c5036b0c3df3e9f9f4e",
        "lessonIds": [
          "68cf5c5036b0c3df3e9f9f50",
          "68cf5c5036b0c3df3e9f9f51",
          "68cf5c5036b0c3df3e9f9f52",
          "68cf5c5036b0c3df3e9f9f53",
          "68cf5c5036b0c3df3e9f9f54",
          "68cf5c5036b0c3df3e9f9f55"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Intermediate",
        "title": "Introduction to Polyglot Persistence",
        "slug": "intro-polyglot-persistence",
        "description": "Understand polyglot persistence and the need for diverse database models in modern applications.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f50",
        "moduleId": "68cf5c5036b0c3df3e9f9f4f",
        "contentId": "68cf5c5036b0c3df3e9f9f56"
      },
      {
        "level": "Intermediate",
        "title": "CQRS (Command Query Responsibility Segregation)",
        "slug": "cqrs",
        "description": "Explore CQRS to separate read and write operations for optimized performance and scalability.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f51",
        "moduleId": "68cf5c5036b0c3df3e9f9f4f",
        "contentId": "68cf5c5036b0c3df3e9f9f57"
      },
      {
        "level": "Intermediate",
        "title": "Sharding, Replication, and Partitioning",
        "slug": "sharding-replication",
        "description": "Learn sharding, replication, and partitioning techniques for horizontal scaling and data distribution.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f52",
        "moduleId": "68cf5c5036b0c3df3e9f9f4f",
        "contentId": "68cf5c5036b0c3df3e9f9f58"
      },
      {
        "level": "Intermediate",
        "title": "Multi-Model Databases: Redis",
        "slug": "multi-model-redis",
        "description": "Use Redis as a multi-model database for caching, sessions, and real-time data.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f53",
        "moduleId": "68cf5c5036b0c3df3e9f9f4f",
        "contentId": "68cf5c5036b0c3df3e9f9f59"
      },
      {
        "level": "Intermediate",
        "title": "Multi-Model Databases: Elasticsearch and Neo4j",
        "slug": "multi-model-elastic-neo4j",
        "description": "Implement Elasticsearch for search and Neo4j for graph-based data alongside SQL databases.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f54",
        "moduleId": "68cf5c5036b0c3df3e9f9f4f",
        "contentId": "68cf5c5036b0c3df3e9f9f5a"
      },
      {
        "level": "Intermediate",
        "title": "Implementing CQRS with Postgres + Elasticsearch",
        "slug": "cqrs-postgres-elastic",
        "description": "Build a sample project using CQRS with Postgres for writes and Elasticsearch for reads.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f55",
        "moduleId": "68cf5c5036b0c3df3e9f9f4f",
        "contentId": "68cf5c5036b0c3df3e9f9f5b"
      }
    ],
    "learningContents": [
      {
        "level": "Intermediate",
        "explanation": "Polyglot persistence uses multiple database types to match diverse data needs, improving performance and flexibility. This lesson introduces polyglot persistence, its benefits, and when to use different models like relational, NoSQL, and graph databases. You’ll learn to set up a project with multiple databases and understand trade-offs for scalable architectures.",
        "examples": [
          "Polyglot setup: Use Postgres for transactions, Redis for caching, Elasticsearch for search.",
          "Run: docker-compose up // Start multi-DB environment"
        ],
        "realWorldApplication": "Polyglot persistence powers apps like Netflix (Cassandra + MySQL) or Uber (PostgreSQL + Redis).",
        "expertInsights": "Choose databases by data characteristics. Monitor query performance across models.",
        "commonMistakes": [
          "Using one database for all needs, causing bottlenecks.",
          "Ignoring data synchronization between models."
        ],
        "exercises": [
          {
            "title": "Plan a Polyglot Database Setup",
            "prompt": "Outline a system using Postgres for users and Redis for sessions.",
            "difficulty": "easy",
            "hints": [
              "Define data models",
              "Specify interactions"
            ],
            "solution": "setup.ts: // Postgres: CREATE TABLE users (id SERIAL, name VARCHAR); // Redis: SET session:123 'data'\nmain.ts: // Connect to both: const pg = new PostgresClient(); const redis = new RedisClient();"
          }
        ],
        "quiz": [
          {
            "question": "What is polyglot persistence?",
            "options": [
              "Single DB",
              "Multiple DB types",
              "Static data",
              "UI design"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why use multiple databases?",
            "options": [
              "Simplicity",
              "Match data needs",
              "Faster builds",
              "Better UI"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 30,
        "resources": [
          {
            "title": "Polyglot Persistence by Martin Fowler",
            "url": "https://martinfowler.com/bliki/PolyglotPersistence.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f56",
        "lessonId": "68cf5c5036b0c3df3e9f9f50"
      },
      {
        "level": "Intermediate",
        "explanation": "CQRS separates read and write operations into distinct models, optimizing for different needs. Commands handle writes (e.g., create, update), while queries handle reads. This lesson covers implementing CQRS, using separate stores for commands and queries, and scaling independently.",
        "examples": [
          "Command: class CreateUser { async execute(data: UserData) { await commandStore.save(data); } }",
          "Query: class GetUser { async execute(id: string) { return await queryStore.find(id); } }"
        ],
        "realWorldApplication": "CQRS is used in e-commerce for order processing (writes) and reporting (reads).",
        "expertInsights": "Combine CQRS with event sourcing for audit trails. Scale read models horizontally.",
        "commonMistakes": [
          "Syncing read/write models incorrectly, causing inconsistencies.",
          "Overapplying CQRS to simple apps, adding complexity."
        ],
        "exercises": [
          {
            "title": "Implement Basic CQRS",
            "prompt": "Create command and query handlers for a user entity.",
            "difficulty": "medium",
            "hints": [
              "Define separate stores",
              "Implement execute methods"
            ],
            "solution": "cqrs.ts: interface UserData { id: string; name: string; } class CommandStore { async save(data: UserData) { console.log('Saved:', data); } } class QueryStore { async find(id: string) { return { id, name: 'Alice' }; } } class CreateUserCommand { constructor(private store: CommandStore) {} async execute(data: UserData) { await this.store.save(data); } } class GetUserQuery { constructor(private store: QueryStore) {} async execute(id: string) { return await this.store.find(id); } }"
          }
        ],
        "quiz": [
          {
            "question": "What does CQRS separate?",
            "options": [
              "UI and logic",
              "Reads and writes",
              "Frontend and backend",
              "DB and cache"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What benefits CQRS?",
            "options": [
              "Simpler code",
              "Optimized scaling",
              "Fewer DBs",
              "Better UI"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 45,
        "resources": [
          {
            "title": "CQRS by Martin Fowler",
            "url": "https://martinfowler.com/bliki/CQRS.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f57",
        "lessonId": "68cf5c5036b0c3df3e9f9f51"
      },
      {
        "level": "Intermediate",
        "explanation": "Sharding distributes data across multiple databases for horizontal scaling, replication copies data for availability, and partitioning divides data within a database. This lesson covers implementing these techniques, choosing sharding keys, and ensuring data consistency.",
        "examples": [
          "Sharding: Shard users by ID modulo 4 across 4 DBs.",
          "Replication: Master-slave setup for read scaling."
        ],
        "realWorldApplication": "Sharding is used in MongoDB for large datasets; replication in MySQL for high availability.",
        "expertInsights": "Choose sharding keys wisely to avoid hotspots. Use async replication for better performance.",
        "commonMistakes": [
          "Poor sharding keys, causing uneven distribution.",
          "Synchronous replication, slowing writes."
        ],
        "exercises": [
          {
            "title": "Design a Sharded System",
            "prompt": "Outline a sharding strategy for user data across 3 databases.",
            "difficulty": "medium",
            "hints": [
              "Use user ID hash",
              "Define routing logic"
            ],
            "solution": "sharding.ts: function getShard(userId: string): number { return parseInt(userId) % 3; }\n// Route to DB[getShard(id)]"
          }
        ],
        "quiz": [
          {
            "question": "What does sharding enable?",
            "options": [
              "Vertical scaling",
              "Horizontal scaling",
              "Better UI",
              "Faster code"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What is replication for?",
            "options": [
              "Data distribution",
              "Availability",
              "Query optimization",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Database Sharding",
            "url": "https://www.mongodb.com/basics/database-sharding",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f58",
        "lessonId": "68cf5c5036b0c3df3e9f9f52"
      },
      {
        "level": "Intermediate",
        "explanation": "Redis supports multiple data models (strings, lists, sets, hashes) for caching, queues, and real-time data. This lesson covers using Redis alongside SQL for polyglot persistence, implementing caching layers, and session management.",
        "examples": [
          "Redis cache: redis.set('user:1', JSON.stringify(user)); redis.get('user:1');",
          "List queue: redis.lpush('tasks', 'Task 1'); redis.rpop('tasks');"
        ],
        "realWorldApplication": "Redis is used in session stores for web apps or leaderboards in gaming platforms.",
        "expertInsights": "Use Redis for hot data only. Set TTLs to prevent memory bloat.",
        "commonMistakes": [
          "Storing large objects, causing memory issues.",
          "No fallback for Redis failures."
        ],
        "exercises": [
          {
            "title": "Implement Redis Caching",
            "prompt": "Create a cache layer for user data in Redis alongside SQL.",
            "difficulty": "medium",
            "hints": [
              "Use redis.set/get",
              "Fallback to SQL"
            ],
            "solution": "cache.ts: import redis from 'redis'; const client = redis.createClient(); async function getUser(id: string) { let user = await client.get(`user:${id}`); if (user) return JSON.parse(user); user = await sqlQuery(`SELECT * FROM users WHERE id = ?`, [id]); await client.set(`user:${id}`, JSON.stringify(user), 'EX', 3600); return user; }"
          }
        ],
        "quiz": [
          {
            "question": "What data model does Redis support?",
            "options": [
              "SQL only",
              "Multi-model",
              "Graph only",
              "Document only"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What is Redis used for?",
            "options": [
              "Persistent storage",
              "Caching",
              "UI rendering",
              "Code bundling"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Redis Documentation",
            "url": "https://redis.io/docs/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f59",
        "lessonId": "68cf5c5036b0c3df3e9f9f53"
      },
      {
        "level": "Intermediate",
        "explanation": "Elasticsearch excels in search and analytics, while Neo4j handles graph data for relationships. Used alongside SQL for polyglot persistence, they enhance query capabilities. This lesson covers integrating Elasticsearch for full-text search and Neo4j for graph queries in a backend system.",
        "examples": [
          "Elasticsearch: client.search({ index: 'users', body: { query: { match: { name: 'Alice' } } } });",
          "Neo4j: MATCH (u:User)-[:FRIENDS_WITH]->(f) RETURN f;"
        ],
        "realWorldApplication": "Elasticsearch is used in search engines; Neo4j in social networks or recommendation systems.",
        "expertInsights": "Index only necessary fields in Elasticsearch. Use Cypher for efficient Neo4j queries.",
        "commonMistakes": [
          "Poor indexing in Elasticsearch, slowing searches.",
          "Complex Neo4j queries without optimization."
        ],
        "exercises": [
          {
            "title": "Integrate Elasticsearch Search",
            "prompt": "Add full-text search to a user system using Elasticsearch.",
            "difficulty": "medium",
            "hints": [
              "Use client.search",
              "Index user data"
            ],
            "solution": "search.ts: const { Client } = require('@elastic/elasticsearch'); const client = new Client(); async function searchUsers(query: string) { const result = await client.search({ index: 'users', body: { query: { match: { name: query } } } }); return result.body.hits.hits; }\n// Index: await client.index({ index: 'users', body: { name: 'Alice' } });"
          }
        ],
        "quiz": [
          {
            "question": "What is Elasticsearch best for?",
            "options": [
              "Graph queries",
              "Full-text search",
              "Transactions",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What does Neo4j use for queries?",
            "options": [
              "SQL",
              "Cypher",
              "MongoDB",
              "Redis"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Elasticsearch Documentation",
            "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html",
            "type": "doc"
          },
          {
            "title": "Neo4j Documentation",
            "url": "https://neo4j.com/docs/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f5a",
        "lessonId": "68cf5c5036b0c3df3e9f9f54"
      },
      {
        "level": "Intermediate",
        "explanation": "Implementing CQRS with Postgres (for writes) and Elasticsearch (for reads) separates concerns for scalability. Commands update Postgres, events sync to Elasticsearch for queries. This lesson guides you through building a sample project, syncing data, and deploying the system.",
        "examples": [
          "Command: await postgres.query('INSERT INTO users ...'); await elasticsearch.index({ body: user });",
          "Query: const results = await elasticsearch.search({ query: { match: { name: 'Alice' } } });"
        ],
        "realWorldApplication": "CQRS with polyglot DBs is used in reporting systems or search-heavy apps like e-commerce search.",
        "expertInsights": "Use event sourcing to sync reads/writes. Monitor sync lag for consistency.",
        "commonMistakes": [
          "Async sync failures, causing data drift.",
          "Overloading read model with write operations."
        ],
        "exercises": [
          {
            "title": "Implement CQRS with Postgres + Elastic",
            "prompt": "Build a CQRS system where user creation updates Postgres and indexes Elasticsearch.",
            "difficulty": "hard",
            "hints": [
              "Use Postgres for commands",
              "Elasticsearch for queries"
            ],
            "solution": "cqrs.ts: import { Pool } from 'pg'; import { Client } from '@elastic/elasticsearch'; const pgPool = new Pool(); const elasticClient = new Client(); async function createUser(user: User) { // Command await pgPool.query('INSERT INTO users (id, name) VALUES ($1, $2)', [user.id, user.name]); // Sync to read model await elasticClient.index({ index: 'users', body: user }); } async function searchUsers(query: string) { // Query const result = await elasticClient.search({ index: 'users', body: { query: { match: { name: query } } } }); return result.body.hits.hits; }\nmain.ts: createUser({ id: '1', name: 'Alice' }); searchUsers('Alice');"
          }
        ],
        "quiz": [
          {
            "question": "What does CQRS use Postgres for?",
            "options": [
              "Reads",
              "Writes",
              "Caching",
              "Search"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why sync to Elasticsearch?",
            "options": [
              "Transactions",
              "Fast search",
              "Storage",
              "UI"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 60,
        "resources": [
          {
            "title": "CQRS with Polyglot Persistence",
            "url": "https://www.infoq.com/articles/polyglot-persistence-cqrs/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f5b",
        "lessonId": "68cf5c5036b0c3df3e9f9f55"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Intermediate",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master authentication and identity management at scale, covering OAuth2.0, OpenID Connect, SSO, and zero-trust principles for secure systems.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f5c"
      }
    ],
    "courses": [
      {
        "title": "Authentication & Identity at Scale",
        "slug": "authentication-identity-scale",
        "shortDescription": "An intermediate course on scalable authentication using OAuth2.0, OpenID Connect, SSO with SAML/OIDC, and zero-trust authorization with OPA and Casbin.",
        "longDescription": "This course explores advanced authentication and identity management techniques for scalable systems, focusing on OAuth2.0 flows, OpenID Connect, single sign-on (SSO) with SAML and OIDC federation, and zero-trust principles using tools like OPA and Casbin. Through hands-on exercises, real-world examples, and quizzes, you’ll implement SSO integration with a mock identity provider (IdP). The course covers secure token management, fine-grained authorization, and scalable identity solutions, preparing you for building secure, enterprise-grade applications.",
        "tags": [
          "authentication",
          "oauth2",
          "openid-connect",
          "sso",
          "zero-trust",
          "opa",
          "casbin",
          "identity"
        ],
        "thumbnail": "https://example.com/thumbnails/authentication-identity.jpg",
        "levelSummary": [
          {
            "level": "Intermediate",
            "overview": "Master scalable authentication and identity management with OAuth2.0, SSO, and zero-trust authorization for secure applications.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f5d",
        "domainId": "68cf5c5036b0c3df3e9f9f5c"
      }
    ],
    "modules": [
      {
        "level": "Intermediate",
        "title": "Module 1 — Authentication & Identity at Scale",
        "slug": "authentication-identity-scale",
        "description": "Learn OAuth2.0, OpenID Connect, SSO with SAML/OIDC, and zero-trust authorization to build secure, scalable identity systems.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f5e",
        "courseId": "68cf5c5036b0c3df3e9f9f5d",
        "lessonIds": [
          "68cf5c5036b0c3df3e9f9f5f",
          "68cf5c5036b0c3df3e9f9f60",
          "68cf5c5036b0c3df3e9f9f61",
          "68cf5c5036b0c3df3e9f9f62",
          "68cf5c5036b0c3df3e9f9f63",
          "68cf5c5036b0c3df3e9f9f64"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Intermediate",
        "title": "Introduction to Authentication & Identity",
        "slug": "intro-authentication-identity",
        "description": "Understand the principles of authentication and identity management in scalable systems.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f5f",
        "moduleId": "68cf5c5036b0c3df3e9f9f5e",
        "contentId": "68cf5c5036b0c3df3e9f9f65"
      },
      {
        "level": "Intermediate",
        "title": "OAuth2.0 Flows in Depth",
        "slug": "oauth2-flows",
        "description": "Explore OAuth2.0 flows, including authorization code, implicit, and client credentials.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f60",
        "moduleId": "68cf5c5036b0c3df3e9f9f5e",
        "contentId": "68cf5c5036b0c3df3e9f9f66"
      },
      {
        "level": "Intermediate",
        "title": "OpenID Connect for Identity",
        "slug": "openid-connect",
        "description": "Implement OpenID Connect for secure identity management on top of OAuth2.0.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f61",
        "moduleId": "68cf5c5036b0c3df3e9f9f5e",
        "contentId": "68cf5c5036b0c3df3e9f9f67"
      },
      {
        "level": "Intermediate",
        "title": "Single Sign-On (SSO) with SAML and OIDC",
        "slug": "sso-saml-oidc",
        "description": "Learn single sign-on using SAML and OIDC federation for seamless user access.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f62",
        "moduleId": "68cf5c5036b0c3df3e9f9f5e",
        "contentId": "68cf5c5036b0c3df3e9f9f68"
      },
      {
        "level": "Intermediate",
        "title": "Zero-Trust and Fine-Grained Authorization",
        "slug": "zero-trust-authorization",
        "description": "Apply zero-trust principles and fine-grained authorization using OPA and Casbin.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f63",
        "moduleId": "68cf5c5036b0c3df3e9f9f5e",
        "contentId": "68cf5c5036b0c3df3e9f9f69"
      },
      {
        "level": "Intermediate",
        "title": "Implementing SSO with a Mock IdP",
        "slug": "sso-mock-idp",
        "description": "Integrate SSO with a mock identity provider for secure, scalable authentication.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f64",
        "moduleId": "68cf5c5036b0c3df3e9f9f5e",
        "contentId": "68cf5c5036b0c3df3e9f9f6a"
      }
    ],
    "learningContents": [
      {
        "level": "Intermediate",
        "explanation": "Authentication and identity management at scale ensure secure, seamless user access across systems. This lesson introduces OAuth2.0, OpenID Connect, SSO, and zero-trust principles, covering their roles in modern applications. You’ll learn to set up a secure authentication project and understand trade-offs for scalability and security.",
        "examples": [
          "OAuth2.0: Redirect to /authorize?client_id=123&scope=openid",
          "Run: npm install express passport // Initialize auth project"
        ],
        "realWorldApplication": "These techniques are used in enterprise apps like Google Workspace or Microsoft Azure for secure identity management.",
        "expertInsights": "Prioritize secure token storage and refresh mechanisms. Use standards like OIDC for interoperability.",
        "commonMistakes": [
          "Storing tokens insecurely, risking breaches.",
          "Ignoring token expiration, breaking user sessions."
        ],
        "exercises": [
          {
            "title": "Plan an Authentication System",
            "prompt": "Outline an authentication system using OAuth2.0 and SSO.",
            "difficulty": "easy",
            "hints": [
              "Include client and IdP",
              "Define token flow"
            ],
            "solution": "auth.ts: const authConfig = { clientId: '123', redirectUri: 'http://localhost/callback', scope: 'openid profile' }; // Setup: npm install passport-oauth2"
          }
        ],
        "quiz": [
          {
            "question": "What improves authentication scalability?",
            "options": [
              "Monoliths",
              "SSO",
              "Local storage",
              "Inline scripts"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why use OAuth2.0?",
            "options": [
              "UI design",
              "Secure access",
              "Database queries",
              "Code bundling"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 30,
        "resources": [
          {
            "title": "OAuth 2.0 Specification",
            "url": "https://oauth.net/2/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f65",
        "lessonId": "68cf5c5036b0c3df3e9f9f5f"
      },
      {
        "level": "Intermediate",
        "explanation": "OAuth2.0 provides secure delegated access through flows like authorization code, implicit, and client credentials. Each flow suits different use cases, from web apps to APIs. This lesson covers implementing OAuth2.0 flows, securing tokens, and testing authentication in a backend system.",
        "examples": [
          "Authorization code: GET /authorize?response_type=code&client_id=123",
          "Token request: POST /token with client_id, code, and client_secret"
        ],
        "realWorldApplication": "OAuth2.0 is used by platforms like GitHub or Spotify for secure API access.",
        "expertInsights": "Use authorization code flow for web apps. Validate tokens with JWKS for security.",
        "commonMistakes": [
          "Using implicit flow for public clients, risking token leaks.",
          "Not validating scopes, allowing unauthorized access."
        ],
        "exercises": [
          {
            "title": "Implement OAuth2.0 Authorization Code Flow",
            "prompt": "Set up an OAuth2.0 authorization code flow with a mock provider.",
            "difficulty": "medium",
            "hints": [
              "Use passport-oauth2",
              "Handle redirect and token exchange"
            ],
            "solution": "server.ts: const express = require('express'); const passport = require('passport'); const OAuth2Strategy = require('passport-oauth2').Strategy; passport.use(new OAuth2Strategy({ authorizationURL: 'https://mock-idp/authorize', tokenURL: 'https://mock-idp/token', clientID: '123', clientSecret: 'secret', callbackURL: 'http://localhost/callback' }, (accessToken, refreshToken, profile, done) => done(null, profile))); const app = express(); app.get('/auth', passport.authenticate('oauth2')); app.get('/callback', passport.authenticate('oauth2', { successRedirect: '/', failureRedirect: '/login' })); app.listen(3000);"
          }
        ],
        "quiz": [
          {
            "question": "What is the OAuth2.0 authorization code flow for?",
            "options": [
              "APIs only",
              "Web apps",
              "Static sites",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What secures OAuth2.0 tokens?",
            "options": [
              "Client secret",
              "Public key",
              "Database",
              "UI"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 45,
        "resources": [
          {
            "title": "OAuth 2.0 Authorization Code Flow",
            "url": "https://oauth.net/2/grant-types/authorization-code/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f66",
        "lessonId": "68cf5c5036b0c3df3e9f9f60"
      },
      {
        "level": "Intermediate",
        "explanation": "OpenID Connect (OIDC) extends OAuth2.0 to provide identity information via ID tokens. It standardizes user authentication across providers. This lesson covers implementing OIDC, validating ID tokens, and integrating with an OAuth2.0 flow for secure identity management.",
        "examples": [
          "OIDC: Request scope=openid to get id_token in JWT format.",
          "Validate: jwt.verify(id_token, publicKey);"
        ],
        "realWorldApplication": "OIDC is used by Google and Okta for secure user authentication.",
        "expertInsights": "Always validate ID tokens with issuer and audience. Use OIDC discovery for provider metadata.",
        "commonMistakes": [
          "Not validating ID tokens, risking impersonation.",
          "Ignoring nonce checks, allowing replay attacks."
        ],
        "exercises": [
          {
            "title": "Implement OpenID Connect",
            "prompt": "Add OIDC to an OAuth2.0 flow with ID token validation.",
            "difficulty": "medium",
            "hints": [
              "Request openid scope",
              "Verify JWT signature"
            ],
            "solution": "server.ts: const express = require('express'); const passport = require('passport'); const OAuth2Strategy = require('passport-oauth2').Strategy; const jwt = require('jsonwebtoken'); passport.use(new OAuth2Strategy({ authorizationURL: 'https://mock-idp/authorize', tokenURL: 'https://mock-idp/token', clientID: '123', clientSecret: 'secret', callbackURL: 'http://localhost/callback', scope: 'openid' }, (accessToken, refreshToken, params, profile, done) => { jwt.verify(params.id_token, 'publicKey', { issuer: 'mock-idp' }, (err, decoded) => done(err, decoded)); })); const app = express(); app.get('/auth', passport.authenticate('oauth2')); app.get('/callback', passport.authenticate('oauth2', { successRedirect: '/', failureRedirect: '/login' })); app.listen(3000);"
          }
        ],
        "quiz": [
          {
            "question": "What does OpenID Connect provide?",
            "options": [
              "Caching",
              "Identity information",
              "Database queries",
              "UI styling"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What validates an ID token?",
            "options": [
              "Client secret",
              "JWT signature",
              "Session ID",
              "API key"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "OpenID Connect Specification",
            "url": "https://openid.net/connect/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f67",
        "lessonId": "68cf5c5036b0c3df3e9f9f61"
      },
      {
        "level": "Intermediate",
        "explanation": "Single Sign-On (SSO) allows users to authenticate once and access multiple applications. SAML and OIDC federation are common protocols for SSO. This lesson covers configuring SSO with SAML and OIDC, integrating with an identity provider, and testing seamless access across services.",
        "examples": [
          "SAML: POST /saml with SAMLResponse XML",
          "OIDC: Redirect to /authorize with openid scope"
        ],
        "realWorldApplication": "SSO is used in enterprise systems like Okta or Auth0 for unified access.",
        "expertInsights": "Use OIDC for modern apps, SAML for legacy systems. Ensure secure redirect URIs.",
        "commonMistakes": [
          "Misconfiguring IdP metadata, breaking SSO.",
          "Not securing SAML responses, risking interception."
        ],
        "exercises": [
          {
            "title": "Set Up SSO with OIDC",
            "prompt": "Configure SSO using OIDC with a mock identity provider.",
            "difficulty": "medium",
            "hints": [
              "Use passport-openidconnect",
              "Define redirect URI"
            ],
            "solution": "server.ts: const express = require('express'); const passport = require('passport'); const OpenIDConnectStrategy = require('passport-openidconnect').Strategy; passport.use(new OpenIDConnectStrategy({ issuer: 'https://mock-idp', authorizationURL: 'https://mock-idp/authorize', tokenURL: 'https://mock-idp/token', clientID: '123', clientSecret: 'secret', callbackURL: 'http://localhost/callback' }, (iss, sub, profile, done) => done(null, profile))); const app = express(); app.get('/auth', passport.authenticate('openidconnect')); app.get('/callback', passport.authenticate('openidconnect', { successRedirect: '/', failureRedirect: '/login' })); app.listen(3000);"
          }
        ],
        "quiz": [
          {
            "question": "What does SSO enable?",
            "options": [
              "Single login",
              "Multiple logins",
              "Database access",
              "UI rendering"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What protocol supports SSO?",
            "options": [
              "HTTP",
              "SAML",
              "CSS",
              "SQL"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "SAML vs OIDC",
            "url": "https://auth0.com/docs/authenticate/protocols/saml-vs-oidc",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f68",
        "lessonId": "68cf5c5036b0c3df3e9f9f62"
      },
      {
        "level": "Intermediate",
        "explanation": "Zero-trust principles assume no trust, requiring continuous verification. Tools like OPA (Open Policy Agent) and Casbin provide fine-grained authorization. This lesson covers implementing zero-trust policies, defining roles with OPA/Casbin, and testing authorization rules in a backend system.",
        "examples": [
          "OPA policy: allow = true { input.user.roles[_] == 'admin' }",
          "Casbin: e.enforce('user', 'resource', 'read') // Check permission"
        ],
        "realWorldApplication": "Zero-trust is used in cloud platforms like AWS or Kubernetes for secure access control.",
        "expertInsights": "Use OPA for dynamic policies, Casbin for simpler RBAC. Test policies with edge cases.",
        "commonMistakes": [
          "Overly permissive policies, risking unauthorized access.",
          "Not updating policies, causing outdated permissions."
        ],
        "exercises": [
          {
            "title": "Implement Zero-Trust with Casbin",
            "prompt": "Set up Casbin for role-based access control in a backend.",
            "difficulty": "medium",
            "hints": [
              "Define policy model",
              "Enforce permissions"
            ],
            "solution": "casbin.ts: const { newEnforcer } = require('casbin'); async function setup() { const enforcer = await newEnforcer('model.conf', 'policy.csv'); // model.conf: [request_definition]\nr = sub, obj, act\n[policy_definition]\np = sub, obj, act\n[policy_effect]\ne = some(where (p.eft == allow))\n[matchers]\nm = r.sub == p.sub && r.obj == p.obj && r.act == p.act\n// policy.csv: p, admin, data, read\nawait enforcer.addPolicy('admin', 'data', 'read'); const allowed = await enforcer.enforce('admin', 'data', 'read'); console.log(allowed); // true } setup();"
          }
        ],
        "quiz": [
          {
            "question": "What does zero-trust assume?",
            "options": [
              "Full trust",
              "No trust",
              "Local trust",
              "UI trust"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What tool provides fine-grained authorization?",
            "options": [
              "Redis",
              "OPA",
              "MongoDB",
              "Vite"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Open Policy Agent Documentation",
            "url": "https://www.openpolicyagent.org/docs/latest/",
            "type": "doc"
          },
          {
            "title": "Casbin Documentation",
            "url": "https://casbin.org/docs/en/overview",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f69",
        "lessonId": "68cf5c5036b0c3df3e9f9f63"
      },
      {
        "level": "Intermediate",
        "explanation": "Integrating SSO with a mock identity provider (IdP) enables seamless authentication across applications. This lesson guides you through setting up SSO using OIDC, connecting to a mock IdP, and testing secure user access. You’ll learn to handle tokens, validate sessions, and deploy the system.",
        "examples": [
          "OIDC redirect: GET /authorize?client_id=123&scope=openid",
          "Callback: Validate id_token and redirect to app"
        ],
        "realWorldApplication": "SSO integration is used in enterprise apps for unified access across tools like Slack or Jira.",
        "expertInsights": "Test IdP integration with mock servers first. Secure callback routes to prevent attacks.",
        "commonMistakes": [
          "Misconfiguring redirect URIs, breaking authentication.",
          "Not validating tokens, allowing unauthorized access."
        ],
        "exercises": [
          {
            "title": "Integrate SSO with Mock IdP",
            "prompt": "Set up SSO using OIDC with a mock IdP and validate user sessions.",
            "difficulty": "hard",
            "hints": [
              "Use passport-openidconnect",
              "Validate id_token"
            ],
            "solution": "server.ts: const express = require('express'); const passport = require('passport'); const OpenIDConnectStrategy = require('passport-openidconnect').Strategy; const jwt = require('jsonwebtoken'); passport.use(new OpenIDConnectStrategy({ issuer: 'https://mock-idp', authorizationURL: 'https://mock-idp/authorize', tokenURL: 'https://mock-idp/token', clientID: '123', clientSecret: 'secret', callbackURL: 'http://localhost/callback', scope: 'openid profile' }, (iss, sub, profile, jwtClaims, accessToken, refreshToken, params, done) => { jwt.verify(params.id_token, 'publicKey', { issuer: 'mock-idp' }, (err, decoded) => done(err, decoded)); })); const app = express(); app.use(passport.initialize()); app.get('/auth', passport.authenticate('openidconnect')); app.get('/callback', passport.authenticate('openidconnect', { successRedirect: '/', failureRedirect: '/login' })); app.get('/', (req, res) => res.send('Authenticated')); app.listen(3000);"
          }
        ],
        "quiz": [
          {
            "question": "What does SSO integration require?",
            "options": [
              "Local storage",
              "Identity provider",
              "Database",
              "UI framework"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why validate id_token in SSO?",
            "options": [
              "Faster login",
              "Prevent unauthorized access",
              "Smaller code",
              "Better UX"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 60,
        "resources": [
          {
            "title": "OIDC SSO Integration",
            "url": "https://auth0.com/docs/authenticate/single-sign-on",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f6a",
        "lessonId": "68cf5c5036b0c3df3e9f9f64"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Intermediate",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master advanced API architectures, including gRPC, GraphQL Federation, Backend for Frontend (BFF), API gateways, rate limiting, and multi-tenant support for scalable systems.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f6b"
      }
    ],
    "courses": [
      {
        "title": "Advanced API Architectures",
        "slug": "advanced-api-architectures",
        "shortDescription": "An intermediate course on designing scalable APIs using gRPC, GraphQL Federation, BFF, API gateways, rate limiting, and multi-tenant support.",
        "longDescription": "This course explores advanced API architectures, focusing on gRPC for high-performance services, GraphQL Federation for modular APIs, Backend for Frontend (BFF) patterns, API gateways, rate limiting, circuit breakers, and API monetization with multi-tenant support. Through hands-on exercises, real-world examples, and quizzes, you’ll build a gRPC service integrated with a GraphQL federation layer. The course covers designing scalable, secure, and resilient APIs, preparing you for enterprise-grade API development.",
        "tags": [
          "api",
          "grpc",
          "graphql",
          "bff",
          "api-gateway",
          "rate-limiting",
          "circuit-breakers",
          "multi-tenant"
        ],
        "thumbnail": "https://example.com/thumbnails/advanced-api.jpg",
        "levelSummary": [
          {
            "level": "Intermediate",
            "overview": "Master advanced API architectures with gRPC, GraphQL Federation, BFF, and API gateways for scalable, secure systems.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f6c",
        "domainId": "68cf5c5036b0c3df3e9f9f6b"
      }
    ],
    "modules": [
      {
        "level": "Intermediate",
        "title": "Module 1 — Advanced API Architectures",
        "slug": "advanced-api-architectures",
        "description": "Learn gRPC, GraphQL Federation, BFF, API gateways, rate limiting, circuit breakers, and multi-tenant API design for scalable systems.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f6d",
        "courseId": "68cf5c5036b0c3df3e9f9f6c",
        "lessonIds": [
          "68cf5c5036b0c3df3e9f9f6e",
          "68cf5c5036b0c3df3e9f9f6f",
          "68cf5c5036b0c3df3e9f9f70",
          "68cf5c5036b0c3df3e9f9f71",
          "68cf5c5036b0c3df3e9f9f72",
          "68cf5c5036b0c3df3e9f9f73",
          "68cf5c5036b0c3df3e9f9f74"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Intermediate",
        "title": "Introduction to Advanced API Architectures",
        "slug": "intro-api-architectures",
        "description": "Understand the principles of advanced API design for scalable and resilient systems.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f6e",
        "moduleId": "68cf5c5036b0c3df3e9f9f6d",
        "contentId": "68cf5c5036b0c3df3e9f9f75"
      },
      {
        "level": "Intermediate",
        "title": "gRPC for High-Performance APIs",
        "slug": "grpc-high-performance",
        "description": "Explore gRPC for building high-performance, type-safe APIs using protocol buffers.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f6f",
        "moduleId": "68cf5c5036b0c3df3e9f9f6d",
        "contentId": "68cf5c5036b0c3df3e9f9f76"
      },
      {
        "level": "Intermediate",
        "title": "GraphQL Federation for Modular APIs",
        "slug": "graphql-federation",
        "description": "Learn GraphQL Federation to build modular, scalable GraphQL APIs across services.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f70",
        "moduleId": "68cf5c5036b0c3df3e9f9f6d",
        "contentId": "68cf5c5036b0c3df3e9f9f77"
      },
      {
        "level": "Intermediate",
        "title": "Backend for Frontend (BFF) Patterns",
        "slug": "bff-patterns",
        "description": "Implement Backend for Frontend patterns to tailor APIs for specific clients.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f71",
        "moduleId": "68cf5c5036b0c3df3e9f9f6d",
        "contentId": "68cf5c5036b0c3df3e9f9f78"
      },
      {
        "level": "Intermediate",
        "title": "API Gateways, Rate Limiting, and Circuit Breakers",
        "slug": "api-gateways",
        "description": "Use API gateways, rate limiting, and circuit breakers for secure, resilient APIs.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f72",
        "moduleId": "68cf5c5036b0c3df3e9f9f6d",
        "contentId": "68cf5c5036b0c3df3e9f9f79"
      },
      {
        "level": "Intermediate",
        "title": "API Monetization and Multi-Tenant Support",
        "slug": "api-monetization-multi-tenant",
        "description": "Design APIs with monetization strategies and multi-tenant support for scalability.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f73",
        "moduleId": "68cf5c5036b0c3df3e9f9f6d",
        "contentId": "68cf5c5036b0c3df3e9f9f7a"
      },
      {
        "level": "Intermediate",
        "title": "Building a gRPC Service + GraphQL Federation Layer",
        "slug": "grpc-graphql-federation",
        "description": "Implement a gRPC service integrated with a GraphQL federation layer for a scalable API.",
        "order": 7,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f74",
        "moduleId": "68cf5c5036b0c3df3e9f9f6d",
        "contentId": "68cf5c5036b0c3df3e9f9f7b"
      }
    ],
    "learningContents": [
      {
        "level": "Intermediate",
        "explanation": "Advanced API architectures enable scalable, secure, and resilient systems using modern approaches like gRPC, GraphQL Federation, and BFF patterns. This lesson introduces these concepts, their benefits, and how to set up a project for advanced API development, covering gateways, rate limiting, and multi-tenant strategies.",
        "examples": [
          "gRPC: service UserService { rpc GetUser (UserRequest) returns (UserResponse); }",
          "Run: npm init -y // Initialize API project"
        ],
        "realWorldApplication": "These architectures power APIs for platforms like Netflix, Shopify, or Google Cloud.",
        "expertInsights": "Choose gRPC for performance, GraphQL for flexibility. Use gateways for centralized control.",
        "commonMistakes": [
          "Overcomplicating APIs with unnecessary layers.",
          "Ignoring rate limiting, causing system overload."
        ],
        "exercises": [
          {
            "title": "Plan an API Architecture",
            "prompt": "Outline a system with gRPC and GraphQL Federation for user data.",
            "difficulty": "easy",
            "hints": [
              "Define service boundaries",
              "Include gateway"
            ],
            "solution": "api.ts: // gRPC: service UserService { rpc GetUser (UserRequest) returns (UserResponse); }\n// GraphQL: type User @key(fields: \"id\") { id: ID! name: String }\n// Gateway: Configure Apollo Gateway"
          }
        ],
        "quiz": [
          {
            "question": "What improves API scalability?",
            "options": [
              "Monoliths",
              "GraphQL Federation",
              "Inline logic",
              "Local storage"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why use gRPC?",
            "options": [
              "UI rendering",
              "High performance",
              "Database queries",
              "Code bundling"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 30,
        "resources": [
          {
            "title": "API Design Patterns",
            "url": "https://microservices.io/patterns/apigateway.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f75",
        "lessonId": "68cf5c5036b0c3df3e9f9f6e"
      },
      {
        "level": "Intermediate",
        "explanation": "gRPC uses protocol buffers for high-performance, type-safe APIs, ideal for microservices. It supports streaming and low-latency communication. This lesson covers defining gRPC services, generating code, and implementing a server and client for efficient communication.",
        "examples": [
          "Proto: service UserService { rpc GetUser (UserRequest) returns (UserResponse); }",
          "Server: server.addService(UserService, { GetUser: (call, callback) => callback(null, { name: 'Alice' }) });"
        ],
        "realWorldApplication": "gRPC is used in microservices for platforms like Kubernetes or Istio for fast communication.",
        "expertInsights": "Use proto3 for simplicity. Optimize for streaming in high-throughput systems.",
        "commonMistakes": [
          "Complex proto definitions, reducing clarity.",
          "Not handling errors, breaking clients."
        ],
        "exercises": [
          {
            "title": "Implement a gRPC Service",
            "prompt": "Create a gRPC service for retrieving user data.",
            "difficulty": "medium",
            "hints": [
              "Define a proto file",
              "Implement server logic"
            ],
            "solution": "user.proto: syntax = \"proto3\"; service UserService { rpc GetUser (UserRequest) returns (UserResponse); } message UserRequest { string id = 1; } message UserResponse { string name = 1; }\nserver.ts: const grpc = require('@grpc/grpc-js'); const protoLoader = require('@grpc/proto-loader'); const packageDef = protoLoader.loadSync('user.proto'); const grpcObj = grpc.loadPackageDefinition(packageDef); const server = new grpc.Server(); server.addService(grpcObj.UserService.service, { GetUser: (call, callback) => callback(null, { name: 'Alice' }) }); server.bindAsync('0.0.0.0:50051', grpc.ServerCredentials.createInsecure(), () => server.start());"
          }
        ],
        "quiz": [
          {
            "question": "What does gRPC use for definitions?",
            "options": [
              "JSON",
              "Protocol buffers",
              "XML",
              "YAML"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What benefits gRPC?",
            "options": [
              "UI rendering",
              "High performance",
              "Static sites",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 45,
        "resources": [
          {
            "title": "gRPC Documentation",
            "url": "https://grpc.io/docs/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f76",
        "lessonId": "68cf5c5036b0c3df3e9f9f6f"
      },
      {
        "level": "Intermediate",
        "explanation": "GraphQL Federation enables modular APIs by combining multiple GraphQL services into a unified schema. It supports scalable, distributed API design. This lesson covers setting up a federated GraphQL schema, defining resolvers, and querying across services.",
        "examples": [
          "Schema: type User @key(fields: \"id\") { id: ID! name: String }",
          "Federation: const gateway = new ApolloGateway({ serviceList: [{ name: 'users', url: 'http://localhost:4001' }] });"
        ],
        "realWorldApplication": "GraphQL Federation is used by Netflix and Apollo for modular microservice APIs.",
        "expertInsights": "Use @key for entity resolution. Optimize resolvers to avoid over-fetching.",
        "commonMistakes": [
          "Poor schema design, causing resolver complexity.",
          "Not handling service failures, breaking queries."
        ],
        "exercises": [
          {
            "title": "Set Up GraphQL Federation",
            "prompt": "Create a federated GraphQL schema for a user service.",
            "difficulty": "medium",
            "hints": [
              "Use @apollo/federation",
              "Define a key field"
            ],
            "solution": "schema.graphql: type User @key(fields: \"id\") { id: ID! name: String }\nserver.ts: const { ApolloServer } = require('apollo-server'); const { buildFederatedSchema } = require('@apollo/federation'); const typeDefs = require('fs').readFileSync('schema.graphql', 'utf8'); const resolvers = { User: { __resolveReference(ref) { return { id: ref.id, name: 'Alice' }; } } }; const server = new ApolloServer({ schema: buildFederatedSchema({ typeDefs, resolvers }) }); server.listen(4001);"
          }
        ],
        "quiz": [
          {
            "question": "What does GraphQL Federation enable?",
            "options": [
              "Monolith APIs",
              "Modular APIs",
              "UI rendering",
              "Database queries"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What directive defines entity keys?",
            "options": [
              "@resolver",
              "@key",
              "@query",
              "@schema"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Apollo Federation Documentation",
            "url": "https://www.apollographql.com/docs/federation/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f77",
        "lessonId": "68cf5c5036b0c3df3e9f9f70"
      },
      {
        "level": "Intermediate",
        "explanation": "Backend for Frontend (BFF) patterns tailor APIs to specific client needs, improving performance and developer experience. Each client (web, mobile) gets a dedicated backend. This lesson covers designing a BFF, aggregating data, and optimizing for client-specific requirements.",
        "examples": [
          "BFF: app.get('/mobile/users', async (req, res) => res.json({ simplified: true }));",
          "Aggregation: Combine user and order data for mobile client."
        ],
        "realWorldApplication": "BFF is used by SoundCloud and Airbnb for client-specific APIs.",
        "expertInsights": "Use BFF for client-specific logic only. Avoid duplicating core business logic.",
        "commonMistakes": [
          "Overloading BFF with business logic, reducing reuse.",
          "Not caching responses, slowing clients."
        ],
        "exercises": [
          {
            "title": "Implement a BFF for Mobile",
            "prompt": "Create a BFF endpoint for a mobile client retrieving user data.",
            "difficulty": "medium",
            "hints": [
              "Use Express for BFF",
              "Simplify response data"
            ],
            "solution": "bff.ts: const express = require('express'); const app = express(); app.get('/mobile/users', async (req, res) => { const users = await fetch('http://core-api/users').then(res => res.json()); res.json(users.map(user => ({ id: user.id, name: user.name }))); }); app.listen(3000);"
          }
        ],
        "quiz": [
          {
            "question": "What does BFF tailor APIs for?",
            "options": [
              "Databases",
              "Clients",
              "UI components",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why use a BFF?",
            "options": [
              "Core logic",
              "Client-specific needs",
              "Database scaling",
              "UI rendering"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Backend for Frontend Pattern",
            "url": "https://samnewman.io/patterns/architectural/bff/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f78",
        "lessonId": "68cf5c5036b0c3df3e9f9f71"
      },
      {
        "level": "Intermediate",
        "explanation": "API gateways centralize request routing, rate limiting ensures system stability, and circuit breakers prevent cascading failures. This lesson covers configuring an API gateway, implementing rate limiting, and setting up circuit breakers for resilient APIs.",
        "examples": [
          "Rate limiting: app.use(rateLimit({ windowMs: 60000, max: 100 }));",
          "Circuit breaker: breaker.fire().catch(() => console.log('Service down'));"
        ],
        "realWorldApplication": "API gateways like Kong or AWS API Gateway manage traffic for large-scale apps.",
        "expertInsights": "Use rate limiting for public APIs. Tune circuit breaker thresholds for reliability.",
        "commonMistakes": [
          "Overly restrictive rate limits, blocking valid users.",
          "Ignoring circuit breaker resets, causing downtime."
        ],
        "exercises": [
          {
            "title": "Set Up API Gateway with Rate Limiting",
            "prompt": "Configure an Express API gateway with rate limiting.",
            "difficulty": "medium",
            "hints": [
              "Use express-rate-limit",
              "Define a route"
            ],
            "solution": "gateway.ts: const express = require('express'); const rateLimit = require('express-rate-limit'); const app = express(); app.use(rateLimit({ windowMs: 60000, max: 100 })); app.get('/api/users', async (req, res) => res.json([{ id: '1', name: 'Alice' }])); app.listen(3000);"
          }
        ],
        "quiz": [
          {
            "question": "What does an API gateway manage?",
            "options": [
              "UI rendering",
              "Request routing",
              "Database queries",
              "Code bundling"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What prevents API overload?",
            "options": [
              "Rate limiting",
              "Static sites",
              "Global state",
              "Inline scripts"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "API Gateway Pattern",
            "url": "https://microservices.io/patterns/apigateway.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f79",
        "lessonId": "68cf5c5036b0c3df3e9f9f72"
      },
      {
        "level": "Intermediate",
        "explanation": "API monetization enables revenue through usage tiers, while multi-tenant support isolates data for different clients. This lesson covers designing APIs with monetization (e.g., rate-based billing) and multi-tenant architectures, ensuring scalability and security.",
        "examples": [
          "Monetization: Track API usage with token-based quotas.",
          "Multi-tenant: SELECT * FROM users WHERE tenant_id = ?"
        ],
        "realWorldApplication": "Monetization is used by Stripe or Twilio; multi-tenancy in SaaS like Salesforce.",
        "expertInsights": "Use API keys for monetization tracking. Isolate tenant data with schemas or namespaces.",
        "commonMistakes": [
          "Not securing tenant data, causing leaks.",
          "Poor quota tracking, breaking monetization."
        ],
        "exercises": [
          {
            "title": "Implement Multi-Tenant API",
            "prompt": "Create an API with tenant-based data isolation.",
            "difficulty": "medium",
            "hints": [
              "Use tenant_id in queries",
              "Secure with middleware"
            ],
            "solution": "api.ts: const express = require('express'); const app = express(); app.use((req, res, next) => { req.tenantId = req.headers['x-tenant-id']; next(); }); app.get('/users', async (req, res) => { const users = await db.query('SELECT * FROM users WHERE tenant_id = ?', [req.tenantId]); res.json(users); }); app.listen(3000);"
          }
        ],
        "quiz": [
          {
            "question": "What does multi-tenancy isolate?",
            "options": [
              "UI components",
              "Tenant data",
              "API routes",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What tracks API monetization?",
            "options": [
              "Database",
              "API keys",
              "UI events",
              "Static files"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "API Monetization Strategies",
            "url": "https://www.apimatic.io/blog/api-monetization",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f7a",
        "lessonId": "68cf5c5036b0c3df3e9f9f73"
      },
      {
        "level": "Intermediate",
        "explanation": "Combining a gRPC service with a GraphQL federation layer creates a scalable, modular API architecture. gRPC handles backend services, while GraphQL Federation unifies client queries. This lesson guides you through building a gRPC service, exposing it via GraphQL Federation, and testing the integrated system.",
        "examples": [
          "gRPC: service OrderService { rpc GetOrder (OrderRequest) returns (OrderResponse); }",
          "GraphQL: type Order @key(fields: \"id\") { id: ID! item: String }"
        ],
        "realWorldApplication": "This architecture is used in microservices for apps like e-commerce or streaming platforms.",
        "expertInsights": "Use gRPC for internal services, GraphQL for client-facing APIs. Optimize resolver performance.",
        "commonMistakes": [
          "Overcomplicating resolvers, slowing queries.",
          "Not handling gRPC errors, breaking federation."
        ],
        "exercises": [
          {
            "title": "Build gRPC + GraphQL Federation",
            "prompt": "Create a gRPC order service and expose it via GraphQL Federation.",
            "difficulty": "hard",
            "hints": [
              "Define gRPC proto",
              "Use Apollo Federation"
            ],
            "solution": "order.proto: syntax = \"proto3\"; service OrderService { rpc GetOrder (OrderRequest) returns (OrderResponse); } message OrderRequest { string id = 1; } message OrderResponse { string id = 1; string item = 2; }\ngrpc-server.ts: const grpc = require('@grpc/grpc-js'); const protoLoader = require('@grpc/proto-loader'); const packageDef = protoLoader.loadSync('order.proto'); const grpcObj = grpc.loadPackageDefinition(packageDef); const server = new grpc.Server(); server.addService(grpcObj.OrderService.service, { GetOrder: (call, callback) => callback(null, { id: call.request.id, item: 'Book' }) }); server.bindAsync('0.0.0.0:50051', grpc.ServerCredentials.createInsecure(), () => server.start());\ngraphql-server.ts: const { ApolloServer } = require('apollo-server'); const { buildFederatedSchema } = require('@apollo/federation'); const typeDefs = `type Order @key(fields: \"id\") { id: ID! item: String } type Query { order(id: ID!): Order }`; const resolvers = { Query: { order: async (_, { id }) => { const client = new grpc.Client('localhost:50051', grpc.credentials.createInsecure()); return new Promise((resolve) => client.GetOrder({ id }, (err, res) => resolve(res))); } }, Order: { __resolveReference: async (ref) => { const client = new grpc.Client('localhost:50051', grpc.credentials.createInsecure()); return new Promise((resolve) => client.GetOrder({ id: ref.id }, (err, res) => resolve(res))); } } }; const server = new ApolloServer({ schema: buildFederatedSchema({ typeDefs, resolvers }) }); server.listen(4001);"
          }
        ],
        "quiz": [
          {
            "question": "What does gRPC optimize for?",
            "options": [
              "UI rendering",
              "Performance",
              "Database queries",
              "Static sites"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What unifies GraphQL services?",
            "options": [
              "API gateway",
              "Federation",
              "Monolith",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 60,
        "resources": [
          {
            "title": "gRPC and GraphQL Federation",
            "url": "https://www.apollographql.com/docs/federation/other-servers/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f7b",
        "lessonId": "68cf5c5036b0c3df3e9f9f74"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Intermediate",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master real-time and event-driven systems using WebRTC, Kafka, Redis Streams, and CRDTs for scalable, reliable applications.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f7c"
      }
    ],
    "courses": [
      {
        "title": "Realtime & Event-Driven Systems",
        "slug": "realtime-event-driven-systems",
        "shortDescription": "An intermediate course on building real-time systems with WebRTC, pub/sub scaling using Kafka or Redis Streams, and ensuring idempotency and delivery guarantees.",
        "longDescription": "This course dives into real-time and event-driven architectures, covering WebRTC for peer-to-peer and streaming applications, scaling pub/sub systems with Kafka and Redis Streams, and ensuring idempotency and delivery guarantees. Through hands-on exercises, real-world examples, and quizzes, you’ll build a collaborative document editor using Conflict-free Replicated Data Types (CRDTs). The course focuses on designing scalable, low-latency systems, preparing you for real-time applications like chat, streaming, or collaborative tools.",
        "tags": [
          "realtime",
          "event-driven",
          "webrtc",
          "kafka",
          "redis-streams",
          "crdt",
          "idempotency",
          "pub-sub"
        ],
        "thumbnail": "https://example.com/thumbnails/realtime-systems.jpg",
        "levelSummary": [
          {
            "level": "Intermediate",
            "overview": "Master real-time and event-driven systems with WebRTC, Kafka, Redis Streams, and CRDTs for scalable, reliable applications.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f7d",
        "domainId": "68cf5c5036b0c3df3e9f9f7c"
      }
    ],
    "modules": [
      {
        "level": "Intermediate",
        "title": "Module 1 — Realtime & Event-Driven Systems",
        "slug": "realtime-event-driven-systems",
        "description": "Learn WebRTC, pub/sub scaling with Kafka and Redis Streams, idempotency, and CRDTs for real-time, event-driven applications.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f7e",
        "courseId": "68cf5c5036b0c3df3e9f9f7d",
        "lessonIds": [
          "68cf5c5036b0c3df3e9f9f7f",
          "68cf5c5036b0c3df3e9f9f80",
          "68cf5c5036b0c3df3e9f9f81",
          "68cf5c5036b0c3df3e9f9f82",
          "68cf5c5036b0c3df3e9f9f83",
          "68cf5c5036b0c3df3e9f9f84"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Intermediate",
        "title": "Introduction to Realtime & Event-Driven Systems",
        "slug": "intro-realtime-event-driven",
        "description": "Understand the principles of real-time and event-driven architectures for scalable applications.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f7f",
        "moduleId": "68cf5c5036b0c3df3e9f9f7e",
        "contentId": "68cf5c5036b0c3df3e9f9f85"
      },
      {
        "level": "Intermediate",
        "title": "WebRTC for Peer-to-Peer and Streaming",
        "slug": "webrtc-peer-to-peer",
        "description": "Explore WebRTC for building peer-to-peer communication and real-time streaming applications.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f80",
        "moduleId": "68cf5c5036b0c3df3e9f9f7e",
        "contentId": "68cf5c5036b0c3df3e9f9f86"
      },
      {
        "level": "Intermediate",
        "title": "Scaling Pub/Sub with Kafka",
        "slug": "pubsub-kafka",
        "description": "Learn to scale pub/sub systems using Apache Kafka for high-throughput event streaming.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f81",
        "moduleId": "68cf5c5036b0c3df3e9f9f7e",
        "contentId": "68cf5c5036b0c3df3e9f9f87"
      },
      {
        "level": "Intermediate",
        "title": "Scaling Pub/Sub with Redis Streams",
        "slug": "pubsub-redis-streams",
        "description": "Use Redis Streams for lightweight, scalable pub/sub messaging in real-time systems.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f82",
        "moduleId": "68cf5c5036b0c3df3e9f9f7e",
        "contentId": "68cf5c5036b0c3df3e9f9f88"
      },
      {
        "level": "Intermediate",
        "title": "Idempotency and Delivery Guarantees",
        "slug": "idempotency-delivery",
        "description": "Implement idempotency and delivery guarantees to ensure reliable event-driven systems.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f83",
        "moduleId": "68cf5c5036b0c3df3e9f9f7e",
        "contentId": "68cf5c5036b0c3df3e9f9f89"
      },
      {
        "level": "Intermediate",
        "title": "Building a Collaborative Doc Editor with CRDTs",
        "slug": "collaborative-doc-crdt",
        "description": "Build a real-time collaborative document editor using Conflict-free Replicated Data Types (CRDTs).",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f84",
        "moduleId": "68cf5c5036b0c3df3e9f9f7e",
        "contentId": "68cf5c5036b0c3df3e9f9f8a"
      }
    ],
    "learningContents": [
      {
        "level": "Intermediate",
        "explanation": "Real-time and event-driven systems enable low-latency, scalable applications like chat, streaming, or collaborative tools. This lesson introduces WebRTC, pub/sub systems, idempotency, and CRDTs, explaining their roles in modern architectures. You’ll learn to set up a project for real-time development and understand trade-offs for performance and reliability.",
        "examples": [
          "WebRTC: new RTCPeerConnection() for peer-to-peer connection.",
          "Run: npm install ws kafka-node // Initialize real-time project"
        ],
        "realWorldApplication": "These systems power apps like Zoom (WebRTC), Twitter (Kafka), or Google Docs (CRDTs).",
        "expertInsights": "Optimize WebRTC for low latency. Use idempotency to handle message retries safely.",
        "commonMistakes": [
          "Ignoring network latency, causing delays.",
          "Not ensuring idempotency, leading to duplicate events."
        ],
        "exercises": [
          {
            "title": "Plan a Real-Time System",
            "prompt": "Outline a real-time chat system using WebRTC and Kafka.",
            "difficulty": "easy",
            "hints": [
              "Define peer connections",
              "Include pub/sub topics"
            ],
            "solution": "realtime.ts: const peerConnection = new RTCPeerConnection(); // Kafka: producer.send({ topic: 'chat', messages: [{ value: 'Hello' }] });"
          }
        ],
        "quiz": [
          {
            "question": "What enables real-time communication?",
            "options": [
              "Static files",
              "WebRTC",
              "SQL queries",
              "CSS"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why use pub/sub systems?",
            "options": [
              "UI rendering",
              "Event streaming",
              "Database storage",
              "Code bundling"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 30,
        "resources": [
          {
            "title": "Real-Time Systems Overview",
            "url": "https://ably.com/topic/real-time",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f85",
        "lessonId": "68cf5c5036b0c3df3e9f9f7f"
      },
      {
        "level": "Intermediate",
        "explanation": "WebRTC enables peer-to-peer communication and real-time streaming for applications like video calls or file sharing. It uses RTCPeerConnection for direct connections. This lesson covers setting up WebRTC, handling signaling, and testing real-time communication in a browser-based application.",
        "examples": [
          "Peer connection: const pc = new RTCPeerConnection(); pc.addTrack(stream.getTracks()[0]);",
          "Signaling: ws.send(JSON.stringify({ offer: pc.localDescription }));"
        ],
        "realWorldApplication": "WebRTC is used in Zoom, Google Meet, or peer-to-peer file-sharing apps.",
        "expertInsights": "Use STUN/TURN servers for NAT traversal. Optimize codecs for bandwidth.",
        "commonMistakes": [
          "Not handling ICE failures, breaking connections.",
          "Ignoring signaling security, risking leaks."
        ],
        "exercises": [
          {
            "title": "Set Up WebRTC Peer Connection",
            "prompt": "Create a WebRTC peer-to-peer connection with signaling.",
            "difficulty": "medium",
            "hints": [
              "Use RTCPeerConnection",
              "Set up WebSocket signaling"
            ],
            "solution": "webrtc.js: const pc = new RTCPeerConnection(); const ws = new WebSocket('ws://localhost:8080'); pc.onicecandidate = ({ candidate }) => ws.send(JSON.stringify({ candidate })); ws.onmessage = async ({ data }) => { const msg = JSON.parse(data); if (msg.offer) await pc.setRemoteDescription(msg.offer); if (msg.candidate) await pc.addIceCandidate(msg.candidate); }; async function start() { const offer = await pc.createOffer(); await pc.setLocalDescription(offer); ws.send(JSON.stringify({ offer })); } start();"
          }
        ],
        "quiz": [
          {
            "question": "What does WebRTC enable?",
            "options": [
              "Database queries",
              "Peer-to-peer communication",
              "Static sites",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What handles WebRTC NAT traversal?",
            "options": [
              "SQL",
              "STUN/TURN",
              "Redis",
              "GraphQL"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 45,
        "resources": [
          {
            "title": "WebRTC Documentation",
            "url": "https://webrtc.org/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f86",
        "lessonId": "68cf5c5036b0c3df3e9f9f80"
      },
      {
        "level": "Intermediate",
        "explanation": "Apache Kafka scales pub/sub systems for high-throughput, fault-tolerant event streaming. It uses topics and partitions for distributed messaging. This lesson covers setting up Kafka, publishing and subscribing to topics, and ensuring scalability for real-time systems.",
        "examples": [
          "Producer: producer.send({ topic: 'events', messages: [{ value: 'Event 1' }] });",
          "Consumer: consumer.run({ eachMessage: async ({ message }) => console.log(message.value) });"
        ],
        "realWorldApplication": "Kafka powers real-time analytics in apps like LinkedIn or Netflix.",
        "expertInsights": "Use partitions for parallel processing. Monitor consumer lag for performance.",
        "commonMistakes": [
          "Not scaling partitions, limiting throughput.",
          "Ignoring retention policies, causing storage issues."
        ],
        "exercises": [
          {
            "title": "Set Up Kafka Pub/Sub",
            "prompt": "Create a Kafka producer and consumer for real-time events.",
            "difficulty": "medium",
            "hints": [
              "Use kafkajs",
              "Define a topic"
            ],
            "solution": "producer.ts: const { Kafka } = require('kafkajs'); const kafka = new Kafka({ clientId: 'app', brokers: ['localhost:9092'] }); const producer = kafka.producer(); async function send() { await producer.connect(); await producer.send({ topic: 'events', messages: [{ value: 'Event 1' }] }); } send();\nconsumer.ts: const consumer = kafka.consumer({ groupId: 'group' }); async function consume() { await consumer.connect(); await consumer.subscribe({ topic: 'events' }); await consumer.run({ eachMessage: async ({ message }) => console.log(message.value) }); } consume();"
          }
        ],
        "quiz": [
          {
            "question": "What does Kafka use for messaging?",
            "options": [
              "Files",
              "Topics",
              "Databases",
              "Routes"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What improves Kafka scalability?",
            "options": [
              "Single topic",
              "Partitions",
              "Single consumer",
              "Small messages"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Kafka Documentation",
            "url": "https://kafka.apache.org/documentation/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f87",
        "lessonId": "68cf5c5036b0c3df3e9f9f81"
      },
      {
        "level": "Intermediate",
        "explanation": "Redis Streams provide a lightweight, scalable pub/sub system for real-time messaging, ideal for smaller-scale applications. This lesson covers setting up Redis Streams, publishing and consuming events, and testing for low-latency communication.",
        "examples": [
          "Publish: await redis.xadd('events', '*', 'data', 'Event 1');",
          "Consume: await redis.xreadgroup('GROUP', 'group', 'consumer', 'STREAMS', 'events', '>');"
        ],
        "realWorldApplication": "Redis Streams are used in real-time dashboards or IoT event processing.",
        "expertInsights": "Use consumer groups for parallel processing. Set stream retention for memory efficiency.",
        "commonMistakes": [
          "Not using consumer groups, limiting scalability.",
          "Ignoring stream cleanup, causing memory bloat."
        ],
        "exercises": [
          {
            "title": "Set Up Redis Streams",
            "prompt": "Create a Redis Streams producer and consumer for events.",
            "difficulty": "medium",
            "hints": [
              "Use redis.xadd/xread",
              "Define a stream"
            ],
            "solution": "stream.ts: const redis = require('redis'); const client = redis.createClient(); async function publish() { await client.xadd('events', '*', 'data', 'Event 1'); } async function consume() { await client.xgroup('CREATE', 'events', 'group', '$', 'MKSTREAM'); while (true) { const [stream] = await client.xreadgroup('GROUP', 'group', 'consumer', 'STREAMS', 'events', '>'); console.log(stream); } } publish(); consume();"
          }
        ],
        "quiz": [
          {
            "question": "What does Redis Streams enable?",
            "options": [
              "Static sites",
              "Event streaming",
              "Database queries",
              "UI rendering"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What improves Redis Streams scalability?",
            "options": [
              "Single stream",
              "Consumer groups",
              "Static data",
              "Inline scripts"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Redis Streams Documentation",
            "url": "https://redis.io/docs/data-types/streams/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f88",
        "lessonId": "68cf5c5036b0c3df3e9f9f82"
      },
      {
        "level": "Intermediate",
        "explanation": "Idempotency ensures operations can be repeated without unintended effects, while delivery guarantees (at-least-once, exactly-once) ensure reliability in event-driven systems. This lesson covers implementing idempotent operations and configuring delivery guarantees for Kafka or Redis Streams.",
        "examples": [
          "Idempotency: Check if event_id exists before processing.",
          "Exactly-once: Use Kafka transaction: producer.beginTransaction();"
        ],
        "realWorldApplication": "Idempotency and delivery guarantees are critical in payment systems or order processing apps.",
        "expertInsights": "Use unique event IDs for idempotency. Prefer exactly-once delivery for critical systems.",
        "commonMistakes": [
          "Not tracking event IDs, causing duplicates.",
          "Using at-most-once delivery for critical events."
        ],
        "exercises": [
          {
            "title": "Implement Idempotent Event Processing",
            "prompt": "Create an idempotent event consumer with Redis for deduplication.",
            "difficulty": "medium",
            "hints": [
              "Store event IDs",
              "Check before processing"
            ],
            "solution": "consumer.ts: const redis = require('redis'); const client = redis.createClient(); async function processEvent(event) { const exists = await client.get(`event:${event.id}`); if (exists) return; await client.set(`event:${event.id}`, 'processed'); console.log('Processed:', event.data); } processEvent({ id: '1', data: 'Event 1' });"
          }
        ],
        "quiz": [
          {
            "question": "What does idempotency prevent?",
            "options": [
              "Network latency",
              "Duplicate effects",
              "UI errors",
              "Database queries"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What ensures reliable delivery?",
            "options": [
              "CSS",
              "Exactly-once",
              "Static files",
              "GraphQL"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Idempotency in Event-Driven Systems",
            "url": "https://aws.amazon.com/blogs/architecture/achieving-exactly-once-processing-with-kafka/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f89",
        "lessonId": "68cf5c5036b0c3df3e9f9f83"
      },
      {
        "level": "Intermediate",
        "explanation": "Conflict-free Replicated Data Types (CRDTs) enable real-time collaborative editing by resolving conflicts without coordination. This lesson guides you through building a collaborative document editor using CRDTs, integrating with WebRTC for real-time updates, and testing for consistency across clients.",
        "examples": [
          "CRDT: Add-only set: { elements: ['a', 'b'], tombstone: [] }",
          "WebRTC: Send CRDT operations via data channel."
        ],
        "realWorldApplication": "CRDTs power collaborative tools like Google Docs or Notion.",
        "expertInsights": "Use operation-based CRDTs for simplicity. Optimize WebRTC channels for low latency.",
        "commonMistakes": [
          "Not merging CRDT states correctly, causing data loss.",
          "Ignoring network delays, breaking real-time updates."
        ],
        "exercises": [
          {
            "title": "Build a Collaborative Doc Editor with CRDTs",
            "prompt": "Create a real-time document editor using CRDTs and WebRTC.",
            "difficulty": "hard",
            "hints": [
              "Use a simple CRDT library",
              "Send operations via WebRTC"
            ],
            "solution": "editor.js: const crdt = { text: '', ops: [] }; const pc = new RTCPeerConnection(); const channel = pc.createDataChannel('editor'); channel.onmessage = ({ data }) => { const op = JSON.parse(data); crdt.ops.push(op); crdt.text += op.char; console.log('Updated:', crdt.text); }; async function addChar(char) { const op = { char, id: Date.now() }; crdt.ops.push(op); crdt.text += char; channel.send(JSON.stringify(op)); } addChar('a');"
          }
        ],
        "quiz": [
          {
            "question": "What do CRDTs enable?",
            "options": [
              "Static sites",
              "Collaborative editing",
              "Database queries",
              "UI rendering"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What sends CRDT operations?",
            "options": [
              "SQL",
              "WebRTC",
              "Redis",
              "GraphQL"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 60,
        "resources": [
          {
            "title": "CRDTs Explained",
            "url": "https://crdt.tech/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f8a",
        "lessonId": "68cf5c5036b0c3df3e9f9f84"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Intermediate",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master advanced security practices, including threat modeling, secrets management with Vault/KMS, and secure coding with SAST/DAST pipelines for scalable applications.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f8b"
      }
    ],
    "courses": [
      {
        "title": "Advanced Security",
        "slug": "advanced-security",
        "shortDescription": "An intermediate course on advanced security practices, covering threat modeling, secrets rotation with Vault/KMS, and secure coding with SAST/DAST pipelines.",
        "longDescription": "This course explores advanced security techniques for building secure, scalable applications, focusing on threat modeling to identify risks, secrets management using Vault and KMS, and secure coding practices with Static Application Security Testing (SAST) and Dynamic Application Security Testing (DAST) pipelines. Through hands-on exercises, real-world examples, and quizzes, you’ll implement secure coding fixes based on SAST findings. The course prepares you to design and maintain secure systems in enterprise environments, emphasizing proactive security measures.",
        "tags": [
          "security",
          "threat-modeling",
          "secrets-management",
          "vault",
          "kms",
          "sast",
          "dast",
          "secure-coding"
        ],
        "thumbnail": "https://example.com/thumbnails/advanced-security.jpg",
        "levelSummary": [
          {
            "level": "Intermediate",
            "overview": "Master advanced security with threat modeling, secrets management, and secure coding practices for scalable, secure applications.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f8c",
        "domainId": "68cf5c5036b0c3df3e9f9f8b"
      }
    ],
    "modules": [
      {
        "level": "Intermediate",
        "title": "Module 1 — Advanced Security",
        "slug": "advanced-security",
        "description": "Learn threat modeling, secrets management with Vault/KMS, and secure coding with SAST/DAST pipelines for secure systems.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f8d",
        "courseId": "68cf5c5036b0c3df3e9f9f8c",
        "lessonIds": [
          "68cf5c5036b0c3df3e9f9f8e",
          "68cf5c5036b0c3df3e9f9f8f",
          "68cf5c5036b0c3df3e9f9f90",
          "68cf5c5036b0c3df3e9f9f91",
          "68cf5c5036b0c3df3e9f9f92",
          "68cf5c5036b0c3df3e9f9f93"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Intermediate",
        "title": "Introduction to Advanced Security",
        "slug": "intro-advanced-security",
        "description": "Understand the principles of advanced security for scalable applications.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f8e",
        "moduleId": "68cf5c5036b0c3df3e9f9f8d",
        "contentId": "68cf5c5036b0c3df3e9f9f94"
      },
      {
        "level": "Intermediate",
        "title": "Threat Modeling for Risk Identification",
        "slug": "threat-modeling",
        "description": "Learn threat modeling to identify and mitigate risks in application design.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f8f",
        "moduleId": "68cf5c5036b0c3df3e9f9f8d",
        "contentId": "68cf5c5036b0c3df3e9f9f95"
      },
      {
        "level": "Intermediate",
        "title": "Secrets Rotation with Vault and KMS",
        "slug": "secrets-rotation",
        "description": "Implement secrets rotation using HashiCorp Vault and AWS KMS for secure key management.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f90",
        "moduleId": "68cf5c5036b0c3df3e9f9f8d",
        "contentId": "68cf5c5036b0c3df3e9f9f96"
      },
      {
        "level": "Intermediate",
        "title": "Secure Coding Practices with SAST",
        "slug": "secure-coding-sast",
        "description": "Apply secure coding practices using Static Application Security Testing (SAST) tools.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f91",
        "moduleId": "68cf5c5036b0c3df3e9f9f8d",
        "contentId": "68cf5c5036b0c3df3e9f9f97"
      },
      {
        "level": "Intermediate",
        "title": "Dynamic Application Security Testing (DAST) Pipelines",
        "slug": "dast-pipelines",
        "description": "Integrate DAST pipelines for runtime security testing in CI/CD workflows.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f92",
        "moduleId": "68cf5c5036b0c3df3e9f9f8d",
        "contentId": "68cf5c5036b0c3df3e9f9f98"
      },
      {
        "level": "Intermediate",
        "title": "Fixing Vulnerabilities from SAST Findings",
        "slug": "fix-sast-vulnerabilities",
        "description": "Analyze and fix vulnerabilities identified by SAST tools in a sample project.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f93",
        "moduleId": "68cf5c5036b0c3df3e9f9f8d",
        "contentId": "68cf5c5036b0c3df3e9f9f99"
      }
    ],
    "learningContents": [
      {
        "level": "Intermediate",
        "explanation": "Advanced security practices ensure applications are resilient against threats through proactive measures like threat modeling, secrets management, and secure coding. This lesson introduces these concepts, their importance in scalable systems, and how to set up a secure development environment, emphasizing risk mitigation and compliance.",
        "examples": [
          "Threat model: Identify data flows and entry points using STRIDE.",
          "Run: npm install eslint-security // Initialize secure coding setup"
        ],
        "realWorldApplication": "These practices are used in banking apps, cloud platforms like AWS, or SaaS products for robust security.",
        "expertInsights": "Start with threat modeling early in design. Automate secrets rotation to reduce exposure.",
        "commonMistakes": [
          "Skipping threat modeling, missing critical risks.",
          "Hardcoding secrets, exposing sensitive data."
        ],
        "exercises": [
          {
            "title": "Plan a Secure System",
            "prompt": "Outline a secure application with threat modeling and secrets management.",
            "difficulty": "easy",
            "hints": [
              "Use STRIDE for threats",
              "Define secrets storage"
            ],
            "solution": "security.ts: // Threat model: { assets: ['user_data'], threats: ['spoofing'], mitigation: ['auth'] }\n// Secrets: Use Vault for API keys"
          }
        ],
        "quiz": [
          {
            "question": "What improves application security?",
            "options": [
              "Inline scripts",
              "Threat modeling",
              "Global state",
              "Static files"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why automate secrets rotation?",
            "options": [
              "Faster builds",
              "Reduce exposure",
              "Better UI",
              "Smaller code"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 30,
        "resources": [
          {
            "title": "OWASP Secure Coding Practices",
            "url": "https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f94",
        "lessonId": "68cf5c5036b0c3df3e9f9f8e"
      },
      {
        "level": "Intermediate",
        "explanation": "Threat modeling identifies potential risks in application design using frameworks like STRIDE or DREAD. It prioritizes mitigation strategies to secure systems. This lesson covers creating a threat model, analyzing data flows, and documenting risks for a sample application.",
        "examples": [
          "STRIDE: Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, Elevation of Privilege.",
          "Data flow: User -> API -> Database"
        ],
        "realWorldApplication": "Threat modeling is used in fintech or healthcare apps to comply with regulations like GDPR.",
        "expertInsights": "Focus on high-risk entry points. Update threat models with system changes.",
        "commonMistakes": [
          "Overlooking external APIs, missing risks.",
          "Not prioritizing threats, delaying mitigation."
        ],
        "exercises": [
          {
            "title": "Create a Threat Model",
            "prompt": "Develop a STRIDE-based threat model for a user login system.",
            "difficulty": "medium",
            "hints": [
              "Identify assets and entry points",
              "List STRIDE threats"
            ],
            "solution": "threat-model.ts: const model = { assets: ['user_credentials'], entryPoints: ['login_api'], threats: [{ type: 'spoofing', mitigation: 'MFA' }, { type: 'tampering', mitigation: 'input_validation' }] }; console.log(model);"
          }
        ],
        "quiz": [
          {
            "question": "What does STRIDE identify?",
            "options": [
              "UI issues",
              "Security threats",
              "Database errors",
              "Performance"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What is a key step in threat modeling?",
            "options": [
              "Code bundling",
              "Data flow analysis",
              "UI design",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 45,
        "resources": [
          {
            "title": "STRIDE Threat Modeling",
            "url": "https://docs.microsoft.com/en-us/azure/security/develop/threat-modeling-tool-threats",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f95",
        "lessonId": "68cf5c5036b0c3df3e9f9f8f"
      },
      {
        "level": "Intermediate",
        "explanation": "Secrets rotation with tools like HashiCorp Vault or AWS Key Management Service (KMS) minimizes exposure of sensitive data like API keys or credentials. This lesson covers setting up Vault/KMS, automating rotation, and integrating with applications for secure key management.",
        "examples": [
          "Vault: vault kv put secret/my-key value=123",
          "KMS: aws kms generate-data-key --key-id alias/my-key"
        ],
        "realWorldApplication": "Vault and KMS are used in cloud apps like AWS-based services or enterprise SaaS for secure secrets management.",
        "expertInsights": "Rotate keys frequently. Use Vault’s dynamic secrets for temporary credentials.",
        "commonMistakes": [
          "Not automating rotation, risking exposure.",
          "Storing secrets in code, enabling leaks."
        ],
        "exercises": [
          {
            "title": "Set Up Secrets Rotation with Vault",
            "prompt": "Configure Vault to store and rotate an API key.",
            "difficulty": "medium",
            "hints": [
              "Use Vault’s KV engine",
              "Enable periodic rotation"
            ],
            "solution": "vault-config.sh: vault kv put secret/api-key value=123 ttl=24h\nvault-policy.hcl: path \"secret/data/api-key\" { capabilities = [\"read\", \"update\"] }\nnode.ts: const vault = require('node-vault')(); async function getKey() { const { data } = await vault.read('secret/data/api-key'); return data.value; } getKey();"
          }
        ],
        "quiz": [
          {
            "question": "What does secrets rotation minimize?",
            "options": [
              "Code size",
              "Exposure",
              "UI latency",
              "Database queries"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What tool manages secrets?",
            "options": [
              "Redis",
              "Vault",
              "MongoDB",
              "Vite"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "HashiCorp Vault Documentation",
            "url": "https://www.vaultproject.io/docs",
            "type": "doc"
          },
          {
            "title": "AWS KMS Documentation",
            "url": "https://docs.aws.amazon.com/kms/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f96",
        "lessonId": "68cf5c5036b0c3df3e9f9f90"
      },
      {
        "level": "Intermediate",
        "explanation": "Secure coding practices with Static Application Security Testing (SAST) tools analyze code for vulnerabilities during development. This lesson covers integrating SAST tools like ESLint or SonarQube into CI/CD pipelines, identifying common issues, and applying fixes for secure code.",
        "examples": [
          "SAST rule: Disallow eval(): no-eval in ESLint.",
          "Fix: Replace eval(code) with JSON.parse(code)."
        ],
        "realWorldApplication": "SAST is used in CI/CD pipelines for apps like GitHub or banking systems to ensure secure code.",
        "expertInsights": "Run SAST early in development. Prioritize high-severity findings.",
        "commonMistakes": [
          "Ignoring SAST warnings, leaving vulnerabilities.",
          "Not updating rules, missing new threats."
        ],
        "exercises": [
          {
            "title": "Integrate SAST with ESLint",
            "prompt": "Set up ESLint with security rules to detect vulnerabilities.",
            "difficulty": "medium",
            "hints": [
              "Use eslint-plugin-security",
              "Add no-eval rule"
            ],
            "solution": "eslintrc.json: { \"plugins\": [\"security\"], \"rules\": { \"security/detect-eval-with-expression\": \"error\" } }\ncode.js: // Bad: eval(userInput);\n// Fixed: JSON.parse(userInput);"
          }
        ],
        "quiz": [
          {
            "question": "What does SAST analyze?",
            "options": [
              "UI components",
              "Source code",
              "Runtime",
              "Network traffic"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why use SAST in CI/CD?",
            "options": [
              "Faster builds",
              "Early vulnerability detection",
              "Better UX",
              "Smaller code"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "ESLint Security Plugin",
            "url": "https://github.com/eslint-community/eslint-plugin-security",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f97",
        "lessonId": "68cf5c5036b0c3df3e9f9f91"
      },
      {
        "level": "Intermediate",
        "explanation": "Dynamic Application Security Testing (DAST) pipelines test applications at runtime to identify vulnerabilities like XSS or SQL injection. This lesson covers integrating DAST tools into CI/CD workflows, analyzing findings, and ensuring secure deployments.",
        "examples": [
          "DAST: Scan /login endpoint for XSS vulnerabilities.",
          "Pipeline: Add DAST step in GitHub Actions."
        ],
        "realWorldApplication": "DAST is used in web apps like e-commerce platforms or APIs to detect runtime issues.",
        "expertInsights": "Run DAST in staging environments. Combine with SAST for comprehensive coverage.",
        "commonMistakes": [
          "Skipping DAST in CI/CD, missing runtime issues.",
          "Not fixing high-severity findings, risking attacks."
        ],
        "exercises": [
          {
            "title": "Set Up DAST in CI/CD",
            "prompt": "Add a DAST scan to a GitHub Actions workflow.",
            "difficulty": "medium",
            "hints": [
              "Use a DAST tool like OWASP Dependency-Check",
              "Add to .github/workflows"
            ],
            "solution": "dast.yml: name: DAST Scan\non: [push]\njobs:\n  scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Run DAST\n        run: docker run -v $(pwd):/src owasp/dependency-check --scan /src"
          }
        ],
        "quiz": [
          {
            "question": "What does DAST test?",
            "options": [
              "Source code",
              "Runtime behavior",
              "UI design",
              "Database"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Where should DAST run?",
            "options": [
              "Production",
              "Staging",
              "Local",
              "UI layer"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "DAST Overview",
            "url": "https://owasp.org/www-community/Application_Security_Testing",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f98",
        "lessonId": "68cf5c5036b0c3df3e9f9f92"
      },
      {
        "level": "Intermediate",
        "explanation": "Fixing vulnerabilities identified by SAST tools ensures secure code in production. This lesson guides you through analyzing SAST findings in a sample project, prioritizing vulnerabilities, and applying fixes like input validation or secure configuration to mitigate risks.",
        "examples": [
          "Vulnerability: SQL injection in query: SELECT * FROM users WHERE name = '${input}'",
          "Fix: Use parameterized query: SELECT * FROM users WHERE name = ?"
        ],
        "realWorldApplication": "Fixing SAST findings is critical in regulated industries like finance or healthcare for compliance.",
        "expertInsights": "Prioritize critical vulnerabilities like injection flaws. Retest after fixes.",
        "commonMistakes": [
          "Ignoring low-severity findings, accumulating risks.",
          "Applying incomplete fixes, leaving vulnerabilities."
        ],
        "exercises": [
          {
            "title": "Fix SAST-Detected Vulnerability",
            "prompt": "Fix a SQL injection vulnerability identified by SAST in a Node.js project.",
            "difficulty": "hard",
            "hints": [
              "Use parameterized queries",
              "Validate input"
            ],
            "solution": "app.ts: const express = require('express'); const { Pool } = require('pg'); const app = express(); const pool = new Pool(); app.get('/users', async (req, res) => { const name = req.query.name; // Bad: const result = await pool.query(`SELECT * FROM users WHERE name = '${name}'`);\n// Fixed: const result = await pool.query('SELECT * FROM users WHERE name = $1', [name]); res.json(result.rows); }); app.listen(3000);"
          }
        ],
        "quiz": [
          {
            "question": "What fixes SQL injection?",
            "options": [
              "Inline queries",
              "Parameterized queries",
              "UI validation",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why prioritize SAST findings?",
            "options": [
              "Faster builds",
              "Reduce risks",
              "Better UX",
              "Smaller code"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 60,
        "resources": [
          {
            "title": "OWASP Top Ten",
            "url": "https://owasp.org/www-project-top-ten/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f99",
        "lessonId": "68cf5c5036b0c3df3e9f9f93"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Intermediate",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master cloud-native development and scaling with Kubernetes operators, service meshes, autoscaling strategies, and observability for distributed systems.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f9a"
      }
    ],
    "courses": [
      {
        "title": "Cloud-Native & Scaling",
        "slug": "cloud-native-scaling",
        "shortDescription": "An intermediate course on cloud-native development with Kubernetes operators, service meshes (Istio/Linkerd), autoscaling, and observability for scalable microservices.",
        "longDescription": "This course dives into cloud-native architectures and scaling strategies, covering advanced Kubernetes topics like operators and service meshes (Istio/Linkerd), autoscaling with Horizontal Pod Autoscaler (HPA) and Vertical Pod Autoscaler (VPA), and observability with distributed tracing. Through hands-on exercises, real-world examples, and quizzes, you’ll deploy a multi-service application to Kubernetes with monitoring and scaling rules. The course focuses on building resilient, scalable systems for enterprise-grade microservices.",
        "tags": [
          "cloud-native",
          "kubernetes",
          "service-mesh",
          "istio",
          "linkerd",
          "autoscaling",
          "hpa",
          "vpa",
          "observability"
        ],
        "thumbnail": "https://example.com/thumbnails/cloud-native-scaling.jpg",
        "levelSummary": [
          {
            "level": "Intermediate",
            "overview": "Master cloud-native development with Kubernetes operators, service meshes, autoscaling, and observability for scalable microservices.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f9b",
        "domainId": "68cf5c5036b0c3df3e9f9f9a"
      }
    ],
    "modules": [
      {
        "level": "Intermediate",
        "title": "Module 1 — Cloud-Native & Scaling",
        "slug": "cloud-native-scaling",
        "description": "Learn Kubernetes operators, service meshes, autoscaling with HPA/VPA, and observability with tracing for scalable cloud-native systems.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f9c",
        "courseId": "68cf5c5036b0c3df3e9f9f9b",
        "lessonIds": [
          "68cf5c5036b0c3df3e9f9f9d",
          "68cf5c5036b0c3df3e9f9f9e",
          "68cf5c5036b0c3df3e9f9f9f",
          "68cf5c5036b0c3df3e9f9fa0",
          "68cf5c5036b0c3df3e9f9fa1",
          "68cf5c5036b0c3df3e9f9fa2"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Intermediate",
        "title": "Introduction to Cloud-Native & Scaling",
        "slug": "intro-cloud-native-scaling",
        "description": "Understand the principles of cloud-native development and scaling for microservices.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f9d",
        "moduleId": "68cf5c5036b0c3df3e9f9f9c",
        "contentId": "68cf5c5036b0c3df3e9f9fa3"
      },
      {
        "level": "Intermediate",
        "title": "Kubernetes Operators",
        "slug": "kubernetes-operators",
        "description": "Explore Kubernetes operators for automating complex application management.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f9e",
        "moduleId": "68cf5c5036b0c3df3e9f9f9c",
        "contentId": "68cf5c5036b0c3df3e9f9fa4"
      },
      {
        "level": "Intermediate",
        "title": "Service Meshes with Istio and Linkerd",
        "slug": "service-meshes",
        "description": "Implement service meshes using Istio and Linkerd for microservice communication.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9f9f",
        "moduleId": "68cf5c5036b0c3df3e9f9f9c",
        "contentId": "68cf5c5036b0c3df3e9f9fa5"
      },
      {
        "level": "Intermediate",
        "title": "Autoscaling Strategies: HPA and VPA",
        "slug": "autoscaling-hpa-vpa",
        "description": "Learn Horizontal Pod Autoscaler (HPA) and Vertical Pod Autoscaler (VPA) for dynamic scaling.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fa0",
        "moduleId": "68cf5c5036b0c3df3e9f9f9c",
        "contentId": "68cf5c5036b0c3df3e9f9fa6"
      },
      {
        "level": "Intermediate",
        "title": "Observability at Scale: Distributed Tracing",
        "slug": "observability-tracing",
        "description": "Implement observability with distributed tracing for monitoring microservices.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fa1",
        "moduleId": "68cf5c5036b0c3df3e9f9f9c",
        "contentId": "68cf5c5036b0c3df3e9f9fa7"
      },
      {
        "level": "Intermediate",
        "title": "Deploying a Multi-Service App with Monitoring",
        "slug": "multi-service-k8s-deployment",
        "description": "Deploy a multi-service app to Kubernetes with monitoring and scaling rules.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fa2",
        "moduleId": "68cf5c5036b0c3df3e9f9f9c",
        "contentId": "68cf5c5036b0c3df3e9f9fa8"
      }
    ],
    "learningContents": [
      {
        "level": "Intermediate",
        "explanation": "Cloud-native development enables scalable, resilient applications using containers and orchestration. This lesson introduces Kubernetes operators, service meshes, autoscaling, and observability, covering their roles in microservices. You’ll learn to set up a cloud-native project and understand trade-offs for scalability and reliability.",
        "examples": [
          "Kubernetes: kubectl apply -f deployment.yaml",
          "Run: docker build -t my-app . // Build container image"
        ],
        "realWorldApplication": "Cloud-native systems power apps like Netflix, Spotify, or Google Cloud services.",
        "expertInsights": "Use operators for automation, meshes for observability. Monitor scaling metrics closely.",
        "commonMistakes": [
          "Overcomplicating Kubernetes configs, reducing clarity.",
          "Ignoring observability, missing performance issues."
        ],
        "exercises": [
          {
            "title": "Plan a Cloud-Native System",
            "prompt": "Outline a microservices app with Kubernetes and monitoring.",
            "difficulty": "easy",
            "hints": [
              "Define services and deployments",
              "Include monitoring tools"
            ],
            "solution": "plan.yaml: apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: app\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: my-app\n  template:\n    metadata:\n      labels:\n        app: my-app\n    spec:\n      containers:\n      - name: app\n        image: my-app:latest\n// Monitoring: Use Prometheus"
          }
        ],
        "quiz": [
          {
            "question": "What enables cloud-native scalability?",
            "options": [
              "Monoliths",
              "Kubernetes",
              "Static files",
              "Inline scripts"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why use service meshes?",
            "options": [
              "UI rendering",
              "Microservice communication",
              "Database queries",
              "Code bundling"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 30,
        "resources": [
          {
            "title": "Cloud Native Computing Foundation",
            "url": "https://www.cncf.io/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fa3",
        "lessonId": "68cf5c5036b0c3df3e9f9f9d"
      },
      {
        "level": "Intermediate",
        "explanation": "Kubernetes operators automate complex application management by extending Kubernetes APIs with custom resources. This lesson covers creating an operator using tools like Operator SDK, defining custom resources, and deploying them to manage application lifecycles.",
        "examples": [
          "Operator: apiVersion: myapp.example.com/v1\nkind: MyApp\nspec:\n  replicas: 3",
          "Command: operator-sdk init --domain example.com"
        ],
        "realWorldApplication": "Operators are used in databases like PostgreSQL Operator or Redis Operator for automation.",
        "expertInsights": "Use operators for stateful apps. Test custom resources thoroughly.",
        "commonMistakes": [
          "Overcomplicating operator logic, causing errors.",
          "Not handling failures, breaking deployments."
        ],
        "exercises": [
          {
            "title": "Create a Kubernetes Operator",
            "prompt": "Define a simple operator for managing a custom app resource.",
            "difficulty": "medium",
            "hints": [
              "Use Operator SDK",
              "Define a CRD"
            ],
            "solution": "crd.yaml: apiVersion: apiextensions.k8s.io/v1\nkind: CustomResourceDefinition\nmetadata:\n  name: myapps.example.com\nspec:\n  group: example.com\n  names:\n    kind: MyApp\n    plural: myapps\n  scope: Namespaced\n  versions:\n  - name: v1\n    served: true\n    storage: true\n    schema:\n      openAPIV3Schema:\n        type: object\n        properties:\n          spec:\n            type: object\n            properties:\n              replicas:\n                type: integer\ncontroller.go: package main\n// Simplified operator logic to reconcile MyApp CR"
          }
        ],
        "quiz": [
          {
            "question": "What do Kubernetes operators automate?",
            "options": [
              "UI rendering",
              "Application management",
              "Database queries",
              "Static sites"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What defines custom resources?",
            "options": [
              "CRD",
              "HPA",
              "VPA",
              "CSS"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 45,
        "resources": [
          {
            "title": "Operator SDK Documentation",
            "url": "https://sdk.operatorframework.io/docs/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fa4",
        "lessonId": "68cf5c5036b0c3df3e9f9f9e"
      },
      {
        "level": "Intermediate",
        "explanation": "Service meshes like Istio and Linkerd manage microservice communication, providing observability, security, and traffic control. This lesson covers setting up a service mesh, configuring traffic policies, and monitoring service interactions for reliability.",
        "examples": [
          "Istio: kubectl apply -f istio-virtual-service.yaml",
          "Linkerd: linkerd inject deployment.yaml | kubectl apply -f -"
        ],
        "realWorldApplication": "Service meshes are used in cloud platforms like AWS App Mesh or Kubernetes clusters.",
        "expertInsights": "Use Istio for advanced routing, Linkerd for simplicity. Monitor mesh performance.",
        "commonMistakes": [
          "Overcomplicating mesh configs, slowing services.",
          "Ignoring observability, missing failures."
        ],
        "exercises": [
          {
            "title": "Set Up Istio Service Mesh",
            "prompt": "Configure Istio for a microservice with traffic routing.",
            "difficulty": "medium",
            "hints": [
              "Define VirtualService",
              "Apply to Kubernetes"
            ],
            "solution": "virtual-service.yaml: apiVersion: networking.istio.io/v1alpha3\nkind: VirtualService\nmetadata:\n  name: my-app\nspec:\n  hosts:\n  - my-app\n  http:\n  - route:\n    - destination:\n        host: my-app-service\n        subset: v1\n      weight: 100"
          }
        ],
        "quiz": [
          {
            "question": "What does a service mesh manage?",
            "options": [
              "UI components",
              "Microservice communication",
              "Database queries",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What provides observability in meshes?",
            "options": [
              "SQL",
              "Tracing",
              "Redis",
              "GraphQL"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Istio Documentation",
            "url": "https://istio.io/latest/docs/",
            "type": "doc"
          },
          {
            "title": "Linkerd Documentation",
            "url": "https://linkerd.io/2.10/overview/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fa5",
        "lessonId": "68cf5c5036b0c3df3e9f9f9f"
      },
      {
        "level": "Intermediate",
        "explanation": "Autoscaling with Horizontal Pod Autoscaler (HPA) and Vertical Pod Autoscaler (VPA) adjusts resources dynamically based on demand. HPA scales pod replicas, while VPA adjusts resource limits. This lesson covers configuring HPA and VPA, testing scaling behavior, and optimizing resource usage.",
        "examples": [
          "HPA: kubectl autoscale deployment my-app --cpu-percent=80 --min=1 --max=10",
          "VPA: apiVersion: autoscaling.k8s.io/v1\nkind: VerticalPodAutoscaler"
        ],
        "realWorldApplication": "Autoscaling is used in cloud apps like e-commerce or streaming platforms for cost efficiency.",
        "expertInsights": "Tune HPA metrics for responsiveness. Use VPA for resource optimization.",
        "commonMistakes": [
          "Setting tight HPA thresholds, causing flapping.",
          "Ignoring VPA recommendations, wasting resources."
        ],
        "exercises": [
          {
            "title": "Configure HPA for a Deployment",
            "prompt": "Set up HPA for a microservice based on CPU usage.",
            "difficulty": "medium",
            "hints": [
              "Use kubectl autoscale",
              "Define CPU threshold"
            ],
            "solution": "hpa.yaml: apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: my-app-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: my-app\n  minReplicas: 1\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 80"
          }
        ],
        "quiz": [
          {
            "question": "What does HPA scale?",
            "options": [
              "Pod resources",
              "Pod replicas",
              "UI components",
              "Databases"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What does VPA adjust?",
            "options": [
              "Replicas",
              "Resource limits",
              "Network traffic",
              "UI"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Kubernetes Autoscaling",
            "url": "https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fa6",
        "lessonId": "68cf5c5036b0c3df3e9f9fa0"
      },
      {
        "level": "Intermediate",
        "explanation": "Observability at scale uses distributed tracing to monitor microservices, tracking requests across services. Tools like Jaeger or Zipkin provide insights into performance and failures. This lesson covers setting up tracing, integrating with Kubernetes, and analyzing traces for debugging.",
        "examples": [
          "Tracing: Jaeger client: tracer.initSpan('my-service');",
          "Config: kubectl apply -f jaeger-deployment.yaml"
        ],
        "realWorldApplication": "Tracing is used in microservices for apps like Uber or AWS X-Ray for debugging.",
        "expertInsights": "Instrument critical paths first. Sample traces to reduce overhead.",
        "commonMistakes": [
          "Not instrumenting services, missing insights.",
          "Over-tracing, slowing performance."
        ],
        "exercises": [
          {
            "title": "Set Up Distributed Tracing",
            "prompt": "Configure Jaeger for tracing a microservice in Kubernetes.",
            "difficulty": "medium",
            "hints": [
              "Deploy Jaeger",
              "Instrument service"
            ],
            "solution": "jaeger.yaml: apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: jaeger\nspec:\n  selector:\n    matchLabels:\n      app: jaeger\n  template:\n    metadata:\n      labels:\n        app: jaeger\n    spec:\n      containers:\n      - name: jaeger\n        image: jaegertracing/all-in-one:latest\napp.ts: const { initTracer } = require('jaeger-client'); const tracer = initTracer({ serviceName: 'my-service' }); const span = tracer.startSpan('operation'); span.finish();"
          }
        ],
        "quiz": [
          {
            "question": "What does distributed tracing monitor?",
            "options": [
              "UI events",
              "Service requests",
              "Database queries",
              "Static files"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What tool provides tracing?",
            "options": [
              "Redis",
              "Jaeger",
              "MongoDB",
              "Vite"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Jaeger Documentation",
            "url": "https://www.jaegertracing.io/docs/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fa7",
        "lessonId": "68cf5c5036b0c3df3e9f9fa1"
      },
      {
        "level": "Intermediate",
        "explanation": "Deploying a multi-service app to Kubernetes with monitoring and scaling rules ensures scalability and observability. This lesson guides you through deploying services, setting up Prometheus for monitoring, configuring HPA for scaling, and testing the system for reliability.",
        "examples": [
          "Deployment: kubectl apply -f service.yaml",
          "HPA: Scale based on CPU usage."
        ],
        "realWorldApplication": "Multi-service apps are used in e-commerce, gaming, or SaaS platforms for scalability.",
        "expertInsights": "Use Prometheus for metrics, Jaeger for tracing. Test scaling under load.",
        "commonMistakes": [
          "Not configuring monitoring, missing issues.",
          "Over-scaling, wasting resources."
        ],
        "exercises": [
          {
            "title": "Deploy Multi-Service App with Monitoring",
            "prompt": "Deploy a two-service app to Kubernetes with Prometheus and HPA.",
            "difficulty": "hard",
            "hints": [
              "Define deployments",
              "Set up Prometheus and HPA"
            ],
            "solution": "service.yaml: apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-service\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: my-service\n  template:\n    metadata:\n      labels:\n        app: my-service\n    spec:\n      containers:\n      - name: my-service\n        image: my-service:latest\nhpa.yaml: apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: my-service-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: my-service\n  minReplicas: 2\n  maxReplicas: 10\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 80\nprometheus.yaml: apiVersion: monitoring.coreos.com/v1\nkind: Prometheus\nmetadata:\n  name: prometheus\nspec:\n  serviceMonitorSelector:\n    matchLabels:\n      app: my-service"
          }
        ],
        "quiz": [
          {
            "question": "What monitors Kubernetes apps?",
            "options": [
              "Prometheus",
              "Redis",
              "GraphQL",
              "CSS"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What does HPA use for scaling?",
            "options": [
              "UI events",
              "CPU metrics",
              "Static files",
              "Database queries"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 60,
        "resources": [
          {
            "title": "Kubernetes Documentation",
            "url": "https://kubernetes.io/docs/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fa8",
        "lessonId": "68cf5c5036b0c3df3e9f9fa2"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Intermediate",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master performance engineering and cost optimization with profiling tools, CDN strategies, and FinOps practices for efficient, scalable systems.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fa9"
      }
    ],
    "courses": [
      {
        "title": "Performance Engineering & Cost Optimization",
        "slug": "performance-engineering-cost-optimization",
        "shortDescription": "An intermediate course on optimizing performance with React Profiler, Lighthouse CI, pprof, and flamegraphs, plus CDN strategies and FinOps for cloud cost reduction.",
        "longDescription": "This course explores advanced performance engineering and cost optimization techniques, covering frontend profiling with React Profiler and Lighthouse CI, backend profiling with pprof and flamegraphs, CDN strategies like edge caching and stale-while-revalidate, and FinOps for cloud cost analysis. Through hands-on exercises, real-world examples, and quizzes, you’ll reduce infrastructure costs for a sample workload by 30% using caching and autoscaling. The course prepares you to build high-performance, cost-efficient applications in modern cloud environments.",
        "tags": [
          "performance",
          "cost-optimization",
          "react-profiler",
          "lighthouse",
          "pprof",
          "flamegraphs",
          "cdn",
          "finops",
          "caching",
          "autoscaling"
        ],
        "thumbnail": "https://example.com/thumbnails/performance-cost.jpg",
        "levelSummary": [
          {
            "level": "Intermediate",
            "overview": "Master performance engineering with profiling tools, CDN strategies, and FinOps for cost-efficient, scalable applications.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9faa",
        "domainId": "68cf5c5036b0c3df3e9f9fa9"
      }
    ],
    "modules": [
      {
        "level": "Intermediate",
        "title": "Module 1 — Performance Engineering & Cost Optimization",
        "slug": "performance-engineering-cost-optimization",
        "description": "Learn frontend and backend profiling, CDN strategies, and FinOps practices to optimize performance and reduce cloud costs.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fab",
        "courseId": "68cf5c5036b0c3df3e9f9faa",
        "lessonIds": [
          "68cf5c5036b0c3df3e9f9fac",
          "68cf5c5036b0c3df3e9f9fad",
          "68cf5c5036b0c3df3e9f9fae",
          "68cf5c5036b0c3df3e9f9faf",
          "68cf5c5036b0c3df3e9f9fb0",
          "68cf5c5036b0c3df3e9f9fb1"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Intermediate",
        "title": "Introduction to Performance Engineering & Cost Optimization",
        "slug": "intro-performance-cost",
        "description": "Understand the principles of performance engineering and cost optimization for scalable systems.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fac",
        "moduleId": "68cf5c5036b0c3df3e9f9fab",
        "contentId": "68cf5c5036b0c3df3e9f9fb2"
      },
      {
        "level": "Intermediate",
        "title": "Frontend Profiling with React Profiler and Lighthouse CI",
        "slug": "frontend-profiling",
        "description": "Profile frontend performance using React Profiler and Lighthouse CI for optimization.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fad",
        "moduleId": "68cf5c5036b0c3df3e9f9fab",
        "contentId": "68cf5c5036b0c3df3e9f9fb3"
      },
      {
        "level": "Intermediate",
        "title": "Backend Profiling with pprof and Flamegraphs",
        "slug": "backend-profiling",
        "description": "Use pprof and flamegraphs to profile and optimize backend application performance.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fae",
        "moduleId": "68cf5c5036b0c3df3e9f9fab",
        "contentId": "68cf5c5036b0c3df3e9f9fb4"
      },
      {
        "level": "Intermediate",
        "title": "CDN Strategies: Edge Caching and Stale-While-Revalidate",
        "slug": "cdn-strategies",
        "description": "Implement CDN strategies like edge caching and stale-while-revalidate for low-latency content delivery.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9faf",
        "moduleId": "68cf5c5036b0c3df3e9f9fab",
        "contentId": "68cf5c5036b0c3df3e9f9fb5"
      },
      {
        "level": "Intermediate",
        "title": "Cloud Cost Analysis & Optimization with FinOps",
        "slug": "finops-cost-optimization",
        "description": "Apply FinOps practices to analyze and optimize cloud infrastructure costs.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fb0",
        "moduleId": "68cf5c5036b0c3df3e9f9fab",
        "contentId": "68cf5c5036b0c3df3e9f9fb6"
      },
      {
        "level": "Intermediate",
        "title": "Reducing Infra Cost with Caching and Autoscaling",
        "slug": "cost-reduction-caching-autoscaling",
        "description": "Optimize infrastructure costs by implementing caching and autoscaling for a sample workload.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fb1",
        "moduleId": "68cf5c5036b0c3df3e9f9fab",
        "contentId": "68cf5c5036b0c3df3e9f9fb7"
      }
    ],
    "learningContents": [
      {
        "level": "Intermediate",
        "explanation": "Performance engineering and cost optimization ensure applications run efficiently while minimizing cloud expenses. This lesson introduces profiling tools, CDN strategies, and FinOps practices, explaining their roles in scalable systems. You’ll learn to set up a project for performance and cost optimization, balancing speed and budget.",
        "examples": [
          "Lighthouse: Run lighthouse ci https://example.com --report",
          "Run: npm install @lhci/cli // Initialize performance tools"
        ],
        "realWorldApplication": "These techniques are used in e-commerce platforms like Amazon or SaaS apps for performance and cost efficiency.",
        "expertInsights": "Profile regularly to catch regressions. Use FinOps for continuous cost monitoring.",
        "commonMistakes": [
          "Ignoring performance bottlenecks, slowing apps.",
          "Not tracking cloud costs, leading to overspending."
        ],
        "exercises": [
          {
            "title": "Plan a Performance-Optimized System",
            "prompt": "Outline an app with profiling and cost optimization strategies.",
            "difficulty": "easy",
            "hints": [
              "Include profiling tools",
              "Define cost monitoring"
            ],
            "solution": "plan.ts: // Profiling: Use React Profiler for frontend, pprof for backend\n// Cost: Monitor with AWS Cost Explorer"
          }
        ],
        "quiz": [
          {
            "question": "What improves application performance?",
            "options": [
              "Inline scripts",
              "Profiling",
              "Global state",
              "Static files"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why use FinOps?",
            "options": [
              "UI rendering",
              "Cost optimization",
              "Database queries",
              "Code bundling"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 30,
        "resources": [
          {
            "title": "FinOps Foundation",
            "url": "https://www.finops.org/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fb2",
        "lessonId": "68cf5c5036b0c3df3e9f9fac"
      },
      {
        "level": "Intermediate",
        "explanation": "Frontend profiling with React Profiler and Lighthouse CI identifies performance bottlenecks in web applications. React Profiler measures component render times, while Lighthouse CI automates performance audits. This lesson covers setting up these tools, analyzing results, and optimizing frontend performance.",
        "examples": [
          "React Profiler: <Profiler id=\"App\" onRender={callback}>",
          "Lighthouse CI: lhci autorun --collect.url=https://example.com"
        ],
        "realWorldApplication": "React Profiler and Lighthouse CI are used by Facebook and Shopify to optimize web apps.",
        "expertInsights": "Focus on reducing render times in React. Use Lighthouse for SEO and performance scores.",
        "commonMistakes": [
          "Ignoring re-renders, slowing UI.",
          "Not automating Lighthouse CI, missing regressions."
        ],
        "exercises": [
          {
            "title": "Profile a React App",
            "prompt": "Set up React Profiler and Lighthouse CI for a sample app.",
            "difficulty": "medium",
            "hints": [
              "Use Profiler component",
              "Run Lighthouse CI in CI/CD"
            ],
            "solution": "app.tsx: import { Profiler } from 'react'; function onRender(id, phase, duration) { console.log(`${id} took ${duration}ms`); } export default function App() { return <Profiler id=\"App\" onRender={onRender}><div>My App</div></Profiler>; }\nlighthouse.yml: name: Lighthouse CI\non: [push]\njobs:\n  lhci:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm install -g @lhci/cli\n      - run: lhci autorun --collect.url=http://localhost:3000"
          }
        ],
        "quiz": [
          {
            "question": "What does React Profiler measure?",
            "options": [
              "Database queries",
              "Render times",
              "Network latency",
              "CSS styles"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What automates performance audits?",
            "options": [
              "Vite",
              "Lighthouse CI",
              "Redis",
              "GraphQL"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 45,
        "resources": [
          {
            "title": "React Profiler Documentation",
            "url": "https://reactjs.org/docs/profiler.html",
            "type": "doc"
          },
          {
            "title": "Lighthouse CI Documentation",
            "url": "https://github.com/GoogleChrome/lighthouse-ci",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fb3",
        "lessonId": "68cf5c5036b0c3df3e9f9fad"
      },
      {
        "level": "Intermediate",
        "explanation": "Backend profiling with pprof and flamegraphs identifies performance issues in server-side applications. pprof collects profiling data, and flamegraphs visualize bottlenecks. This lesson covers setting up pprof in a Node.js or Go app, generating flamegraphs, and optimizing backend performance.",
        "examples": [
          "pprof: import pprof from 'pprof'; pprof.start();",
          "Flamegraph: Generate with go tool pprof -http=:8080 profile"
        ],
        "realWorldApplication": "pprof and flamegraphs are used by Uber and Netflix for backend optimization.",
        "expertInsights": "Profile under realistic loads. Focus on CPU and memory hotspots in flamegraphs.",
        "commonMistakes": [
          "Not profiling in production-like environments, missing real issues.",
          "Ignoring memory leaks, causing crashes."
        ],
        "exercises": [
          {
            "title": "Profile a Node.js Backend",
            "prompt": "Set up pprof to profile a Node.js app and generate a flamegraph.",
            "difficulty": "medium",
            "hints": [
              "Use node-pprof",
              "Export profile data"
            ],
            "solution": "server.ts: const express = require('express'); const pprof = require('pprof'); pprof.start(); const app = express(); app.get('/data', (req, res) => { for (let i = 0; i < 1000000; i++) {} res.send('Done'); }); app.listen(3000); // Run: node --prof server.ts && pprof --http=localhost:8080 profile"
          }
        ],
        "quiz": [
          {
            "question": "What does pprof collect?",
            "options": [
              "UI events",
              "Profiling data",
              "Database queries",
              "CSS styles"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What visualizes bottlenecks?",
            "options": [
              "Flamegraphs",
              "Redis",
              "GraphQL",
              "Vite"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "pprof Documentation",
            "url": "https://github.com/google/pprof",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fb4",
        "lessonId": "68cf5c5036b0c3df3e9f9fae"
      },
      {
        "level": "Intermediate",
        "explanation": "CDN strategies like edge caching and stale-while-revalidate reduce latency by serving content closer to users. Edge caching stores static assets, while stale-while-revalidate serves cached content during updates. This lesson covers configuring a CDN with Cloudflare or AWS CloudFront and optimizing cache policies.",
        "examples": [
          "Edge cache: Cache-Control: max-age=3600",
          "Stale-while-revalidate: Cache-Control: stale-while-revalidate=86400"
        ],
        "realWorldApplication": "CDNs are used by YouTube, Netflix, or e-commerce sites for fast content delivery.",
        "expertInsights": "Use short TTLs for dynamic content. Test stale-while-revalidate for reliability.",
        "commonMistakes": [
          "Caching dynamic data, causing stale responses.",
          "Not invalidating caches, serving outdated content."
        ],
        "exercises": [
          {
            "title": "Configure CDN Caching",
            "prompt": "Set up edge caching with stale-while-revalidate for a web app.",
            "difficulty": "medium",
            "hints": [
              "Use Cache-Control headers",
              "Configure in Cloudflare"
            ],
            "solution": "server.ts: const express = require('express'); const app = express(); app.get('/static', (req, res) => { res.set('Cache-Control', 'public, max-age=3600, stale-while-revalidate=86400'); res.send('Static content'); }); app.listen(3000);\ncloudflare-config: Page Rule: *example.com/static* -> Cache Level: Cache Everything, Edge Cache TTL: 1 hour"
          }
        ],
        "quiz": [
          {
            "question": "What reduces latency in CDNs?",
            "options": [
              "Database queries",
              "Edge caching",
              "UI rendering",
              "Static files"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What does stale-while-revalidate do?",
            "options": [
              "Blocks updates",
              "Serves cached content",
              "Increases latency",
              "Bundles code"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Cloudflare Caching",
            "url": "https://developers.cloudflare.com/cache/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fb5",
        "lessonId": "68cf5c5036b0c3df3e9f9faf"
      },
      {
        "level": "Intermediate",
        "explanation": "FinOps practices analyze and optimize cloud costs by monitoring usage, forecasting budgets, and identifying savings. Tools like AWS Cost Explorer or Google Cloud Billing help track expenses. This lesson covers setting up cost monitoring, analyzing usage, and applying optimization strategies.",
        "examples": [
          "Cost Explorer: Filter by service to identify high-cost resources.",
          "Optimization: Use reserved instances for predictable workloads."
        ],
        "realWorldApplication": "FinOps is used by enterprises like Airbnb or Lyft to manage cloud spending.",
        "expertInsights": "Tag resources for granular cost tracking. Review costs weekly to catch spikes.",
        "commonMistakes": [
          "Not tagging resources, losing cost visibility.",
          "Ignoring idle resources, wasting budget."
        ],
        "exercises": [
          {
            "title": "Set Up Cloud Cost Monitoring",
            "prompt": "Configure AWS Cost Explorer to monitor a workload’s costs.",
            "difficulty": "medium",
            "hints": [
              "Add cost allocation tags",
              "Use Cost Explorer filters"
            ],
            "solution": "cost-config.yaml: Resources:\n  MyEC2:\n    Type: AWS::EC2::Instance\n    Properties:\n      Tags:\n        - Key: project\n          Value: my-app\ncost-explorer.js: const AWS = require('aws-sdk'); const costexplorer = new AWS.CostExplorer(); async function getCosts() { const params = { TimePeriod: { Start: '2025-09-01', End: '2025-09-16' }, Filter: { Tags: { Key: 'project', Values: ['my-app'] } } }; const data = await costexplorer.getCostAndUsage(params).promise(); console.log(data); } getCosts();"
          }
        ],
        "quiz": [
          {
            "question": "What does FinOps optimize?",
            "options": [
              "UI performance",
              "Cloud costs",
              "Database queries",
              "Code size"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What improves cost tracking?",
            "options": [
              "Static files",
              "Resource tagging",
              "CSS",
              "GraphQL"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "AWS Cost Explorer",
            "url": "https://docs.aws.amazon.com/cost-management/latest/userguide/ce-what-is.html",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fb6",
        "lessonId": "68cf5c5036b0c3df3e9f9fb0"
      },
      {
        "level": "Intermediate",
        "explanation": "Reducing infrastructure costs by 30% involves leveraging caching and autoscaling to optimize resource usage. Caching reduces compute demand, while autoscaling adjusts resources dynamically. This lesson guides you through optimizing a sample workload with Redis caching and Kubernetes HPA, testing for cost savings.",
        "examples": [
          "Caching: redis.set('data', JSON.stringify(result), 'EX', 3600);",
          "HPA: Scale pods based on CPU usage."
        ],
        "realWorldApplication": "Caching and autoscaling are used by Netflix or Spotify to reduce cloud costs.",
        "expertInsights": "Cache frequently accessed data. Tune HPA thresholds for cost efficiency.",
        "commonMistakes": [
          "Caching stale data, affecting accuracy.",
          "Over-scaling, increasing costs unnecessarily."
        ],
        "exercises": [
          {
            "title": "Reduce Costs with Caching and Autoscaling",
            "prompt": "Optimize a workload’s costs using Redis caching and Kubernetes HPA.",
            "difficulty": "hard",
            "hints": [
              "Cache API responses",
              "Configure HPA for CPU"
            ],
            "solution": "app.ts: const express = require('express'); const redis = require('redis'); const client = redis.createClient(); const app = express(); app.get('/data', async (req, res) => { const cached = await client.get('data'); if (cached) return res.json(JSON.parse(cached)); const data = await fetchData(); await client.set('data', JSON.stringify(data), 'EX', 3600); res.json(data); }); app.listen(3000);\nhpa.yaml: apiVersion: autoscaling/v2\nkind: HorizontalPodAutoscaler\nmetadata:\n  name: my-app-hpa\nspec:\n  scaleTargetRef:\n    apiVersion: apps/v1\n    kind: Deployment\n    name: my-app\n  minReplicas: 1\n  maxReplicas: 5\n  metrics:\n  - type: Resource\n    resource:\n      name: cpu\n      target:\n        type: Utilization\n        averageUtilization: 70"
          }
        ],
        "quiz": [
          {
            "question": "What reduces compute demand?",
            "options": [
              "Static files",
              "Caching",
              "UI rendering",
              "Database queries"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What does HPA optimize?",
            "options": [
              "UI performance",
              "Resource usage",
              "CSS styles",
              "Network latency"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 60,
        "resources": [
          {
            "title": "Kubernetes Autoscaling",
            "url": "https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/",
            "type": "doc"
          },
          {
            "title": "Redis Caching",
            "url": "https://redis.io/docs/management/optimization/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fb7",
        "lessonId": "68cf5c5036b0c3df3e9f9fb1"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Intermediate",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master DevOps and continuous delivery at scale with advanced CI/CD, IaC patterns, and progressive delivery using feature flags for robust deployments.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fb8"
      }
    ],
    "courses": [
      {
        "title": "DevOps & Continuous Delivery at Scale",
        "slug": "devops-continuous-delivery",
        "shortDescription": "An intermediate course on advanced CI/CD with multi-environment setups, canary deployments, GitOps, IaC with Terraform/Pulumi, and progressive delivery with feature flags.",
        "longDescription": "This course explores advanced DevOps and continuous delivery practices, covering multi-environment CI/CD pipelines, canary deployments, GitOps with ArgoCD/Flux, Infrastructure as Code (IaC) with Terraform modules and Pulumi, and progressive delivery using feature flags. Through hands-on exercises, real-world examples, and quizzes, you’ll implement a blue-green and canary deployment pipeline with feature flags. The course prepares you to build scalable, automated, and resilient deployment systems for enterprise-grade applications.",
        "tags": [
          "devops",
          "ci-cd",
          "gitops",
          "argocd",
          "flux",
          "iac",
          "terraform",
          "pulumi",
          "feature-flags",
          "canary-deployment"
        ],
        "thumbnail": "https://example.com/thumbnails/devops-cd.jpg",
        "levelSummary": [
          {
            "level": "Intermediate",
            "overview": "Master DevOps with advanced CI/CD, IaC patterns, and progressive delivery for scalable, reliable deployments.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fb9",
        "domainId": "68cf5c5036b0c3df3e9f9fb8"
      }
    ],
    "modules": [
      {
        "level": "Intermediate",
        "title": "Module 1 — DevOps & Continuous Delivery at Scale",
        "slug": "devops-continuous-delivery",
        "description": "Learn advanced CI/CD, GitOps with ArgoCD/Flux, IaC with Terraform/Pulumi, and progressive delivery with feature flags for scalable deployments.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fba",
        "courseId": "68cf5c5036b0c3df3e9f9fb9",
        "lessonIds": [
          "68cf5c5036b0c3df3e9f9fbb",
          "68cf5c5036b0c3df3e9f9fbc",
          "68cf5c5036b0c3df3e9f9fbd",
          "68cf5c5036b0c3df3e9f9fbe",
          "68cf5c5036b0c3df3e9f9fbf",
          "68cf5c5036b0c3df3e9f9fc0"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Intermediate",
        "title": "Introduction to DevOps & Continuous Delivery",
        "slug": "intro-devops-cd",
        "description": "Understand the principles of DevOps and continuous delivery for scalable systems.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fbb",
        "moduleId": "68cf5c5036b0c3df3e9f9fba",
        "contentId": "68cf5c5036b0c3df3e9f9fc1"
      },
      {
        "level": "Intermediate",
        "title": "Advanced CI/CD: Multi-Environment and Canary Deployments",
        "slug": "advanced-ci-cd",
        "description": "Explore multi-environment CI/CD pipelines and canary deployments for safe releases.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fbc",
        "moduleId": "68cf5c5036b0c3df3e9f9fba",
        "contentId": "68cf5c5036b0c3df3e9f9fc2"
      },
      {
        "level": "Intermediate",
        "title": "GitOps with ArgoCD and Flux",
        "slug": "gitops-argocd-flux",
        "description": "Implement GitOps workflows using ArgoCD and Flux for automated deployments.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fbd",
        "moduleId": "68cf5c5036b0c3df3e9f9fba",
        "contentId": "68cf5c5036b0c3df3e9f9fc3"
      },
      {
        "level": "Intermediate",
        "title": "IaC Advanced Patterns: Terraform Modules and Pulumi",
        "slug": "iac-terraform-pulumi",
        "description": "Use Terraform modules and Pulumi for advanced Infrastructure as Code patterns.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fbe",
        "moduleId": "68cf5c5036b0c3df3e9f9fba",
        "contentId": "68cf5c5036b0c3df3e9f9fc4"
      },
      {
        "level": "Intermediate",
        "title": "Progressive Delivery with Feature Flags",
        "slug": "progressive-delivery-feature-flags",
        "description": "Implement progressive delivery using feature flags for controlled rollouts.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fbf",
        "moduleId": "68cf5c5036b0c3df3e9f9fba",
        "contentId": "68cf5c5036b0c3df3e9f9fc5"
      },
      {
        "level": "Intermediate",
        "title": "Blue-Green and Canary Deployment Pipeline with Feature Flags",
        "slug": "blue-green-canary-pipeline",
        "description": "Build a blue-green and canary deployment pipeline with feature flags for safe releases.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fc0",
        "moduleId": "68cf5c5036b0c3df3e9f9fba",
        "contentId": "68cf5c5036b0c3df3e9f9fc6"
      }
    ],
    "learningContents": [
      {
        "level": "Intermediate",
        "explanation": "DevOps and continuous delivery at scale automate deployments and infrastructure management for reliable, fast releases. This lesson introduces advanced CI/CD, GitOps, IaC, and progressive delivery, covering their roles in modern systems. You’ll learn to set up a DevOps project and understand trade-offs for automation and reliability.",
        "examples": [
          "CI/CD: GitHub Actions workflow for multi-env deployments.",
          "Run: npm install -g terraform // Initialize IaC setup"
        ],
        "realWorldApplication": "These practices are used by Netflix, GitHub, and AWS for automated, scalable deployments.",
        "expertInsights": "Automate everything but test manually for critical paths. Use GitOps for auditability.",
        "commonMistakes": [
          "Overcomplicating pipelines, slowing releases.",
          "Not testing rollbacks, risking downtime."
        ],
        "exercises": [
          {
            "title": "Plan a DevOps Pipeline",
            "prompt": "Outline a CI/CD pipeline with GitOps and feature flags.",
            "difficulty": "easy",
            "hints": [
              "Include multi-env stages",
              "Define feature flag integration"
            ],
            "solution": "pipeline.yaml: stages:\n  - build\n  - deploy: [staging, production]\n// GitOps: Use ArgoCD\n// Feature flags: Integrate LaunchDarkly"
          }
        ],
        "quiz": [
          {
            "question": "What improves deployment reliability?",
            "options": [
              "Manual deploys",
              "CI/CD pipelines",
              "Inline scripts",
              "Static files"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why use GitOps?",
            "options": [
              "UI rendering",
              "Automated deployments",
              "Database queries",
              "Code bundling"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 30,
        "resources": [
          {
            "title": "DevOps Handbook",
            "url": "https://www.devops.com/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fc1",
        "lessonId": "68cf5c5036b0c3df3e9f9fbb"
      },
      {
        "level": "Intermediate",
        "explanation": "Advanced CI/CD pipelines support multi-environment setups and canary deployments to minimize risks during releases. This lesson covers configuring pipelines with tools like GitHub Actions or Jenkins, implementing canary strategies, and testing deployments across staging and production.",
        "examples": [
          "Canary: Deploy to 10% of users with weight: 10 in Kubernetes.",
          "GitHub Actions: Run tests and deploy to staging."
        ],
        "realWorldApplication": "Canary deployments are used by Spotify and Netflix for safe rollouts.",
        "expertInsights": "Use canary for critical services. Monitor metrics during rollouts.",
        "commonMistakes": [
          "Not monitoring canary metrics, missing issues.",
          "Skipping staging, risking production failures."
        ],
        "exercises": [
          {
            "title": "Set Up a Canary Deployment",
            "prompt": "Configure a CI/CD pipeline with canary deployment for a Kubernetes app.",
            "difficulty": "medium",
            "hints": [
              "Use GitHub Actions",
              "Define canary weights"
            ],
            "solution": "workflow.yml: name: CI/CD\non: [push]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy Canary\n        run: kubectl apply -f canary.yaml\ncanary.yaml: apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-app\n  annotations:\n    nginx.ingress.kubernetes.io/canary: 'true'\n    nginx.ingress.kubernetes.io/canary-weight: '10'"
          }
        ],
        "quiz": [
          {
            "question": "What does canary deployment reduce?",
            "options": [
              "Code size",
              "Release risks",
              "UI latency",
              "Database queries"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What runs CI/CD pipelines?",
            "options": [
              "Redis",
              "GitHub Actions",
              "MongoDB",
              "Vite"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 45,
        "resources": [
          {
            "title": "Canary Deployments in Kubernetes",
            "url": "https://kubernetes.io/docs/concepts/cluster-administration/canary-deployments/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fc2",
        "lessonId": "68cf5c5036b0c3df3e9f9fbc"
      },
      {
        "level": "Intermediate",
        "explanation": "GitOps with tools like ArgoCD and Flux automates deployments by syncing Kubernetes clusters with Git repositories. This lesson covers setting up ArgoCD or Flux, defining application manifests in Git, and automating deployments for consistency and auditability.",
        "examples": [
          "ArgoCD: argocd app create my-app --repo https://github.com/my/repo",
          "Flux: flux bootstrap github --owner=my-user --repository=my-repo"
        ],
        "realWorldApplication": "GitOps is used by GitLab and Weaveworks for automated Kubernetes deployments.",
        "expertInsights": "Use ArgoCD for complex apps, Flux for simplicity. Version manifests for rollback.",
        "commonMistakes": [
          "Not securing Git repos, risking unauthorized changes.",
          "Ignoring sync failures, causing drift."
        ],
        "exercises": [
          {
            "title": "Set Up GitOps with ArgoCD",
            "prompt": "Configure ArgoCD to deploy an app from a Git repository.",
            "difficulty": "medium",
            "hints": [
              "Define app manifest",
              "Use ArgoCD CLI"
            ],
            "solution": "app.yaml: apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: my-app\nspec:\n  source:\n    repoURL: https://github.com/my/repo\n    path: manifests\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: default\nsetup.sh: argocd app create my-app --repo https://github.com/my/repo --path manifests --dest-server https://kubernetes.default.svc --dest-namespace default"
          }
        ],
        "quiz": [
          {
            "question": "What does GitOps sync?",
            "options": [
              "UI components",
              "Git and clusters",
              "Database queries",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What tool enables GitOps?",
            "options": [
              "Redis",
              "ArgoCD",
              "MongoDB",
              "Vite"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "ArgoCD Documentation",
            "url": "https://argoproj.github.io/argo-cd/",
            "type": "doc"
          },
          {
            "title": "Flux Documentation",
            "url": "https://fluxcd.io/docs/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fc3",
        "lessonId": "68cf5c5036b0c3df3e9f9fbd"
      },
      {
        "level": "Intermediate",
        "explanation": "Infrastructure as Code (IaC) with Terraform modules and Pulumi enables reusable, cross-language infrastructure management. Terraform modules abstract resources, while Pulumi uses programming languages. This lesson covers creating reusable modules and deploying infrastructure with both tools.",
        "examples": [
          "Terraform: module 'vpc' { source = './modules/vpc' }",
          "Pulumi: new aws.ec2.Vpc('my-vpc', { cidrBlock: '10.0.0.0/16' });"
        ],
        "realWorldApplication": "IaC is used by HashiCorp and AWS for automated infrastructure provisioning.",
        "expertInsights": "Use Terraform for declarative configs, Pulumi for programmatic control. Version modules.",
        "commonMistakes": [
          "Hardcoding values, reducing reusability.",
          "Not testing IaC, causing deployment failures."
        ],
        "exercises": [
          {
            "title": "Create a Terraform Module",
            "prompt": "Define a reusable Terraform module for an S3 bucket.",
            "difficulty": "medium",
            "hints": [
              "Use module structure",
              "Define variables"
            ],
            "solution": "modules/s3/main.tf: resource 'aws_s3_bucket' 'bucket' { bucket = var.bucket_name }\nvariables.tf: variable 'bucket_name' { type = string }\nmain.tf: module 's3' { source = './modules/s3' bucket_name = 'my-bucket' }"
          }
        ],
        "quiz": [
          {
            "question": "What does Terraform modules enable?",
            "options": [
              "UI rendering",
              "Reusable infrastructure",
              "Database queries",
              "Code bundling"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What language does Pulumi use?",
            "options": [
              "SQL",
              "JavaScript",
              "CSS",
              "XML"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Terraform Modules",
            "url": "https://www.terraform.io/docs/language/modules/",
            "type": "doc"
          },
          {
            "title": "Pulumi Documentation",
            "url": "https://www.pulumi.com/docs/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fc4",
        "lessonId": "68cf5c5036b0c3df3e9f9fbe"
      },
      {
        "level": "Intermediate",
        "explanation": "Progressive delivery with feature flags enables controlled rollouts by toggling features for specific users or environments. Tools like LaunchDarkly or Unleash manage flags. This lesson covers integrating feature flags, testing rollouts, and ensuring safe deployments.",
        "examples": [
          "LaunchDarkly: ld.variation('new-feature', user, false);",
          "Unleash: isEnabled('new-feature');"
        ],
        "realWorldApplication": "Feature flags are used by GitHub and Airbnb for controlled feature releases.",
        "expertInsights": "Use flags for A/B testing. Remove stale flags to reduce complexity.",
        "commonMistakes": [
          "Not cleaning up flags, causing technical debt.",
          "Overusing flags, complicating code."
        ],
        "exercises": [
          {
            "title": "Implement Feature Flags",
            "prompt": "Add feature flags to a Node.js app using Unleash.",
            "difficulty": "medium",
            "hints": [
              "Use Unleash SDK",
              "Toggle a feature"
            ],
            "solution": "app.ts: const { Unleash } = require('unleash-client'); const unleash = new Unleash({ url: 'http://unleash:4242/api', appName: 'my-app' }); app.get('/', (req, res) => { const enabled = unleash.isEnabled('new-feature'); res.send(enabled ? 'New Feature' : 'Old Feature'); }); app.listen(3000);"
          }
        ],
        "quiz": [
          {
            "question": "What do feature flags enable?",
            "options": [
              "Database queries",
              "Controlled rollouts",
              "UI rendering",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What manages feature flags?",
            "options": [
              "Redis",
              "LaunchDarkly",
              "MongoDB",
              "Vite"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "LaunchDarkly Documentation",
            "url": "https://docs.launchdarkly.com/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fc5",
        "lessonId": "68cf5c5036b0c3df3e9f9fbf"
      },
      {
        "level": "Intermediate",
        "explanation": "Blue-green and canary deployment pipelines with feature flags ensure safe, scalable releases by minimizing downtime and risks. Blue-green switches traffic between environments, while canary tests new versions on a subset of users. This lesson guides you through building a pipeline with GitHub Actions, Kubernetes, and feature flags.",
        "examples": [
          "Blue-green: kubectl set image deployment/my-app my-app=new-image",
          "Canary: nginx.ingress.kubernetes.io/canary-weight: '10'"
        ],
        "realWorldApplication": "Blue-green and canary deployments are used by Amazon and Google for reliable releases.",
        "expertInsights": "Use blue-green for zero-downtime. Combine canary with feature flags for granular control.",
        "commonMistakes": [
          "Not monitoring canary metrics, missing errors.",
          "Skipping rollback plans, risking failures."
        ],
        "exercises": [
          {
            "title": "Blue-Green and Canary Pipeline with Feature Flags",
            "prompt": "Build a pipeline with blue-green and canary deployments using feature flags.",
            "difficulty": "hard",
            "hints": [
              "Use GitHub Actions",
              "Integrate LaunchDarkly"
            ],
            "solution": "workflow.yml: name: Blue-Green and Canary\non: [push]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy Blue\n        run: kubectl apply -f blue.yaml\n      - name: Deploy Canary\n        run: kubectl apply -f canary.yaml\nblue.yaml: apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: my-app-blue\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: my-app\n      env: blue\n  template:\n    metadata:\n      labels:\n        app: my-app\n        env: blue\n    spec:\n      containers:\n      - name: my-app\n        image: my-app:latest\ncanary.yaml: apiVersion: networking.k8s.io/v1\nkind: Ingress\nmetadata:\n  name: my-app-canary\n  annotations:\n    nginx.ingress.kubernetes.io/canary: 'true'\n    nginx.ingress.kubernetes.io/canary-weight: '10'\napp.ts: const { Unleash } = require('unleash-client'); const unleash = new Unleash({ url: 'http://unleash:4242/api', appName: 'my-app' }); app.get('/', (req, res) => { const enabled = unleash.isEnabled('new-feature'); res.send(enabled ? 'Canary Feature' : 'Stable Feature'); }); app.listen(3000);"
          }
        ],
        "quiz": [
          {
            "question": "What does blue-green deployment ensure?",
            "options": [
              "UI rendering",
              "Zero downtime",
              "Database queries",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What tests new versions in canary?",
            "options": [
              "All users",
              "Subset of users",
              "Static files",
              "UI components"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 60,
        "resources": [
          {
            "title": "Blue-Green Deployments",
            "url": "https://www.redhat.com/en/topics/devops/what-is-blue-green-deployment",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fc6",
        "lessonId": "68cf5c5036b0c3df3e9f9fc0"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Intermediate",
        "name": "Professional Development",
        "slug": "professional-development",
        "description": "Master soft skills and leadership for technical roles, including system design interview prep, cross-team collaboration, and mentoring with code reviews at scale.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fc7"
      }
    ],
    "courses": [
      {
        "title": "Soft Skills & Leadership",
        "slug": "soft-skills-leadership",
        "shortDescription": "An intermediate course on soft skills for technical leadership, covering system design interviews, cross-team collaboration with API contracts and RFCs, and mentoring with scalable code reviews.",
        "longDescription": "This course focuses on essential soft skills and leadership techniques for technical professionals, including preparing for system design interviews, fostering collaboration across teams through API contracts and RFCs, and mentoring via scalable code review processes. Through hands-on exercises, real-world examples, and quizzes, you’ll write and present an RFC for a new system feature, analyzing its trade-offs. The course equips you to lead effectively, communicate clearly, and mentor teams in high-growth technical environments.",
        "tags": [
          "soft-skills",
          "leadership",
          "system-design",
          "api-contracts",
          "rfcs",
          "mentoring",
          "code-reviews"
        ],
        "thumbnail": "https://example.com/thumbnails/soft-skills-leadership.jpg",
        "levelSummary": [
          {
            "level": "Intermediate",
            "overview": "Master soft skills and leadership with system design prep, cross-team collaboration, and scalable mentoring for technical roles.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fc8",
        "domainId": "68cf5c5036b0c3df3e9f9fc7"
      }
    ],
    "modules": [
      {
        "level": "Intermediate",
        "title": "Module 1 — Soft Skills & Leadership",
        "slug": "soft-skills-leadership",
        "description": "Learn system design interview preparation, cross-team collaboration with API contracts and RFCs, and mentoring through scalable code reviews.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fc9",
        "courseId": "68cf5c5036b0c3df3e9f9fc8",
        "lessonIds": [
          "68cf5c5036b0c3df3e9f9fca",
          "68cf5c5036b0c3df3e9f9fcb",
          "68cf5c5036b0c3df3e9f9fcc",
          "68cf5c5036b0c3df3e9f9fcd",
          "68cf5c5036b0c3df3e9f9fce"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Intermediate",
        "title": "Introduction to Soft Skills & Leadership",
        "slug": "intro-soft-skills-leadership",
        "description": "Understand the role of soft skills and leadership in technical environments.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fca",
        "moduleId": "68cf5c5036b0c3df3e9f9fc9",
        "contentId": "68cf5c5036b0c3df3e9f9fcf"
      },
      {
        "level": "Intermediate",
        "title": "System Design Interview Preparation",
        "slug": "system-design-interview",
        "description": "Prepare for system design interviews by practicing scalable architecture design.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fcb",
        "moduleId": "68cf5c5036b0c3df3e9f9fc9",
        "contentId": "68cf5c5036b0c3df3e9f9fd0"
      },
      {
        "level": "Intermediate",
        "title": "Collaboration Across Teams: API Contracts and RFCs",
        "slug": "collaboration-api-rfcs",
        "description": "Foster cross-team collaboration using API contracts and Request for Comments (RFCs).",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fcc",
        "moduleId": "68cf5c5036b0c3df3e9f9fc9",
        "contentId": "68cf5c5036b0c3df3e9f9fd1"
      },
      {
        "level": "Intermediate",
        "title": "Mentoring and Code Reviews at Scale",
        "slug": "mentoring-code-reviews",
        "description": "Learn mentoring techniques and scalable code review processes for teams.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fcd",
        "moduleId": "68cf5c5036b0c3df3e9f9fc9",
        "contentId": "68cf5c5036b0c3df3e9f9fd2"
      },
      {
        "level": "Intermediate",
        "title": "Writing and Presenting an RFC",
        "slug": "write-present-rfc",
        "description": "Write an RFC for a new system feature and present its trade-offs effectively.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fce",
        "moduleId": "68cf5c5036b0c3df3e9f9fc9",
        "contentId": "68cf5c5036b0c3df3e9f9fd3"
      }
    ],
    "learningContents": [
      {
        "level": "Intermediate",
        "explanation": "Soft skills and leadership are critical for technical professionals to drive collaboration, mentor teams, and succeed in interviews. This lesson introduces system design interview prep, cross-team collaboration with API contracts and RFCs, and scalable mentoring, emphasizing communication and leadership in technical roles.",
        "examples": [
          "RFC: Propose a new API endpoint with clear objectives.",
          "Run: Practice system design with mock interviews."
        ],
        "realWorldApplication": "These skills are used by engineers at Google, Amazon, and Microsoft to lead projects and mentor teams.",
        "expertInsights": "Practice clear communication in RFCs. Use structured feedback in code reviews.",
        "commonMistakes": [
          "Neglecting stakeholder input in RFCs, causing misalignment.",
          "Providing vague feedback in code reviews, slowing progress."
        ],
        "exercises": [
          {
            "title": "Plan a Leadership Strategy",
            "prompt": "Outline a plan for system design prep and team collaboration.",
            "difficulty": "easy",
            "hints": [
              "Include RFC structure",
              "Define mentoring goals"
            ],
            "solution": "plan.md: # Leadership Plan\n- System Design: Practice scalability questions\n- Collaboration: Draft RFC for new feature\n- Mentoring: Set up weekly code reviews"
          }
        ],
        "quiz": [
          {
            "question": "What improves technical leadership?",
            "options": [
              "Inline scripts",
              "Soft skills",
              "Database queries",
              "Static files"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why use RFCs?",
            "options": [
              "UI rendering",
              "Team alignment",
              "Code bundling",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 30,
        "resources": [
          {
            "title": "The Manager’s Path",
            "url": "https://www.oreilly.com/library/view/the-managers-path/9781491973882/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fcf",
        "lessonId": "68cf5c5036b0c3df3e9f9fca"
      },
      {
        "level": "Intermediate",
        "explanation": "System design interviews test your ability to architect scalable, reliable systems. This lesson covers preparing for these interviews by practicing common patterns like load balancing, caching, and database sharding, along with effective communication of trade-offs.",
        "examples": [
          "Design: Scalable URL shortener with Redis cache and MySQL.",
          "Diagram: [Client -> Load Balancer -> App Servers -> Database]"
        ],
        "realWorldApplication": "System design skills are used in interviews at FAANG companies and for real-world systems like Twitter’s URL shortener.",
        "expertInsights": "Focus on scalability and trade-offs. Practice whiteboarding under time constraints.",
        "commonMistakes": [
          "Overcomplicating designs, losing clarity.",
          "Ignoring non-functional requirements like latency."
        ],
        "exercises": [
          {
            "title": "Practice System Design",
            "prompt": "Design a scalable chat system and explain trade-offs.",
            "difficulty": "medium",
            "hints": [
              "Use WebSocket for real-time",
              "Consider sharding for scale"
            ],
            "solution": "chat-design.md: # Chat System Design\n- Components: WebSocket servers, Redis pub/sub, sharded MySQL\n- Trade-offs: Redis for speed vs. MySQL for persistence\n- Scalability: Shard by user ID"
          }
        ],
        "quiz": [
          {
            "question": "What is key in system design interviews?",
            "options": [
              "UI design",
              "Scalability",
              "CSS styles",
              "Static files"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What improves design clarity?",
            "options": [
              "Complex logic",
              "Trade-off analysis",
              "Inline scripts",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 45,
        "resources": [
          {
            "title": "System Design Primer",
            "url": "https://github.com/donnemartin/system-design-primer",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fd0",
        "lessonId": "68cf5c5036b0c3df3e9f9fcb"
      },
      {
        "level": "Intermediate",
        "explanation": "Collaboration across teams requires clear API contracts and Request for Comments (RFCs) to align stakeholders. API contracts define interfaces, while RFCs propose changes with feedback. This lesson covers drafting API contracts and RFCs, ensuring clarity and consensus.",
        "examples": [
          "API Contract: GET /users/{id} returns { id, name }",
          "RFC: Propose a new authentication flow with OAuth2."
        ],
        "realWorldApplication": "API contracts and RFCs are used by GitHub and Stripe to align engineering teams.",
        "expertInsights": "Keep contracts simple and versioned. Solicit early feedback on RFCs.",
        "commonMistakes": [
          "Vague API contracts, causing integration issues.",
          "Skipping RFC reviews, missing stakeholder input."
        ],
        "exercises": [
          {
            "title": "Draft an API Contract and RFC",
            "prompt": "Create an API contract and RFC for a user profile endpoint.",
            "difficulty": "medium",
            "hints": [
              "Use OpenAPI for contract",
              "Structure RFC with goals and trade-offs"
            ],
            "solution": "api.yaml: openapi: 3.0.0\npaths:\n  /users/{id}:\n    get:\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  id: { type: string }\n                  name: { type: string }\nrfc.md: # RFC: User Profile Endpoint\n- Goal: Provide user data access\n- Proposal: GET /users/{id}\n- Trade-offs: REST vs. GraphQL (REST chosen for simplicity)"
          }
        ],
        "quiz": [
          {
            "question": "What do API contracts define?",
            "options": [
              "UI layouts",
              "Service interfaces",
              "Database schemas",
              "CSS styles"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What is the purpose of an RFC?",
            "options": [
              "Code execution",
              "Stakeholder alignment",
              "UI rendering",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "OpenAPI Specification",
            "url": "https://swagger.io/specification/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fd1",
        "lessonId": "68cf5c5036b0c3df3e9f9fcc"
      },
      {
        "level": "Intermediate",
        "explanation": "Mentoring and code reviews at scale improve team skills and code quality. Effective mentoring involves clear feedback, while scalable code reviews use tools like GitHub or Gerrit. This lesson covers mentoring techniques, structuring reviews, and automating review processes.",
        "examples": [
          "Feedback: Suggest replacing loop with map for clarity.",
          "Tool: GitHub pull request with review comments."
        ],
        "realWorldApplication": "Code reviews and mentoring are used at Google and Microsoft to maintain code quality.",
        "expertInsights": "Focus on constructive feedback. Automate linting to reduce review load.",
        "commonMistakes": [
          "Vague feedback, confusing mentees.",
          "Not prioritizing critical issues in reviews."
        ],
        "exercises": [
          {
            "title": "Conduct a Code Review",
            "prompt": "Review a sample code change and provide feedback.",
            "difficulty": "medium",
            "hints": [
              "Check for readability",
              "Suggest improvements"
            ],
            "solution": "review.md: # Code Review\n- File: app.js\n- Issue: Hardcoded API key\n- Suggestion: Move to environment variable\n```javascript\n// Bad: const apiKey = '123';\n// Good: const apiKey = process.env.API_KEY;\n```"
          }
        ],
        "quiz": [
          {
            "question": "What improves code reviews?",
            "options": [
              "Vague comments",
              "Constructive feedback",
              "Inline scripts",
              "Static files"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What automates review tasks?",
            "options": [
              "Linters",
              "Redis",
              "MongoDB",
              "Vite"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Google’s Code Review Guidelines",
            "url": "https://google.github.io/eng-practices/review/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fd2",
        "lessonId": "68cf5c5036b0c3df3e9f9fcd"
      },
      {
        "level": "Intermediate",
        "explanation": "Writing and presenting an RFC for a new system feature ensures alignment by clearly outlining goals, implementation, and trade-offs. This lesson guides you through drafting an RFC, soliciting feedback, and presenting it to stakeholders, focusing on clarity and persuasion.",
        "examples": [
          "RFC: # Feature: Real-Time Notifications\n- Goal: Improve user engagement\n- Trade-offs: WebSocket vs. polling",
          "Presentation: Summarize RFC in 5 minutes with diagrams."
        ],
        "realWorldApplication": "RFCs are used by Amazon and GitLab to propose and align on new features.",
        "expertInsights": "Structure RFCs for clarity. Anticipate stakeholder questions in presentations.",
        "commonMistakes": [
          "Omitting trade-offs, weakening proposals.",
          "Not addressing feedback, losing buy-in."
        ],
        "exercises": [
          {
            "title": "Write and Present an RFC",
            "prompt": "Draft an RFC for a real-time chat feature and outline trade-offs.",
            "difficulty": "hard",
            "hints": [
              "Use clear sections",
              "Compare WebSocket vs. polling"
            ],
            "solution": "rfc.md: # RFC: Real-Time Chat Feature\n## Goal\nEnable real-time messaging for users.\n## Proposal\nImplement WebSocket-based chat.\n## Trade-offs\n- WebSocket: Low latency, complex scaling\n- Polling: Simpler, higher latency\n## Implementation\n- Backend: Node.js with ws\n- Frontend: React with WebSocket client\n## Risks\n- Scaling WebSocket connections\n## Mitigation\n- Use Redis pub/sub for scalability"
          }
        ],
        "quiz": [
          {
            "question": "What does an RFC align?",
            "options": [
              "UI components",
              "Stakeholders",
              "Database queries",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What strengthens an RFC?",
            "options": [
              "Vague goals",
              "Trade-off analysis",
              "Inline scripts",
              "Static files"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 60,
        "resources": [
          {
            "title": "How to Write an RFC",
            "url": "https://www.ietf.org/about/process-docs/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fd3",
        "lessonId": "68cf5c5036b0c3df3e9f9fce"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Intermediate",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Build a production-grade SaaS application with multi-tenant architecture, API gateway, microservices, real-time collaboration, monitoring, and cloud deployment with CI/CD.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fd4"
      }
    ],
    "courses": [
      {
        "title": "Capstone Project: Advanced SaaS",
        "slug": "capstone-saas",
        "shortDescription": "An advanced course guiding you through building a production-grade SaaS app with multi-tenant architecture, microservices, real-time features, monitoring, and CI/CD deployment.",
        "longDescription": "This capstone project course guides you through building a production-grade SaaS application, covering multi-tenant architecture, API gateway with microservices, real-time collaboration features, and monitoring with alerts and dashboards. You’ll deploy the app on a cloud platform using CI/CD pipelines. Through hands-on development, real-world examples, and quizzes, you’ll deliver a working app, a design document, and a monitoring setup. The course prepares you to architect, build, and deploy scalable SaaS applications in enterprise environments.",
        "tags": [
          "saas",
          "multi-tenant",
          "api-gateway",
          "microservices",
          "real-time",
          "monitoring",
          "ci-cd",
          "cloud-deployment"
        ],
        "thumbnail": "https://example.com/thumbnails/capstone-saas.jpg",
        "levelSummary": [
          {
            "level": "Intermediate",
            "overview": "Build a production-grade SaaS app with multi-tenant architecture, microservices, real-time collaboration, and cloud deployment with monitoring.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fd5",
        "domainId": "68cf5c5036b0c3df3e9f9fd4"
      }
    ],
    "modules": [
      {
        "level": "Intermediate",
        "title": "Module 1 — Capstone Project: Advanced SaaS",
        "slug": "capstone-saas",
        "description": "Learn to build a SaaS app with multi-tenant architecture, API gateway, microservices, real-time collaboration, monitoring, and CI/CD deployment.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fd6",
        "courseId": "68cf5c5036b0c3df3e9f9fd5",
        "lessonIds": [
          "68cf5c5036b0c3df3e9f9fd7",
          "68cf5c5036b0c3df3e9f9fd8",
          "68cf5c5036b0c3df3e9f9fd9",
          "68cf5c5036b0c3df3e9f9fda",
          "68cf5c5036b0c3df3e9f9fdb",
          "68cf5c5036b0c3df3e9f9fdc"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Intermediate",
        "title": "Introduction to SaaS Application Development",
        "slug": "intro-saas-development",
        "description": "Understand the components and architecture of a production-grade SaaS application.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fd7",
        "moduleId": "68cf5c5036b0c3df3e9f9fd6",
        "contentId": "68cf5c5036b0c3df3e9f9fdd"
      },
      {
        "level": "Intermediate",
        "title": "Designing a Multi-Tenant Architecture",
        "slug": "multi-tenant-architecture",
        "description": "Design a multi-tenant architecture to support isolated tenant data and scalability.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fd8",
        "moduleId": "68cf5c5036b0c3df3e9f9fd6",
        "contentId": "68cf5c5036b0c3df3e9f9fde"
      },
      {
        "level": "Intermediate",
        "title": "Implementing API Gateway and Microservices",
        "slug": "api-gateway-microservices",
        "description": "Build an API gateway and microservices for modular, scalable SaaS functionality.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fd9",
        "moduleId": "68cf5c5036b0c3df3e9f9fd6",
        "contentId": "68cf5c5036b0c3df3e9f9fdf"
      },
      {
        "level": "Intermediate",
        "title": "Adding Real-Time Collaboration Features",
        "slug": "real-time-collaboration",
        "description": "Implement real-time collaboration using WebSocket and CRDTs.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fda",
        "moduleId": "68cf5c5036b0c3df3e9f9fd6",
        "contentId": "68cf5c5036b0c3df3e9f9fe0"
      },
      {
        "level": "Intermediate",
        "title": "Setting Up Monitoring, Alerts, and Dashboards",
        "slug": "monitoring-alerts-dashboards",
        "description": "Configure monitoring, alerts, and dashboards for observability in a SaaS app.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fdb",
        "moduleId": "68cf5c5036b0c3df3e9f9fd6",
        "contentId": "68cf5c5036b0c3df3e9f9fe1"
      },
      {
        "level": "Intermediate",
        "title": "Deploying to Cloud with CI/CD",
        "slug": "cloud-deployment-cicd",
        "description": "Deploy the SaaS app to a cloud platform with a CI/CD pipeline and deliver a design doc.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fdc",
        "moduleId": "68cf5c5036b0c3df3e9f9fd6",
        "contentId": "68cf5c5036b0c3df3e9f9fe2"
      }
    ],
    "learningContents": [
      {
        "level": "Intermediate",
        "explanation": "Building a production-grade SaaS application requires integrating multi-tenant architecture, microservices, real-time features, monitoring, and CI/CD pipelines. This lesson introduces these components, their roles in SaaS, and how to plan a project for scalability, reliability, and observability.",
        "examples": [
          "Multi-tenant: Use tenant_id in database schemas.",
          "Run: docker-compose up // Start microservices locally"
        ],
        "realWorldApplication": "SaaS apps like Slack, Salesforce, or Notion use these patterns for scalability and collaboration.",
        "expertInsights": "Design for tenant isolation early. Prioritize observability for debugging.",
        "commonMistakes": [
          "Mixing tenant data, breaking isolation.",
          "Skipping CI/CD, slowing deployments."
        ],
        "exercises": [
          {
            "title": "Plan a SaaS Architecture",
            "prompt": "Outline a SaaS app with multi-tenant and microservices components.",
            "difficulty": "easy",
            "hints": [
              "Define tenant isolation",
              "Include monitoring tools"
            ],
            "solution": "plan.md: # SaaS Architecture\n- Multi-tenant: Schema-based isolation\n- Microservices: User, Billing, Collaboration\n- Monitoring: Prometheus\n- CI/CD: GitHub Actions"
          }
        ],
        "quiz": [
          {
            "question": "What enables SaaS scalability?",
            "options": [
              "Monoliths",
              "Microservices",
              "Static files",
              "Inline scripts"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "Why use monitoring in SaaS?",
            "options": [
              "UI rendering",
              "Observability",
              "Database queries",
              "Code bundling"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 30,
        "resources": [
          {
            "title": "Building SaaS Applications",
            "url": "https://aws.amazon.com/architecture/saas/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fdd",
        "lessonId": "68cf5c5036b0c3df3e9f9fd7"
      },
      {
        "level": "Intermediate",
        "explanation": "Multi-tenant architecture isolates data and resources for each tenant, ensuring scalability and security. This lesson covers designing tenant isolation (e.g., schema-based or database-based), implementing tenant routing, and testing for data separation.",
        "examples": [
          "Schema: CREATE SCHEMA tenant_{id};",
          "Routing: Route requests by tenant_id header."
        ],
        "realWorldApplication": "Multi-tenancy is used by SaaS platforms like Shopify and HubSpot for tenant isolation.",
        "expertInsights": "Use schema-based isolation for simplicity. Monitor tenant resource usage.",
        "commonMistakes": [
          "Not isolating tenant data, risking leaks.",
          "Overcomplicating routing, slowing performance."
        ],
        "exercises": [
          {
            "title": "Design Multi-Tenant Routing",
            "prompt": "Implement tenant-based routing in a Node.js app.",
            "difficulty": "medium",
            "hints": [
              "Use tenant_id header",
              "Route to tenant schema"
            ],
            "solution": "app.ts: const express = require('express'); const app = express(); app.use((req, res, next) => { const tenantId = req.headers['tenant-id']; req.tenantSchema = `tenant_${tenantId}`; next(); }); app.get('/data', async (req, res) => { const data = await db.query(`SELECT * FROM ${req.tenantSchema}.data`); res.json(data); }); app.listen(3000);"
          }
        ],
        "quiz": [
          {
            "question": "What does multi-tenancy ensure?",
            "options": [
              "UI rendering",
              "Data isolation",
              "Database queries",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What routes tenant requests?",
            "options": [
              "CSS",
              "Tenant ID",
              "Redis",
              "GraphQL"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 45,
        "resources": [
          {
            "title": "Multi-Tenancy Patterns",
            "url": "https://docs.microsoft.com/en-us/azure/architecture/patterns/multi-tenancy",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fde",
        "lessonId": "68cf5c5036b0c3df3e9f9fd8"
      },
      {
        "level": "Intermediate",
        "explanation": "An API gateway routes requests to microservices, providing authentication, rate limiting, and observability. Microservices modularize functionality for scalability. This lesson covers setting up an API gateway (e.g., Kong or AWS API Gateway) and building microservices with Node.js or Go.",
        "examples": [
          "API Gateway: Kong route: /api/users -> user-service",
          "Microservice: Go service with HTTP endpoint."
        ],
        "realWorldApplication": "API gateways and microservices are used by Netflix and Amazon for modular SaaS apps.",
        "expertInsights": "Use gateways for centralized auth. Keep microservices small and focused.",
        "commonMistakes": [
          "Overloading gateways, slowing requests.",
          "Coupling microservices, reducing modularity."
        ],
        "exercises": [
          {
            "title": "Set Up API Gateway and Microservice",
            "prompt": "Configure an API gateway to route to a user microservice.",
            "difficulty": "medium",
            "hints": [
              "Use Kong or AWS API Gateway",
              "Define a simple microservice"
            ],
            "solution": "kong.yaml: services:\n- name: user-service\n  url: http://user-service:8080\n  routes:\n  - name: users\n    paths:\n    - /api/users\nuser-service.go: package main\nimport ( \"net/http\" )\nfunc main() { http.HandleFunc(\"/users\", func(w http.ResponseWriter, r *http.Request) { w.Write([]byte(\"Users\")) }); http.ListenAndServe(\":8080\", nil) }"
          }
        ],
        "quiz": [
          {
            "question": "What does an API gateway manage?",
            "options": [
              "UI rendering",
              "Request routing",
              "Database queries",
              "CSS styles"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What improves microservice scalability?",
            "options": [
              "Monoliths",
              "Modularity",
              "Static files",
              "Inline scripts"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Kong API Gateway",
            "url": "https://docs.konghq.com/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fdf",
        "lessonId": "68cf5c5036b0c3df3e9f9fd9"
      },
      {
        "level": "Intermediate",
        "explanation": "Real-time collaboration features, like those in Google Docs, enable users to work simultaneously. Technologies like WebSocket and CRDTs ensure low-latency updates. This lesson covers implementing a collaborative editor with WebSocket and a CRDT library for conflict-free updates.",
        "examples": [
          "WebSocket: ws.send(JSON.stringify({ op: 'insert', char: 'a' }));",
          "CRDT: Merge operations for consistent state."
        ],
        "realWorldApplication": "Real-time collaboration is used by Notion and Figma for shared editing.",
        "expertInsights": "Use WebSocket for low latency. Optimize CRDT merges for performance.",
        "commonMistakes": [
          "Not handling network delays, breaking sync.",
          "Ignoring CRDT conflicts, causing data loss."
        ],
        "exercises": [
          {
            "title": "Build a Collaborative Editor",
            "prompt": "Implement a real-time text editor with WebSocket and CRDTs.",
            "difficulty": "hard",
            "hints": [
              "Use ws library",
              "Implement simple CRDT"
            ],
            "solution": "server.ts: const WebSocket = require('ws'); const wss = new WebSocket.Server({ port: 8080 }); const crdt = { text: '', ops: [] }; wss.on('connection', ws => { ws.on('message', data => { const op = JSON.parse(data); crdt.ops.push(op); crdt.text += op.char; wss.clients.forEach(client => client.send(JSON.stringify(op))); }); });"
          }
        ],
        "quiz": [
          {
            "question": "What enables real-time collaboration?",
            "options": [
              "Static files",
              "WebSocket",
              "CSS",
              "SQL"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What do CRDTs prevent?",
            "options": [
              "UI errors",
              "Data conflicts",
              "Network latency",
              "Code bundling"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "CRDTs Explained",
            "url": "https://crdt.tech/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fe0",
        "lessonId": "68cf5c5036b0c3df3e9f9fda"
      },
      {
        "level": "Intermediate",
        "explanation": "Monitoring, alerts, and dashboards provide observability for SaaS apps, tracking performance and errors. Tools like Prometheus and Grafana visualize metrics. This lesson covers setting up monitoring, configuring alerts, and building dashboards for a SaaS app.",
        "examples": [
          "Prometheus: prometheus.yml with scrape_configs.",
          "Grafana: Dashboard for request latency."
        ],
        "realWorldApplication": "Monitoring is used by Datadog and AWS CloudWatch for SaaS observability.",
        "expertInsights": "Monitor key metrics like latency and errors. Set actionable alerts.",
        "commonMistakes": [
          "Not monitoring critical paths, missing issues.",
          "Over-alerting, causing noise."
        ],
        "exercises": [
          {
            "title": "Set Up Monitoring and Alerts",
            "prompt": "Configure Prometheus and Grafana for a microservice.",
            "difficulty": "medium",
            "hints": [
              "Define scrape_configs",
              "Create Grafana dashboard"
            ],
            "solution": "prometheus.yml: scrape_configs:\n- job_name: 'my-app'\n  static_configs:\n  - targets: ['my-app:8080']\nservice.ts: const express = require('express'); const prom = require('prom-client'); const counter = new prom.Counter({ name: 'requests_total', help: 'Total requests' }); const app = express(); app.get('/', (req, res) => { counter.inc(); res.send('OK'); }); app.listen(8080);"
          }
        ],
        "quiz": [
          {
            "question": "What does Prometheus monitor?",
            "options": [
              "UI components",
              "Metrics",
              "Database queries",
              "CSS styles"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What visualizes metrics?",
            "options": [
              "Redis",
              "Grafana",
              "MongoDB",
              "Vite"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 50,
        "resources": [
          {
            "title": "Prometheus Documentation",
            "url": "https://prometheus.io/docs/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fe1",
        "lessonId": "68cf5c5036b0c3df3e9f9fdb"
      },
      {
        "level": "Intermediate",
        "explanation": "Deploying a SaaS app to the cloud with CI/CD ensures automated, reliable releases. This lesson guides you through deploying a multi-service app to AWS or GCP using Kubernetes, setting up a CI/CD pipeline with GitHub Actions, and delivering a design document.",
        "examples": [
          "CI/CD: GitHub Actions workflow for deploying to EKS.",
          "Design Doc: Outline architecture and trade-offs."
        ],
        "realWorldApplication": "Cloud deployment with CI/CD is used by Dropbox and Zoom for scalable SaaS apps.",
        "expertInsights": "Use GitOps for deployments. Document trade-offs in design docs.",
        "commonMistakes": [
          "Not testing deployments, causing failures.",
          "Omitting rollback plans, risking downtime."
        ],
        "exercises": [
          {
            "title": "Deploy SaaS App with CI/CD",
            "prompt": "Deploy a SaaS app to Kubernetes with a CI/CD pipeline and write a design doc.",
            "difficulty": "hard",
            "hints": [
              "Use GitHub Actions",
              "Include monitoring setup"
            ],
            "solution": "workflow.yml: name: Deploy SaaS\non: [push]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - name: Deploy to EKS\n        run: kubectl apply -f deployment.yaml\ndeployment.yaml: apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: saas-app\nspec:\n  replicas: 2\n  selector:\n    matchLabels:\n      app: saas-app\n  template:\n    metadata:\n      labels:\n        app: saas-app\n    spec:\n      containers:\n      - name: saas-app\n        image: saas-app:latest\ndesign.md: # SaaS Design Doc\n- Architecture: Multi-tenant, microservices\n- Components: API Gateway, User Service, Collaboration Service\n- Trade-offs: WebSocket vs. polling (WebSocket for low latency)"
          }
        ],
        "quiz": [
          {
            "question": "What automates SaaS deployments?",
            "options": [
              "Static files",
              "CI/CD pipelines",
              "UI components",
              "CSS"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What does a design doc outline?",
            "options": [
              "UI layouts",
              "Architecture",
              "Database queries",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 60,
        "resources": [
          {
            "title": "Kubernetes on AWS EKS",
            "url": "https://aws.amazon.com/eks/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68cf5c5036b0c3df3e9f9fe2",
        "lessonId": "68cf5c5036b0c3df3e9f9fdc"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  }
]