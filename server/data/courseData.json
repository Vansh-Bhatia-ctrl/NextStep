[
  {
    "learningModuleId": "507f1f77bcf86cd799439020",
    "title": "Basics of the Web",
    "slug": "basics-of-the-web",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439021",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Explore the core concepts of how the web works, including protocols, servers, and browsers.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439022",
            "title": "Understanding the Web",
            "slug": "understanding-the-web",
            "shortDescription": "A beginner-friendly course to learn the fundamentals of how the web operates.",
            "longDescription": "This course covers the essential concepts of the web, including HTTP/HTTPS, servers, clients, and browsers, designed for those new to web technology.",
            "tags": ["Web", "HTTP", "HTTPS", "Servers", "Browsers", "Beginner"],
            "thumbnail": "https://example.com/thumbnails/web-basics.jpg",
            "levels": [
              {
                "level": "Beginner",
                "overview": "This level introduces the foundational concepts of how the internet and web function, including communication protocols and server-client interactions.",
                "goals": [
                  "Understand the basics of HTTP and HTTPS",
                  "Learn what servers and clients are",
                  "Explore how browsers interact with the web",
                  "Grasp the role of URLs and DNS"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439023",
                    "title": "Introduction to the Web",
                    "slug": "introduction-to-the-web",
                    "description": "Learn the basic components and structure of the web.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439024",
                        "title": "What is the Web?",
                        "slug": "what-is-the-web",
                        "description": "Understand the internet, the web, and their basic components.",
                        "order": 1,
                        "content": {
                          "explanation": "The World Wide Web is a system of interlinked resources accessed via the internet. It uses browsers, servers, and protocols to deliver content like webpages.",
                          "examples": [
                            "When you visit 'example.com', your browser sends a request to a server, which responds with the webpage data."
                          ],
                          "realWorldApplication": "The web enables online shopping, social media, and information sharing globally.",
                          "expertInsights": "The web relies on a client-server model, where browsers (clients) request data from servers.",
                          "commonMistakes": [
                            "Confusing the internet with the web (the web is a service on the internet)",
                            "Assuming all websites are secure by default"
                          ],
                          "exercises": [
                            {
                              "title": "Describe a Web Interaction",
                              "prompt": "Write a short description of how a browser retrieves a webpage when you enter a URL.",
                              "difficulty": "easy",
                              "hints": [
                                "Mention the browser, server, and request",
                                "Include the role of a URL"
                              ],
                              "solution": "When you enter a URL like 'example.com' in a browser, the browser sends a request to a server. The server processes the request and sends back the webpage data, which the browser displays."
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is the World Wide Web?",
                              "options": [
                                "A programming language",
                                "A system of interlinked resources on the internet",
                                "A type of server",
                                "A browser"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 15,
                          "resources": [
                            {
                              "title": "MDN How the Web Works",
                              "url": "https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/How_the_Web_works",
                              "type": "article"
                            },
                            {
                              "title": "Web Basics Video",
                              "url": "https://www.youtube.com/watch?v=example-web-basics",
                              "type": "video"
                            }
                          ]
                        }
                      }
                    ]
                  },
                  {
                    "moduleId": "507f1f77bcf86cd799439025",
                    "title": "HTTP and HTTPS",
                    "slug": "http-and-https",
                    "description": "Learn about HTTP, HTTPS, and how they enable web communication.",
                    "order": 2,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439026",
                        "title": "Understanding HTTP and HTTPS",
                        "slug": "understanding-http-https",
                        "description": "Explore the protocols that power web communication.",
                        "order": 1,
                        "content": {
                          "explanation": "HTTP (HyperText Transfer Protocol) is the protocol for transferring data over the web. HTTPS is its secure version, using encryption to protect data.",
                          "examples": [
                            "A URL starting with 'http://' uses HTTP, while 'https://' uses HTTPS for secure communication."
                          ],
                          "realWorldApplication": "HTTPS is critical for secure transactions, like online banking or shopping.",
                          "expertInsights": "Always use HTTPS for websites handling sensitive data to ensure security.",
                          "commonMistakes": [
                            "Assuming HTTP is secure",
                            "Ignoring browser warnings about insecure (HTTP) sites"
                          ],
                          "exercises": [
                            {
                              "title": "Identify Secure URLs",
                              "prompt": "Given a list of URLs, identify which ones use HTTPS.",
                              "difficulty": "easy",
                              "hints": [
                                "Look for 'https://' at the start of the URL",
                                "HTTP URLs are not secure"
                              ],
                              "solution": "URLs like 'https://example.com' use HTTPS, while 'http://example.com' uses HTTP."
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does HTTPS add to HTTP?",
                              "options": [
                                "Faster speed",
                                "Encryption for security",
                                "More colors",
                                "Additional file types"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN HTTP Overview",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  },
                  {
                    "moduleId": "507f1f77bcf86cd799439027",
                    "title": "Servers, Clients, and DNS",
                    "slug": "servers-clients-dns",
                    "description": "Understand the roles of servers, clients, and DNS in web interactions.",
                    "order": 3,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439028",
                        "title": "Servers, Clients, and DNS Basics",
                        "slug": "servers-clients-dns-basics",
                        "description": "Learn how servers, clients, and DNS work together to deliver webpages.",
                        "order": 1,
                        "content": {
                          "explanation": "Servers store and send webpage data, clients (like browsers) request it, and DNS (Domain Name System) translates domain names (e.g., example.com) into IP addresses.",
                          "examples": [
                            "When you type 'example.com', DNS finds the server's IP address, and your browser (client) requests data from that server."
                          ],
                          "realWorldApplication": "Servers host websites, clients access them, and DNS ensures you reach the right server.",
                          "expertInsights": "DNS is like the internet's phonebook, mapping names to addresses.",
                          "commonMistakes": [
                            "Confusing servers with physical computers (servers can be software)",
                            "Assuming DNS is instantaneous (it can take time)"
                          ],
                          "exercises": [
                            {
                              "title": "Explain DNS Role",
                              "prompt": "Write a short explanation of how DNS helps you access a website.",
                              "difficulty": "medium",
                              "hints": [
                                "Mention domain names and IP addresses",
                                "Describe DNS as a translator"
                              ],
                              "solution": "DNS translates a domain name like 'example.com' into an IP address, allowing your browser to find and connect to the correct server."
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does DNS do?",
                              "options": [
                                "Stores webpages",
                                "Translates domain names to IP addresses",
                                "Styles webpages",
                                "Encrypts data"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 25,
                          "resources": [
                            {
                              "title": "MDN How DNS Works",
                              "url": "https://developer.mozilla.org/en-US/docs/Glossary/DNS",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-12T00:29:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439030",
    "title": "HTML Essentials",
    "slug": "html-essentials",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439031",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master the core skills for structuring content on the web with HTML.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439032",
            "title": "HTML Fundamentals",
            "slug": "html-fundamentals",
            "shortDescription": "A beginner-friendly course to learn the basics of HTML for building webpages.",
            "longDescription": "This course introduces HTML, the foundation of web development, teaching you how to create structured, accessible, and semantic webpages from scratch.",
            "tags": ["HTML", "Web Development", "Beginner", "Frontend"],
            "thumbnail": "https://example.com/thumbnails/html-fundamentals.jpg",
            "levels": [
              {
                "level": "Beginner",
                "overview": "This level covers the essentials of HTML, including tags, attributes, and semantic markup, to create well-structured webpages.",
                "goals": [
                  "Understand the purpose and structure of HTML",
                  "Learn to use common HTML tags and attributes",
                  "Create a simple, semantic webpage",
                  "Apply best practices for accessibility"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439033",
                    "title": "Getting Started with HTML",
                    "slug": "getting-started-with-html",
                    "description": "Learn the basics of HTML to structure content on the web.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439034",
                        "title": "Introduction to HTML",
                        "slug": "introduction-to-html",
                        "description": "Understand what HTML is and how to create a basic webpage.",
                        "order": 1,
                        "content": {
                          "explanation": "HTML (HyperText Markup Language) is the standard language for creating webpages. It uses tags to structure content, such as headings, paragraphs, and links.",
                          "examples": [
                            "<!DOCTYPE html>\n<html>\n<head>\n  <title>My First Webpage</title>\n</head>\n<body>\n  <h1>Hello, World!</h1>\n  <p>This is my first webpage.</p>\n</body>\n</html>"
                          ],
                          "realWorldApplication": "HTML is used to build the structure of websites like news sites, blogs, and online stores.",
                          "expertInsights": "Always include the <!DOCTYPE html> declaration to ensure browsers render your page correctly.",
                          "commonMistakes": [
                            "Forgetting to close tags, e.g., <p> without </p>",
                            "Nesting tags incorrectly, e.g., <p><h1>Text</p></h1>"
                          ],
                          "exercises": [
                            {
                              "title": "Create a Basic HTML Page",
                              "prompt": "Write HTML code to create a webpage with a heading, paragraph, and a link.",
                              "difficulty": "easy",
                              "hints": [
                                "Start with <!DOCTYPE html>",
                                "Use <h1> for the heading",
                                "Use <a href='url'> for the link"
                              ],
                              "solution": "<!DOCTYPE html>\n<html>\n<head>\n  <title>My Page</title>\n</head>\n<body>\n  <h1>Welcome</h1>\n  <p>This is a paragraph.</p>\n  <a href='https://example.com'>Visit Example</a>\n</body>\n</html>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does HTML stand for?",
                              "options": [
                                "HyperText Markup Language",
                                "HighText Machine Language",
                                "HyperTool Multi Language",
                                "HomeText Markup Language"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 15,
                          "resources": [
                            {
                              "title": "MDN HTML Basics",
                              "url": "https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/HTML_basics",
                              "type": "article"
                            },
                            {
                              "title": "HTML Introduction Video",
                              "url": "https://www.youtube.com/watch?v=example-html-video",
                              "type": "video"
                            }
                          ]
                        }
                      }
                    ]
                  },
                  {
                    "moduleId": "507f1f77bcf86cd799439035",
                    "title": "HTML Tags and Attributes",
                    "slug": "html-tags-and-attributes",
                    "description": "Learn how to use HTML tags and attributes to add structure and functionality.",
                    "order": 2,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439036",
                        "title": "Working with Tags and Attributes",
                        "slug": "working-with-tags-and-attributes",
                        "description": "Explore common HTML tags and how attributes enhance them.",
                        "order": 1,
                        "content": {
                          "explanation": "HTML tags define elements like headings (<h1>), images (<img>), and lists (<ul>). Attributes provide additional information, such as 'src' for images or 'href' for links.",
                          "examples": [
                            "<img src='image.jpg' alt='Description'>\n<a href='https://example.com' title='Visit Example'>Link</a>\n<ul>\n  <li>Item 1</li>\n  <li>Item 2</li>\n</ul>"
                          ],
                          "realWorldApplication": "Tags and attributes are used to create navigation menus, image galleries, and forms on websites.",
                          "expertInsights": "Use the 'alt' attribute for images to improve accessibility for screen readers.",
                          "commonMistakes": [
                            "Omitting required attributes, e.g., 'alt' for <img>",
                            "Using incorrect attribute values, e.g., invalid URLs in 'href'"
                          ],
                          "exercises": [
                            {
                              "title": "Add an Image with Attributes",
                              "prompt": "Write HTML code to display an image with a source URL and an alt description.",
                              "difficulty": "easy",
                              "hints": [
                                "Use the <img> tag",
                                "Include 'src' and 'alt' attributes"
                              ],
                              "solution": "<img src='https://example.com/image.jpg' alt='Sample Image'>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "Which attribute specifies the URL for a link?",
                              "options": ["src", "href", "alt", "title"],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN HTML Elements Reference",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  },
                  {
                    "moduleId": "507f1f77bcf86cd799439037",
                    "title": "Semantic HTML",
                    "slug": "semantic-html",
                    "description": "Learn how to use semantic HTML for better structure and accessibility.",
                    "order": 3,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439038",
                        "title": "Using Semantic HTML",
                        "slug": "using-semantic-html",
                        "description": "Understand semantic tags and their importance for accessibility and SEO.",
                        "order": 1,
                        "content": {
                          "explanation": "Semantic HTML uses tags like <header>, <nav>, <article>, and <footer> to give meaning to content, improving accessibility and search engine optimization.",
                          "examples": [
                            "<header>\n  <h1>My Website</h1>\n</header>\n<nav>\n  <a href='/home'>Home</a>\n</nav>\n<article>\n  <h2>Article Title</h2>\n  <p>Content here.</p>\n</article>\n<footer>\n  <p>© 2025</p>\n</footer>"
                          ],
                          "realWorldApplication": "Semantic HTML is used in professional websites to ensure accessibility and improve search engine rankings.",
                          "expertInsights": "Semantic tags help screen readers understand the structure, making your site more inclusive.",
                          "commonMistakes": [
                            "Using <div> instead of semantic tags like <section> or <article>",
                            "Overusing generic tags, reducing accessibility"
                          ],
                          "exercises": [
                            {
                              "title": "Create a Semantic Webpage",
                              "prompt": "Write HTML code for a webpage with a header, navigation menu, article, and footer using semantic tags.",
                              "difficulty": "medium",
                              "hints": [
                                "Use <header>, <nav>, <article>, and <footer>",
                                "Include at least one link in the navigation"
                              ],
                              "solution": "<!DOCTYPE html>\n<html>\n<head>\n  <title>Semantic Page</title>\n</head>\n<body>\n  <header>\n    <h1>My Site</h1>\n  </header>\n  <nav>\n    <a href='/home'>Home</a>\n    <a href='/about'>About</a>\n  </nav>\n  <article>\n    <h2>Article</h2>\n    <p>This is an article.</p>\n  </article>\n  <footer>\n    <p>© 2025</p>\n  </footer>\n</body>\n</html>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "Which tag is used for the main navigation of a webpage?",
                              "options": [
                                "<header>",
                                "<nav>",
                                "<article>",
                                "<div>"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 25,
                          "resources": [
                            {
                              "title": "MDN Semantic HTML",
                              "url": "https://developer.mozilla.org/en-US/docs/Glossary/Semantics#semantic_html",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-12T00:34:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439040",
    "title": "CSS Fundamentals",
    "slug": "css-fundamentals",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439041",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master the core skills for styling webpages with CSS.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439042",
            "title": "CSS Essentials",
            "slug": "css-essentials",
            "shortDescription": "A beginner-friendly course to learn the basics of CSS for styling webpages.",
            "longDescription": "This course introduces CSS, teaching you how to style webpages using selectors, the box model, typography, and colors, perfect for beginners in web development.",
            "tags": ["CSS", "Web Development", "Beginner", "Frontend"],
            "thumbnail": "https://example.com/thumbnails/css-essentials.jpg",
            "levels": [
              {
                "level": "Beginner",
                "overview": "This level covers the essentials of CSS, including selectors, the box model, typography, and colors, to create visually appealing webpages.",
                "goals": [
                  "Understand how to apply CSS to HTML",
                  "Learn to use selectors and understand specificity",
                  "Master the box model and layout properties",
                  "Apply typography and color styles effectively"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439043",
                    "title": "CSS Fundamentals",
                    "slug": "css-fundamentals",
                    "description": "Learn the core concepts of CSS to style webpages effectively.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439044",
                        "title": "CSS Basics & Inclusion Methods",
                        "slug": "css-basics-inclusion",
                        "description": "Understand what CSS is and how to include it in your HTML.",
                        "order": 1,
                        "content": {
                          "explanation": "CSS (Cascading Style Sheets) is used to style HTML elements, controlling their appearance. It can be included inline (within HTML tags), internally (in a <style> tag), or externally (via a separate .css file).",
                          "examples": [
                            "Inline: <p style='color: blue;'>Text</p>\nInternal: <style>\np { color: blue; }\n</style>\nExternal: <link rel='stylesheet' href='styles.css'>"
                          ],
                          "realWorldApplication": "CSS is used to style websites, such as creating consistent designs for buttons or layouts across pages.",
                          "expertInsights": "Use external CSS files for better organization and scalability in larger projects.",
                          "commonMistakes": [
                            "Using inline CSS excessively, making maintenance difficult",
                            "Incorrectly linking external CSS files (wrong file path)"
                          ],
                          "exercises": [
                            {
                              "title": "Apply CSS to HTML",
                              "prompt": "Write HTML with an external CSS file link to style a heading with red text.",
                              "difficulty": "easy",
                              "hints": [
                                "Use the <link> tag in the <head>",
                                "Create a simple CSS rule for the heading"
                              ],
                              "solution": "HTML: <!DOCTYPE html>\n<html>\n<head>\n  <link rel='stylesheet' href='styles.css'>\n</head>\n<body>\n  <h1>My Heading</h1>\n</body>\n</html>\nCSS (styles.css): h1 { color: red; }"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "Which method uses a separate .css file?",
                              "options": [
                                "Inline CSS",
                                "Internal CSS",
                                "External CSS",
                                "Embedded CSS"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "Where is internal CSS placed in HTML?",
                              "options": [
                                "In a <script> tag",
                                "In a <style> tag",
                                "In a <link> tag",
                                "In a <div>"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What tag links an external CSS file?",
                              "options": [
                                "<style>",
                                "<script>",
                                "<link>",
                                "<css>"
                              ],
                              "correctOption": [2]
                            }
                          ],
                          "estimatedTime": 15,
                          "resources": [
                            {
                              "title": "MDN CSS Basics",
                              "url": "https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/CSS_basics",
                              "type": "article"
                            },
                            {
                              "title": "CSS Introduction Video",
                              "url": "https://www.youtube.com/watch?v=example-css-video",
                              "type": "video"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439045",
                        "title": "Selectors & Specificity",
                        "slug": "selectors-specificity",
                        "description": "Learn how to target HTML elements with selectors and understand specificity.",
                        "order": 2,
                        "content": {
                          "explanation": "CSS selectors target HTML elements (e.g., type, class, ID). Specificity determines which rule applies when multiple rules conflict, with ID selectors being more specific than class or type selectors.",
                          "examples": [
                            "Type: p { color: blue; }\nClass: .highlight { background: yellow; }\nID: #header { font-size: 24px; }\nCombinator: div p { margin: 10px; }"
                          ],
                          "realWorldApplication": "Selectors are used to style specific parts of a webpage, like highlighting active menu items or styling form inputs.",
                          "expertInsights": "Use class selectors for reusable styles and avoid overusing ID selectors due to high specificity.",
                          "commonMistakes": [
                            "Using overly specific selectors, making styles hard to override",
                            "Misspelling class or ID names in CSS"
                          ],
                          "exercises": [
                            {
                              "title": "Style a Profile Card",
                              "prompt": "Write CSS to style a div with class='profile-card' to have a blue border and centered text.",
                              "difficulty": "easy",
                              "hints": [
                                "Use the class selector '.profile-card'",
                                "Apply 'border' and 'text-align' properties"
                              ],
                              "solution": ".profile-card { border: 1px solid blue; text-align: center; }"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "Which selector has the highest specificity?",
                              "options": [
                                "Type selector",
                                "Class selector",
                                "ID selector",
                                "Universal selector"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "How do you select an element with class='box'?",
                              "options": [".box", "#box", "box", "*box"],
                              "correctOption": [0]
                            },
                            {
                              "question": "What does the '>' combinator select?",
                              "options": [
                                "All descendants",
                                "Direct children",
                                "Siblings",
                                "Parent elements"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Which rule applies if two selectors target the same element?",
                              "options": [
                                "The first rule",
                                "The last rule",
                                "The most specific rule",
                                "None apply"
                              ],
                              "correctOption": [2]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN CSS Selectors",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439046",
                        "title": "Box Model & Display",
                        "slug": "box-model-display",
                        "description": "Understand the CSS box model and display properties for layout.",
                        "order": 3,
                        "content": {
                          "explanation": "The CSS box model defines an element's content, padding, border, and margin. The 'display' property controls layout, with 'block' (full-width) and 'inline' (in-line) being common values. 'box-sizing: border-box' includes padding and border in the element's width.",
                          "examples": [
                            ".box { width: 200px; padding: 10px; border: 1px solid black; margin: 20px; box-sizing: border-box; }\ndiv { display: block; }\nspan { display: inline; }"
                          ],
                          "realWorldApplication": "The box model is used to create layouts, like spacing buttons or aligning content in a grid.",
                          "expertInsights": "Use 'box-sizing: border-box' to make sizing calculations easier and more predictable.",
                          "commonMistakes": [
                            "Forgetting margins collapse vertically",
                            "Not accounting for padding/border in width calculations"
                          ],
                          "exercises": [
                            {
                              "title": "Fix Spacing with Box Model",
                              "prompt": "Write CSS for a div with class='card' to have a 200px width, 10px padding, 2px border, and 15px margin, using border-box sizing.",
                              "difficulty": "medium",
                              "hints": [
                                "Set 'box-sizing: border-box'",
                                "Include padding, border, and margin properties"
                              ],
                              "solution": ".card { width: 200px; padding: 10px; border: 2px solid black; margin: 15px; box-sizing: border-box; }"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does 'box-sizing: border-box' do?",
                              "options": [
                                "Excludes padding from width",
                                "Includes padding and border in width",
                                "Removes margins",
                                "Changes display type"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Which property makes an element take the full width of its container?",
                              "options": [
                                "display: inline",
                                "display: block",
                                "width: 100%",
                                "Both b and c"
                              ],
                              "correctOption": [3]
                            },
                            {
                              "question": "What is part of the CSS box model?",
                              "options": [
                                "Content",
                                "Padding",
                                "Border",
                                "All of the above"
                              ],
                              "correctOption": [3]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN CSS Box Model",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Introduction_to_the_CSS_box_model",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439047",
                        "title": "Typography & Colors",
                        "slug": "typography-colors",
                        "description": "Learn how to style text and colors in CSS.",
                        "order": 4,
                        "content": {
                          "explanation": "CSS typography controls fonts, sizes, and styles using properties like 'font-family', 'font-size', and 'font-weight'. Colors can be set using hex, RGB, or RGBA for transparency.",
                          "examples": [
                            "p { font-family: Arial, sans-serif; font-size: 16px; color: #333333; }\n.button { background-color: rgb(0, 128, 255); color: rgba(255, 255, 255, 0.8); }"
                          ],
                          "realWorldApplication": "Typography and colors are used to create readable text and visually appealing designs, like branding for websites.",
                          "expertInsights": "Use web-safe fonts or fallback fonts to ensure consistent rendering across devices.",
                          "commonMistakes": [
                            "Using non-web-safe fonts without fallbacks",
                            "Specifying invalid color values, e.g., incorrect hex codes"
                          ],
                          "exercises": [
                            {
                              "title": "Style a Profile Card Text",
                              "prompt": "Write CSS to style a paragraph with class='profile-text' using Arial font, 14px size, and a dark gray color (#444444).",
                              "difficulty": "easy",
                              "hints": [
                                "Use 'font-family', 'font-size', and 'color'",
                                "Include a fallback font like 'sans-serif'"
                              ],
                              "solution": ".profile-text { font-family: Arial, sans-serif; font-size: 14px; color: #444444; }"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "Which property sets the font type?",
                              "options": [
                                "font-size",
                                "font-family",
                                "color",
                                "font-weight"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does RGBA include that RGB does not?",
                              "options": [
                                "Brightness",
                                "Transparency",
                                "Saturation",
                                "Hue"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Which is a web-safe font?",
                              "options": [
                                "Comic Sans",
                                "Arial",
                                "CustomFont",
                                "None"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "How is a hex color written?",
                              "options": [
                                "rgb(255, 0, 0)",
                                "#FF0000",
                                "red",
                                "Both b and c"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 25,
                          "resources": [
                            {
                              "title": "MDN CSS Typography",
                              "url": "https://developer.mozilla.org/en-US/docs/Learn/CSS/Styling_text/Fundamentals",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-12T00:53:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439050",
    "title": "CSS Styling & Visual Design",
    "slug": "css-styling-visual-design",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439051",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Learn advanced CSS techniques for visual design and interactivity.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439052",
            "title": "CSS Visual Design Essentials",
            "slug": "css-visual-design-essentials",
            "shortDescription": "A beginner-friendly course to enhance webpages with CSS visual styling and interactivity.",
            "longDescription": "This course dives into CSS visual properties, pseudo-classes, transitions, animations, and responsive typography to create engaging and accessible webpages.",
            "tags": [
              "CSS",
              "Visual Design",
              "Beginner",
              "Frontend",
              "Accessibility"
            ],
            "thumbnail": "https://example.com/thumbnails/css-visual-design.jpg",
            "levels": [
              {
                "level": "Beginner",
                "overview": "This level covers CSS techniques for visual styling, interactivity, and accessibility, including colors, pseudo-classes, animations, and responsive typography.",
                "goals": [
                  "Master CSS visual properties like colors, gradients, and borders",
                  "Use pseudo-classes and pseudo-elements for interactive effects",
                  "Create basic transitions and animations",
                  "Apply responsive typography and accessibility-focused styling"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439053",
                    "title": "CSS Styling & Visual Design",
                    "slug": "css-styling-visual-design",
                    "description": "Learn to enhance webpages with visual CSS properties and interactivity.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439054",
                        "title": "Colors, Gradients, Backgrounds, and Borders",
                        "slug": "colors-gradients-backgrounds-borders",
                        "description": "Learn to style webpages with colors, gradients, backgrounds, and borders.",
                        "order": 1,
                        "content": {
                          "explanation": "CSS allows you to style elements with colors (hex, RGB, RGBA), gradients (linear or radial), background properties (images, colors), and borders (style, width, color). These properties enhance visual appeal.",
                          "examples": [
                            "p { color: #333333; background: linear-gradient(to right, #ff0000, #0000ff); border: 2px solid #000; }\n.button { background-image: url('bg.jpg'); border-radius: 5px; }"
                          ],
                          "realWorldApplication": "Used to create visually appealing buttons, hero sections, and card designs on websites.",
                          "expertInsights": "Use RGBA for transparency and gradients for modern, dynamic backgrounds.",
                          "commonMistakes": [
                            "Using invalid color values, e.g., incorrect hex codes",
                            "Overusing heavy background images, slowing page load"
                          ],
                          "exercises": [
                            {
                              "title": "Style a Card with Gradient",
                              "prompt": "Write CSS for a div with class='card' to have a linear gradient from blue to green and a 1px black border.",
                              "difficulty": "easy",
                              "hints": [
                                "Use 'background: linear-gradient(...)'",
                                "Set 'border' property"
                              ],
                              "solution": ".card { background: linear-gradient(to right, blue, green); border: 1px solid black; }"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "Which property sets a gradient background?",
                              "options": [
                                "color",
                                "background",
                                "border",
                                "gradient"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "How do you specify transparency in a color?",
                              "options": ["RGB", "Hex", "RGBA", "HSL"],
                              "correctOption": [2]
                            },
                            {
                              "question": "Which property rounds border corners?",
                              "options": [
                                "border-style",
                                "border-radius",
                                "border-width",
                                "border-color"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 15,
                          "resources": [
                            {
                              "title": "MDN CSS Backgrounds",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/background",
                              "type": "article"
                            },
                            {
                              "title": "CSS Gradients Video",
                              "url": "https://www.youtube.com/watch?v=example-gradients-video",
                              "type": "video"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439055",
                        "title": "Pseudo-Classes & Pseudo-Elements",
                        "slug": "pseudo-classes-elements",
                        "description": "Learn to use pseudo-classes and pseudo-elements for interactive styling.",
                        "order": 2,
                        "content": {
                          "explanation": "Pseudo-classes (:hover, :focus) style elements based on user interaction or state. Pseudo-elements (::before, ::after) style specific parts of an element, like adding content or decorations.",
                          "examples": [
                            "a:hover { color: red; }\nbutton:focus { outline: 2px solid blue; }\np::before { content: '★'; }"
                          ],
                          "realWorldApplication": "Used for interactive effects like button hover states or adding icons before text.",
                          "expertInsights": "Ensure :focus states are visible for accessibility, especially for keyboard navigation.",
                          "commonMistakes": [
                            "Forgetting to define :focus for accessibility",
                            "Using single colons (::) for pseudo-classes or vice versa"
                          ],
                          "exercises": [
                            {
                              "title": "Add Hover Effect to Button",
                              "prompt": "Write CSS for a button with class='btn' to change its background to blue on hover.",
                              "difficulty": "easy",
                              "hints": [
                                "Use the :hover pseudo-class",
                                "Change the 'background-color' property"
                              ],
                              "solution": ".btn:hover { background-color: blue; }"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "Which pseudo-class is triggered on mouse over?",
                              "options": [
                                ":focus",
                                ":hover",
                                ":active",
                                ":visited"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does ::before do?",
                              "options": [
                                "Styles the element",
                                "Adds content before the element",
                                "Changes the element's state",
                                "Removes content"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Why is :focus important?",
                              "options": [
                                "For animations",
                                "For accessibility",
                                "For colors",
                                "For gradients"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Which uses double colons?",
                              "options": [
                                ":hover",
                                ":focus",
                                "::before",
                                ":active"
                              ],
                              "correctOption": [2]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN Pseudo-Classes",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439056",
                        "title": "Transitions & Simple Animations",
                        "slug": "transitions-animations",
                        "description": "Learn to create smooth transitions and basic animations.",
                        "order": 3,
                        "content": {
                          "explanation": "CSS transitions create smooth changes for properties like color or size. The 'transform' property adjusts position, scale, or rotation. Keyframes (@keyframes) define custom animations for more complex effects.",
                          "examples": [
                            ".btn { transition: background-color 0.3s; }\n.btn:hover { background-color: blue; }\n.box { transform: scale(1.2); }\n@keyframes slide { 0% { transform: translateX(0); } 100% { transform: translateX(100px); } }\n.animated { animation: slide 2s infinite; }"
                          ],
                          "realWorldApplication": "Used for button hover effects, fading images, or sliding menus in websites.",
                          "expertInsights": "Keep transitions short (0.2–0.5s) for a snappy user experience.",
                          "commonMistakes": [
                            "Not specifying 'transition-property' or duration",
                            "Overusing animations, causing performance issues"
                          ],
                          "exercises": [
                            {
                              "title": "Create an Animated Button",
                              "prompt": "Write CSS for a button with class='btn' to scale up by 10% on hover with a 0.3s transition.",
                              "difficulty": "medium",
                              "hints": [
                                "Use 'transition' and 'transform: scale()'",
                                "Apply the effect on :hover"
                              ],
                              "solution": ".btn { transition: transform 0.3s; }\n.btn:hover { transform: scale(1.1); }"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "Which property defines a transition's duration?",
                              "options": [
                                "transform",
                                "transition-duration",
                                "animation",
                                "transition-property"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does 'transform: scale(2)' do?",
                              "options": [
                                "Moves the element",
                                "Doubles the size",
                                "Rotates the element",
                                "Fades the element"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What defines a custom animation?",
                              "options": [
                                "transition",
                                "@keyframes",
                                "transform",
                                "animation-duration"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN CSS Transitions",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Transitions/Using_CSS_transitions",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439057",
                        "title": "Responsive Typography & Accessibility",
                        "slug": "responsive-typography-accessibility",
                        "description": "Learn to style text responsively and ensure accessibility.",
                        "order": 4,
                        "content": {
                          "explanation": "Responsive typography uses relative units like 'rem' or 'vw' to adapt to screen sizes. Accessibility styling ensures focus states are visible and text is readable (e.g., sufficient contrast).",
                          "examples": [
                            "body { font-size: 16px; }\nh1 { font-size: 2rem; }\nbutton:focus { outline: 2px solid blue; }\n@media (max-width: 600px) { h1 { font-size: 1.5rem; } }"
                          ],
                          "realWorldApplication": "Used to make text readable on all devices and ensure websites are usable for keyboard navigation.",
                          "expertInsights": "Use a contrast ratio of at least 4.5:1 for text to meet accessibility standards.",
                          "commonMistakes": [
                            "Using fixed units like 'px' for responsive typography",
                            "Omitting focus styles, reducing accessibility"
                          ],
                          "exercises": [
                            {
                              "title": "Add Hover and Focus to Module 1 Page",
                              "prompt": "Write CSS for a button with class='btn' on a Module 1 page to change background to green on hover and add a blue outline on focus.",
                              "difficulty": "medium",
                              "hints": [
                                "Use :hover and :focus pseudo-classes",
                                "Apply 'background-color' and 'outline'"
                              ],
                              "solution": ".btn:hover { background-color: green; }\n.btn:focus { outline: 2px solid blue; }"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "Which unit is relative to the root font size?",
                              "options": ["px", "rem", "%", "vw"],
                              "correctOption": [1]
                            },
                            {
                              "question": "Why are focus styles important?",
                              "options": [
                                "For animations",
                                "For keyboard accessibility",
                                "For colors",
                                "For gradients"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What adjusts styles based on screen size?",
                              "options": [
                                "transition",
                                "@keyframes",
                                "@media",
                                "transform"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "What ensures readable text?",
                              "options": [
                                "High contrast ratio",
                                "Low font size",
                                "Fixed units",
                                "No outlines"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 25,
                          "resources": [
                            {
                              "title": "MDN Responsive Typography",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Text",
                              "type": "article"
                            },
                            {
                              "title": "Web Accessibility Basics",
                              "url": "https://www.w3.org/WAI/fundamentals/accessibility-intro/",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-13T22:33:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439060",
    "title": "CSS Layout & Responsive Design",
    "slug": "css-layout-responsive",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439061",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Learn to create flexible and responsive layouts using CSS.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439062",
            "title": "CSS Layout Essentials",
            "slug": "css-layout-essentials",
            "shortDescription": "A beginner-friendly course to master CSS layouts and responsive design.",
            "longDescription": "This course covers CSS layout techniques including normal flow, positioning, Flexbox, Grid, and media queries to build responsive webpages for all devices.",
            "tags": ["CSS", "Flexbox", "Grid", "Responsive Design", "Beginner"],
            "thumbnail": "https://example.com/thumbnails/css-layout.jpg",
            "levels": [
              {
                "level": "Beginner",
                "overview": "This level teaches CSS layout fundamentals, Flexbox, Grid, and media queries to create responsive webpages adaptable to various screen sizes.",
                "goals": [
                  "Understand CSS layout fundamentals and positioning",
                  "Master Flexbox for flexible layouts",
                  "Learn CSS Grid for complex layouts",
                  "Apply media queries for mobile-first responsive design"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439063",
                    "title": "CSS Layout & Responsive",
                    "slug": "css-layout-responsive",
                    "description": "Learn to build responsive layouts using modern CSS techniques.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439064",
                        "title": "Layout Fundamentals",
                        "slug": "layout-fundamentals",
                        "description": "Understand normal flow and CSS positioning for layouts.",
                        "order": 1,
                        "content": {
                          "explanation": "CSS layouts are built on normal flow, where elements follow the document order. Positioning properties ('position: static, relative, absolute, fixed') control element placement.",
                          "examples": [
                            "div { position: relative; top: 10px; }\n.absolute-box { position: absolute; top: 20px; left: 20px; }\n.fixed-nav { position: fixed; top: 0; }"
                          ],
                          "realWorldApplication": "Used for creating page structures like sticky headers or positioned overlays.",
                          "expertInsights": "Use 'relative' for small adjustments and 'absolute' for elements outside the normal flow.",
                          "commonMistakes": [
                            "Misusing 'position: absolute' without a positioned parent",
                            "Not accounting for normal flow disruptions"
                          ],
                          "exercises": [
                            {
                              "title": "Position a Banner",
                              "prompt": "Write CSS to position a div with class='banner' 10px from the top using relative positioning.",
                              "difficulty": "easy",
                              "hints": [
                                "Use 'position: relative'",
                                "Set 'top' property"
                              ],
                              "solution": ".banner { position: relative; top: 10px; }"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is the default CSS position value?",
                              "options": [
                                "relative",
                                "absolute",
                                "fixed",
                                "static"
                              ],
                              "correctOption": [3]
                            },
                            {
                              "question": "Which positioning removes an element from normal flow?",
                              "options": [
                                "static",
                                "relative",
                                "absolute",
                                "inline"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "What does 'position: fixed' do?",
                              "options": [
                                "Moves with scroll",
                                "Stays relative to parent",
                                "Stays fixed to viewport",
                                "Follows normal flow"
                              ],
                              "correctOption": [2]
                            }
                          ],
                          "estimatedTime": 15,
                          "resources": [
                            {
                              "title": "MDN CSS Position",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/position",
                              "type": "article"
                            },
                            {
                              "title": "CSS Positioning Video",
                              "url": "https://www.youtube.com/watch?v=example-positioning-video",
                              "type": "video"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439065",
                        "title": "Flexbox",
                        "slug": "flexbox",
                        "description": "Learn to create flexible layouts using CSS Flexbox.",
                        "order": 2,
                        "content": {
                          "explanation": "Flexbox is a layout model for arranging elements in a container. Key properties include 'display: flex', 'flex-direction', 'justify-content', and 'align-items' for alignment and spacing.",
                          "examples": [
                            ".container { display: flex; flex-direction: row; justify-content: space-between; align-items: center; }\n.item { flex: 1; }"
                          ],
                          "realWorldApplication": "Used for navigation bars, card layouts, and centering content horizontally or vertically.",
                          "expertInsights": "Use 'flex: 1' for equal-width items and 'flex-wrap: wrap' for responsive layouts.",
                          "commonMistakes": [
                            "Forgetting to set 'display: flex' on the container",
                            "Misusing 'justify-content' vs 'align-items'"
                          ],
                          "exercises": [
                            {
                              "title": "Create a Flexbox Navigation",
                              "prompt": "Write CSS for a nav with class='nav' to display its items horizontally, spaced evenly.",
                              "difficulty": "easy",
                              "hints": [
                                "Use 'display: flex'",
                                "Set 'justify-content: space-between'"
                              ],
                              "solution": ".nav { display: flex; justify-content: space-between; }"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What property enables Flexbox?",
                              "options": [
                                "flex-direction",
                                "display: flex",
                                "justify-content",
                                "align-items"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Which property aligns items along the main axis?",
                              "options": [
                                "align-items",
                                "flex-direction",
                                "justify-content",
                                "flex-wrap"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "What does 'flex-direction: column' do?",
                              "options": [
                                "Aligns items horizontally",
                                "Aligns items vertically",
                                "Wraps items",
                                "Centers items"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What allows items to wrap in Flexbox?",
                              "options": [
                                "flex-wrap",
                                "justify-content",
                                "align-items",
                                "flex-direction"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN Flexbox",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439066",
                        "title": "Grid Basics",
                        "slug": "grid-basics",
                        "description": "Learn to create complex layouts using CSS Grid.",
                        "order": 3,
                        "content": {
                          "explanation": "CSS Grid creates two-dimensional layouts with rows and columns. Key properties include 'display: grid', 'grid-template-columns', 'grid-template-rows', and 'grid-template-areas' for named areas.",
                          "examples": [
                            ".grid { display: grid; grid-template-columns: 1fr 1fr; grid-template-rows: auto; }\n.grid-item { grid-area: header; }"
                          ],
                          "realWorldApplication": "Used for dashboard layouts, image galleries, and complex webpage structures.",
                          "expertInsights": "Use 'fr' units for flexible column/row sizing and named areas for intuitive layouts.",
                          "commonMistakes": [
                            "Forgetting to set 'display: grid' on the container",
                            "Misaligning items due to incorrect grid-area names"
                          ],
                          "exercises": [
                            {
                              "title": "Create a Two-Column Grid",
                              "prompt": "Write CSS for a div with class='grid' to create a two-column layout with equal widths.",
                              "difficulty": "medium",
                              "hints": [
                                "Use 'display: grid'",
                                "Set 'grid-template-columns: 1fr 1fr'"
                              ],
                              "solution": ".grid { display: grid; grid-template-columns: 1fr 1fr; }"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What property enables CSS Grid?",
                              "options": [
                                "grid-template",
                                "display: grid",
                                "grid-area",
                                "grid-columns"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does '1fr' represent in Grid?",
                              "options": [
                                "Fixed pixel size",
                                "Fraction of available space",
                                "Percentage",
                                "Auto size"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What defines named grid sections?",
                              "options": [
                                "grid-template-columns",
                                "grid-template-areas",
                                "grid-area",
                                "Both b and c"
                              ],
                              "correctOption": [3]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN CSS Grid",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439067",
                        "title": "Media Queries & Responsive Patterns",
                        "slug": "media-queries-responsive",
                        "description": "Learn to create mobile-first responsive designs with media queries.",
                        "order": 4,
                        "content": {
                          "explanation": "Media queries adjust styles based on screen size or device characteristics using '@media'. Mobile-first design starts with base styles and progressively adds changes for larger screens.",
                          "examples": [
                            "body { font-size: 16px; }\n@media (min-width: 768px) { body { font-size: 18px; } }\n.container { display: flex; flex-direction: column; }\n@media (min-width: 1024px) { .container { flex-direction: row; } }"
                          ],
                          "realWorldApplication": "Used to make websites adapt to phones, tablets, and desktops, like responsive navigation menus.",
                          "expertInsights": "Use 'min-width' for mobile-first designs to ensure a smooth scaling experience.",
                          "commonMistakes": [
                            "Overusing media queries for minor tweaks",
                            "Not testing responsive designs on actual devices"
                          ],
                          "exercises": [
                            {
                              "title": "Responsive Profile Page",
                              "prompt": "Convert a profile page to be responsive: use Flexbox column layout for mobile, row layout for desktop (min-width: 768px), and complete a responsive checklist.",
                              "difficulty": "medium",
                              "hints": [
                                "Start with 'flex-direction: column'",
                                "Use '@media (min-width: 768px)' for row layout",
                                "Checklist: check font sizes, spacing, and layout"
                              ],
                              "solution": "HTML: <div class='profile'> <img src='avatar.jpg' alt='Avatar'> <div class='info'> <h2>Name</h2> <p>Bio</p> </div> </div>\nCSS: .profile { display: flex; flex-direction: column; gap: 10px; } img { width: 100px; } @media (min-width: 768px) { .profile { flex-direction: row; align-items: center; } img { width: 150px; } }\nChecklist: 1. Font-size ≥ 16px, 2. Adequate spacing (gap: 10px), 3. Flexible layout, 4. Image scales appropriately."
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does '@media (min-width: 768px)' target?",
                              "options": [
                                "Screens smaller than 768px",
                                "Screens 768px or wider",
                                "All screens",
                                "Only 768px"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is a mobile-first approach?",
                              "options": [
                                "Start with desktop styles",
                                "Start with base styles for mobile",
                                "Use fixed units",
                                "Avoid media queries"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Which property is commonly adjusted in media queries?",
                              "options": [
                                "font-size",
                                "flex-direction",
                                "display",
                                "All of the above"
                              ],
                              "correctOption": [3]
                            },
                            {
                              "question": "Why use relative units in responsive design?",
                              "options": [
                                "Fixed sizes",
                                "Better scalability",
                                "Faster loading",
                                "Simpler code"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 25,
                          "resources": [
                            {
                              "title": "MDN Media Queries",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries",
                              "type": "article"
                            },
                            {
                              "title": "Responsive Design Video",
                              "url": "https://www.youtube.com/watch?v=example-responsive-video",
                              "type": "video"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-13T22:48:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439070",
    "title": "JavaScript Basics & Environment",
    "slug": "js-basics-environment",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439071",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Learn the foundational concepts of JavaScript and its runtime environment.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439072",
            "title": "JavaScript Essentials",
            "slug": "js-essentials",
            "shortDescription": "A beginner-friendly course to understand JavaScript basics and its browser environment.",
            "longDescription": "This course introduces JavaScript, the programming language of the web, covering its role, execution in browsers, primitive data types, variable declarations, and strict mode for cleaner code.",
            "tags": ["JavaScript", "Web Development", "Beginner", "Frontend"],
            "thumbnail": "https://example.com/thumbnails/js-essentials.jpg",
            "levels": [
              {
                "level": "Beginner",
                "overview": "This level covers the essentials of JavaScript, including its purpose, browser environment, console usage, data types, variables, and strict mode for writing robust code.",
                "goals": [
                  "Understand what JavaScript is and where it runs",
                  "Learn to use the browser console for debugging",
                  "Master JavaScript primitive types and variable declarations",
                  "Apply strict mode to avoid common errors"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439073",
                    "title": "JavaScript Basics & Environment",
                    "slug": "js-basics-environment",
                    "description": "Learn the core concepts of JavaScript and how it operates in the browser.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439074",
                        "title": "Introduction to JavaScript",
                        "slug": "introduction-to-javascript",
                        "description": "Understand what JavaScript is and its role in web development.",
                        "order": 1,
                        "content": {
                          "explanation": "JavaScript is a versatile, high-level programming language primarily used to add interactivity to webpages. It runs in the browser, enabling dynamic content updates, event handling, and user interactions. Unlike HTML (structure) and CSS (style), JavaScript adds behavior, such as form validation or animations. It is executed by the browser's JavaScript engine (e.g., V8 in Chrome), which interprets and runs the code. JavaScript can also run on servers (via Node.js), but this course focuses on its client-side use in browsers. As a beginner, you'll start by writing JavaScript to manipulate webpage elements and handle user actions, making websites more engaging and functional.",
                          "examples": [
                            "<script>\n  alert('Welcome to JavaScript!');\n</script>",
                            "<script>\n  document.getElementById('demo').innerHTML = 'Hello, World!';\n</script>"
                          ],
                          "realWorldApplication": "JavaScript powers interactive features like dropdown menus, form submissions, and live content updates on websites like social media platforms or e-commerce sites.",
                          "expertInsights": "Focus on understanding JavaScript's role in the browser first before exploring server-side or advanced frameworks to build a strong foundation.",
                          "commonMistakes": [
                            "Placing <script> tags in the wrong location, causing code to run before the DOM is loaded",
                            "Not understanding JavaScript's client-side nature, expecting server-side behavior"
                          ],
                          "exercises": [
                            {
                              "title": "Display a Welcome Message",
                              "prompt": "Write JavaScript to display an alert with the message 'Hello, JavaScript!'.",
                              "difficulty": "easy",
                              "hints": [
                                "Use the alert() function",
                                "Place the code inside a <script> tag"
                              ],
                              "solution": "<script>\n  alert('Hello, JavaScript!');\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is JavaScript primarily used for?",
                              "options": [
                                "Styling webpages",
                                "Adding interactivity",
                                "Structuring content",
                                "Managing servers"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Where does JavaScript typically run for web development?",
                              "options": [
                                "Server only",
                                "Browser",
                                "Database",
                                "Operating system"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Which engine runs JavaScript in Chrome?",
                              "options": [
                                "V8",
                                "SpiderMonkey",
                                "Chakra",
                                "JavaScriptCore"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 15,
                          "resources": [
                            {
                              "title": "MDN JavaScript Basics",
                              "url": "https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/JavaScript_basics",
                              "type": "article"
                            },
                            {
                              "title": "JavaScript Intro Video",
                              "url": "https://www.youtube.com/watch?v=example-js-video",
                              "type": "video"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439075",
                        "title": "Using the Browser Console",
                        "slug": "browser-console",
                        "description": "Learn to use the browser console for debugging and testing JavaScript.",
                        "order": 2,
                        "content": {
                          "explanation": "The browser console is a powerful tool in the browser's developer tools (accessible via F12 or right-click > Inspect) that allows you to run JavaScript, log outputs, and debug code. The console.log() function outputs messages or values to the console, helping you inspect variables or track code execution. Other console methods, like console.error() or console.warn(), provide ways to highlight issues or warnings. For beginners, the console is essential for experimenting with code, checking results, and identifying errors. For example, you can log a variable's value to see if it matches expectations or use the console to test small snippets before adding them to your script. Understanding the console is a critical skill for debugging and learning JavaScript effectively.",
                          "examples": [
                            "console.log('Hello, Console!');\nlet num = 42;\nconsole.log('The number is:', num);",
                            "console.error('Something went wrong!');\nconsole.warn('This is a warning.');"
                          ],
                          "realWorldApplication": "Developers use the console to debug issues, like checking why a button click doesn't work or verifying API data in web applications.",
                          "expertInsights": "Use descriptive console messages and group related logs with console.group() for better debugging clarity in complex projects.",
                          "commonMistakes": [
                            "Forgetting to open the console to see output",
                            "Logging sensitive data, like passwords, which can expose security risks"
                          ],
                          "exercises": [
                            {
                              "title": "Console Practice",
                              "prompt": "Write JavaScript to log 'Welcome to the console!' and the value of a variable 'count' set to 10.",
                              "difficulty": "easy",
                              "hints": [
                                "Use console.log()",
                                "Declare the variable with let"
                              ],
                              "solution": "<script>\n  let count = 10;\n  console.log('Welcome to the console!');\n  console.log(count);\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does console.log() do?",
                              "options": [
                                "Displays an alert",
                                "Logs to the console",
                                "Saves to a file",
                                "Styles the page"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "How do you open the browser console?",
                              "options": [
                                "F12 or Inspect",
                                "Ctrl+Shift+J",
                                "Right-click > Console",
                                "Both a and b"
                              ],
                              "correctOption": [3]
                            },
                            {
                              "question": "Which method logs an error?",
                              "options": [
                                "console.log()",
                                "console.error()",
                                "console.warn()",
                                "console.info()"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Why use the console?",
                              "options": [
                                "To style pages",
                                "To debug code",
                                "To store data",
                                "To create HTML"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN Console API",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/API/Console",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439076",
                        "title": "Primitive Types & Variables",
                        "slug": "primitive-types-variables",
                        "description": "Learn JavaScript primitive types and variable declarations.",
                        "order": 3,
                        "content": {
                          "explanation": "JavaScript has several primitive data types: number (e.g., 42, 3.14), string (e.g., 'hello'), boolean (true/false), null (no value), undefined (unassigned value), and symbol (unique identifiers). Variables store these values and are declared using 'var', 'let', or 'const'. 'var' is older and has function or global scope, which can lead to issues. 'let' allows reassignment and has block scope, making it safer for most cases. 'const' is for values that won't be reassigned, but objects declared with 'const' can still have their properties modified. Understanding types and variables is crucial because JavaScript is dynamically typed, meaning you don't specify types explicitly, and the interpreter determines them at runtime. This flexibility requires careful variable management to avoid errors like redeclaring variables or unexpected type coercion.",
                          "examples": [
                            "let num = 42;\nconst name = 'Alice';\nlet isActive = true;\nlet nothing = null;\nlet notAssigned;\nconsole.log(typeof num); // 'number'",
                            "const obj = { key: 'value' }; obj.key = 'new value'; // Allowed\n// obj = {}; // Error: cannot reassign const"
                          ],
                          "realWorldApplication": "Variables store user inputs, calculations, or states in applications, like tracking a shopping cart total or user login status.",
                          "expertInsights": "Prefer 'let' and 'const' over 'var' to avoid scope-related bugs, and always initialize variables to avoid 'undefined' errors.",
                          "commonMistakes": [
                            "Using 'var' instead of 'let' or 'const', causing scope issues",
                            "Assuming 'const' prevents all changes (objects can still be mutated)",
                            "Not understanding type coercion, e.g., '5' + 5 = '55'"
                          ],
                          "exercises": [
                            {
                              "title": "Small Arithmetic Script",
                              "prompt": "Write JavaScript to declare two numbers using 'let', calculate their sum, and log the result.",
                              "difficulty": "medium",
                              "hints": [
                                "Use 'let' for variable declarations",
                                "Use console.log() to output the sum"
                              ],
                              "solution": "<script>\n  let num1 = 10;\n  let num2 = 20;\n  let sum = num1 + num2;\n  console.log('Sum:', sum);\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "Which is NOT a JavaScript primitive type?",
                              "options": [
                                "number",
                                "string",
                                "object",
                                "boolean"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "What keyword prevents variable reassignment?",
                              "options": ["var", "let", "const", "static"],
                              "correctOption": [2]
                            },
                            {
                              "question": "What is the value of an uninitialized variable?",
                              "options": ["null", "undefined", "0", "false"],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN JavaScript Data Types",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439077",
                        "title": "Strict Mode",
                        "slug": "strict-mode",
                        "description": "Learn to use strict mode for cleaner and safer JavaScript code.",
                        "order": 4,
                        "content": {
                          "explanation": "Strict mode is a JavaScript feature activated by adding 'use strict'; at the start of a script or function. It enforces stricter rules to catch common coding mistakes and prevent unsafe practices. For example, strict mode prevents undeclared variables, disallows duplicate function parameters, and throws errors for deprecated features. It helps beginners write cleaner code by catching errors early, such as assigning to undeclared variables, which would otherwise create global variables. Strict mode also improves performance in some cases by allowing the JavaScript engine to optimize code better. By adopting strict mode, you ensure your code is more robust, easier to debug, and compatible with modern JavaScript practices, making it a best practice for all projects.",
                          "examples": [
                            "'use strict';\nlet x = 10;\ny = 20; // Error: y is not declared",
                            "'use strict';\nfunction test(a, a) { } // Error: duplicate parameter\nfunction test() { console.log('Safe code'); }"
                          ],
                          "realWorldApplication": "Strict mode is used in production code to prevent bugs, like in web apps where undeclared variables could cause unexpected behavior.",
                          "expertInsights": "Always use strict mode in new projects to enforce good coding habits and avoid legacy JavaScript pitfalls.",
                          "commonMistakes": [
                            "Forgetting to include 'use strict' at the start of the script",
                            "Assuming strict mode fixes all errors (it only catches specific issues)"
                          ],
                          "exercises": [
                            {
                              "title": "Variable Scoping Example",
                              "prompt": "Write a JavaScript function in strict mode that declares a variable with 'let' and logs it, ensuring no undeclared variables are used.",
                              "difficulty": "medium",
                              "hints": [
                                "Add 'use strict' at the start",
                                "Use 'let' for variable declaration"
                              ],
                              "solution": "<script>\n  'use strict';\n  function logValue() {\n    let value = 100;\n    console.log(value);\n  }\n  logValue();\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "How do you enable strict mode?",
                              "options": [
                                "strict: true",
                                "'use strict';",
                                "enableStrict()",
                                "strictMode()"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does strict mode prevent?",
                              "options": [
                                "Undeclared variables",
                                "All errors",
                                "Console logging",
                                "Variable declarations"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "Where should 'use strict' be placed?",
                              "options": [
                                "End of script",
                                "Start of script or function",
                                "Middle of script",
                                "In HTML"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What happens if you use an undeclared variable in strict mode?",
                              "options": [
                                "It works fine",
                                "Creates global variable",
                                "Throws an error",
                                "Logs to console"
                              ],
                              "correctOption": [2]
                            }
                          ],
                          "estimatedTime": 25,
                          "resources": [
                            {
                              "title": "MDN Strict Mode",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-13T23:05:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439080",
    "title": "JavaScript Control Flow & Operators",
    "slug": "js-control-flow-operators",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439081",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Learn essential JavaScript control flow and operator concepts for dynamic programming.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439082",
            "title": "JavaScript Control Flow Essentials",
            "slug": "js-control-flow-essentials",
            "shortDescription": "A beginner-friendly course to master JavaScript control flow and operators.",
            "longDescription": "This course covers JavaScript's control flow mechanisms, including comparisons, logical operators, conditional statements (if/else, switch), and loops (for, while, for...of), enabling you to write dynamic and interactive code.",
            "tags": [
              "JavaScript",
              "Control Flow",
              "Operators",
              "Beginner",
              "Frontend"
            ],
            "thumbnail": "https://example.com/thumbnails/js-control-flow.jpg",
            "levels": [
              {
                "level": "Beginner",
                "overview": "This level introduces JavaScript control flow and operators, teaching you how to make decisions, handle conditions, and iterate over data for interactive web applications.",
                "goals": [
                  "Understand comparison and logical operators for decision-making",
                  "Master if/else and switch statements for conditional logic",
                  "Learn to use for, while, and for...of loops for iteration",
                  "Apply control flow in practical scenarios like filtering and iteration"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439083",
                    "title": "Control Flow & Operators",
                    "slug": "control-flow-operators",
                    "description": "Learn to control program flow and use operators in JavaScript.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439084",
                        "title": "Comparison and Logical Operators",
                        "slug": "comparison-logical-operators",
                        "description": "Understand how to use comparison and logical operators for decision-making.",
                        "order": 1,
                        "content": {
                          "explanation": "JavaScript operators are essential for controlling program logic. Comparison operators compare values and return a boolean (true or false). These include equality (== for loose, === for strict), inequality (!= loose, !== strict), greater than (>), less than (<), greater than or equal (>=), and less than or equal (<=). Strict equality (===) checks both value and type, preventing unexpected type coercion (e.g., '5' == 5 is true, but '5' === 5 is false). Logical operators combine conditions: && (and) returns true if both operands are true, || (or) returns true if at least one operand is true, and ! (not) inverts a boolean. These operators are foundational for building conditional logic, allowing you to evaluate conditions and make decisions in your code. For example, you can check if a user is logged in and has admin privileges before granting access to a feature. Understanding the nuances of loose vs. strict equality and logical operator precedence is critical for writing reliable code, especially in dynamic web applications where user inputs vary.",
                          "examples": [
                            "let x = 10;\nconsole.log(x === 10); // true\nconsole.log(x == '10'); // true\nconsole.log(x === '10'); // false",
                            "let age = 25;\nlet isAdult = age >= 18 && age < 65;\nconsole.log(isAdult); // true\nconsole.log(age < 18 || age >= 65); // false"
                          ],
                          "realWorldApplication": "Comparison and logical operators are used in form validation (e.g., checking if a password meets length requirements) and access control (e.g., verifying user roles).",
                          "expertInsights": "Always use strict equality (===) to avoid unexpected type coercion, and combine logical operators carefully to ensure clear condition evaluation.",
                          "commonMistakes": [
                            "Using == instead of ===, leading to type coercion errors",
                            "Misunderstanding operator precedence, e.g., && is evaluated before ||",
                            "Not accounting for edge cases like null or undefined in comparisons"
                          ],
                          "exercises": [
                            {
                              "title": "Filter Numbers",
                              "prompt": "Write JavaScript to check if a number is between 10 and 100 (inclusive) using comparison and logical operators, and log the result.",
                              "difficulty": "easy",
                              "hints": [
                                "Use >= and <= for range checking",
                                "Combine conditions with &&"
                              ],
                              "solution": "<script>\n  let num = 50;\n  let isInRange = num >= 10 && num <= 100;\n  console.log(isInRange); // true\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does === check?",
                              "options": [
                                "Value only",
                                "Type only",
                                "Value and type",
                                "Reference only"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "Which operator returns true if both conditions are true?",
                              "options": ["||", "&&", "!", "=="],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is the result of 5 !== '5'?",
                              "options": ["true", "false", "undefined", "null"],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 15,
                          "resources": [
                            {
                              "title": "MDN Comparison Operators",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Comparison_Operators",
                              "type": "article"
                            },
                            {
                              "title": "JavaScript Operators Video",
                              "url": "https://www.youtube.com/watch?v=example-operators-video",
                              "type": "video"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439085",
                        "title": "If/Else Statements",
                        "slug": "if-else-statements",
                        "description": "Learn to use if/else statements for conditional logic.",
                        "order": 2,
                        "content": {
                          "explanation": "If/else statements allow JavaScript to execute different code blocks based on conditions. The 'if' statement checks a condition; if true, its block runs. An optional 'else if' checks additional conditions, and an 'else' block runs if no conditions are true. Conditions often use comparison and logical operators to evaluate expressions. For example, you can check a user's age to determine access to content or display different messages based on input values. If/else statements are fundamental for decision-making in programming, enabling dynamic behavior like showing error messages for invalid form inputs or redirecting users based on their actions. Nesting if/else statements is possible but should be used sparingly to keep code readable. Beginners should focus on writing clear conditions and ensuring all possible cases are handled to avoid unexpected behavior, such as missing an else block for default cases. Proper indentation and logical organization make if/else statements easier to maintain and debug.",
                          "examples": [
                            "let age = 20;\nif (age >= 18) {\n  console.log('Adult');\n} else {\n  console.log('Minor');\n}",
                            "let score = 85;\nif (score >= 90) {\n  console.log('A');\n} else if (score >= 80) {\n  console.log('B');\n} else {\n  console.log('C or below');\n}"
                          ],
                          "realWorldApplication": "Used in web apps for tasks like validating user inputs, displaying conditional content, or handling user permissions.",
                          "expertInsights": "Keep if/else chains short and consider using switch or object literals for complex conditionals to improve readability.",
                          "commonMistakes": [
                            "Forgetting curly braces {} for multi-line blocks",
                            "Writing overly complex nested if/else statements",
                            "Not handling all possible conditions, leading to unhandled cases"
                          ],
                          "exercises": [
                            {
                              "title": "Filter Numbers with If/Else",
                              "prompt": "Write JavaScript to check if a number is positive, negative, or zero using if/else, and log the result.",
                              "difficulty": "easy",
                              "hints": [
                                "Use if, else if, and else",
                                "Compare the number with 0"
                              ],
                              "solution": "<script>\n  let num = 42;\n  if (num > 0) {\n    console.log('Positive');\n  } else if (num < 0) {\n    console.log('Negative');\n  } else {\n    console.log('Zero');\n  }\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What happens if no if/else condition is true and there's no else block?",
                              "options": [
                                "Error",
                                "Nothing runs",
                                "Logs undefined",
                                "Runs the first block"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "How many conditions can 'else if' check?",
                              "options": ["One", "Two", "Unlimited", "None"],
                              "correctOption": [2]
                            },
                            {
                              "question": "What is required for an if statement?",
                              "options": [
                                "Condition",
                                "Else block",
                                "Curly braces",
                                "Both a and c"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What does else do?",
                              "options": [
                                "Checks a condition",
                                "Runs if no conditions are true",
                                "Loops code",
                                "Declares variables"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN If...Else",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439086",
                        "title": "Switch Statements",
                        "slug": "switch-statements",
                        "description": "Learn to use switch statements for multiple conditions.",
                        "order": 3,
                        "content": {
                          "explanation": "Switch statements provide an alternative to if/else for handling multiple conditions based on a single expression's value. The 'switch' keyword evaluates an expression, and each 'case' clause specifies a value to match. If a match is found, the corresponding block runs until a 'break' statement or the switch ends. A 'default' case handles unmatched values, acting like an else block. Switch is ideal when you have a single variable with multiple possible values, such as determining a user's role or processing menu selections. Unlike if/else, switch avoids repetitive condition checks, making code cleaner for specific use cases. However, forgetting 'break' can cause 'fall-through,' where subsequent cases execute unintentionally. Beginners should focus on matching exact values, using break consistently, and including a default case to handle unexpected inputs, ensuring robust and predictable logic in their programs.",
                          "examples": [
                            "let day = 'Monday';\nswitch (day) {\n  case 'Monday':\n    console.log('Start of week');\n    break;\n  case 'Friday':\n    console.log('End of week');\n    break;\n  default:\n    console.log('Midweek');\n}",
                            "let grade = 'B';\nswitch (grade) {\n  case 'A':\n    console.log('Excellent');\n    break;\n  case 'B':\n    console.log('Good');\n    break;\n  default:\n    console.log('Needs improvement');\n}"
                          ],
                          "realWorldApplication": "Used in applications to handle user inputs, like selecting options in a dropdown or processing form responses.",
                          "expertInsights": "Use switch for discrete value matching, but prefer if/else for complex conditions or ranges to maintain clarity.",
                          "commonMistakes": [
                            "Forgetting 'break', causing fall-through behavior",
                            "Not including a default case for unmatched values",
                            "Using switch for complex conditions better suited for if/else"
                          ],
                          "exercises": [
                            {
                              "title": "Switch-Based Categorization",
                              "prompt": "Write a switch statement to log 'Hot', 'Warm', or 'Cold' based on a temperature variable (Hot: >=30, Warm: 15-29, Cold: <15).",
                              "difficulty": "medium",
                              "hints": [
                                "Use if/else within cases if needed for ranges",
                                "Include a default case"
                              ],
                              "solution": "<script>\n  let temp = 25;\n  switch (true) {\n    case temp >= 30:\n      console.log('Hot');\n      break;\n    case temp >= 15:\n      console.log('Warm');\n      break;\n    default:\n      console.log('Cold');\n  }\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does a 'break' statement do in a switch?",
                              "options": [
                                "Exits the switch",
                                "Skips a case",
                                "Repeats the case",
                                "Checks a condition"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What is the role of the default case?",
                              "options": [
                                "Runs first",
                                "Handles unmatched values",
                                "Replaces break",
                                "Checks conditions"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What happens without a break in a case?",
                              "options": [
                                "Error",
                                "Fall-through to next case",
                                "Skips all cases",
                                "Stops execution"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN Switch Statement",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439087",
                        "title": "Loops",
                        "slug": "loops",
                        "description": "Learn to use for, while, and for...of loops for iteration.",
                        "order": 4,
                        "content": {
                          "explanation": "Loops allow JavaScript to repeat code until a condition is met, making them essential for tasks like processing lists or performing repetitive calculations. The 'for' loop (for (initialization; condition; update)) is ideal for a known number of iterations, such as looping through an array's indices. The 'while' loop runs as long as a condition is true, useful when the number of iterations is unknown, like waiting for user input. The 'for...of' loop iterates over iterable objects (e.g., arrays, strings), providing a simpler syntax for accessing values directly. Loops can be controlled with 'break' to exit early or 'continue' to skip an iteration. Beginners should be cautious of infinite loops, which occur when a condition never becomes false, freezing the program. Proper loop design, including clear conditions and updates, ensures efficient and error-free iteration, enabling tasks like rendering lists or filtering data in web applications.",
                          "examples": [
                            "for (let i = 0; i < 5; i++) {\n  console.log(i); // Logs 0, 1, 2, 3, 4\n}",
                            "let count = 0;\nwhile (count < 3) {\n  console.log(count);\n  count++;\n}",
                            "let items = ['apple', 'banana', 'orange'];\nfor (let item of items) {\n  console.log(item);\n}"
                          ],
                          "realWorldApplication": "Loops are used to render dynamic content (e.g., product lists in e-commerce) or process user data (e.g., filtering valid emails).",
                          "expertInsights": "Use 'for...of' for arrays and iterables to simplify code, and always ensure loop conditions will eventually terminate to avoid infinite loops.",
                          "commonMistakes": [
                            "Creating infinite loops by not updating the condition",
                            "Using incorrect loop types, e.g., for instead of for...of for arrays",
                            "Modifying loop variables unexpectedly, causing skips or errors"
                          ],
                          "exercises": [
                            {
                              "title": "Iterate List of Items",
                              "prompt": "Write JavaScript to iterate over an array ['cat', 'dog', 'bird'] using for...of and log each item.",
                              "difficulty": "medium",
                              "hints": [
                                "Use for...of for array iteration",
                                "Log each item with console.log()"
                              ],
                              "solution": "<script>\n  let animals = ['cat', 'dog', 'bird'];\n  for (let animal of animals) {\n    console.log(animal);\n  }\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "Which loop is best for iterating over array values?",
                              "options": ["for", "while", "for...of", "switch"],
                              "correctOption": [2]
                            },
                            {
                              "question": "What stops a loop early?",
                              "options": [
                                "continue",
                                "break",
                                "return",
                                "Both b and c"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What causes an infinite loop?",
                              "options": [
                                "Missing break",
                                "Condition never false",
                                "Incorrect variable",
                                "Using for...of"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does 'continue' do in a loop?",
                              "options": [
                                "Exits the loop",
                                "Skips to next iteration",
                                "Restarts the loop",
                                "Logs output"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 25,
                          "resources": [
                            {
                              "title": "MDN Loops and Iteration",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-13T23:16:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439090",
    "title": "JavaScript Functions, Scope & Closures",
    "slug": "js-functions-scope-closures",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439091",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Explore advanced JavaScript concepts for managing code execution and data encapsulation.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439092",
            "title": "JavaScript Functions and Scope",
            "slug": "js-functions-and-scope",
            "shortDescription": "A beginner-friendly course on JavaScript functions, scope, and closures.",
            "longDescription": "This course delves into JavaScript functions, including declarations, expressions, and arrow functions, along with scope chains and closures, teaching you how to organize code and manage variable accessibility effectively.",
            "tags": [
              "JavaScript",
              "Functions",
              "Scope",
              "Closures",
              "Beginner"
            ],
            "thumbnail": "https://example.com/thumbnails/js-functions.jpg",
            "levels": [
              {
                "level": "Beginner",
                "overview": "This level covers JavaScript functions, scope, and closures, enabling you to write modular, reusable code with proper variable management.",
                "goals": [
                  "Understand different ways to declare and use functions",
                  "Learn about variable scope and the scope chain",
                  "Master closures for data privacy and advanced patterns",
                  "Apply these concepts in practical exercises"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439093",
                    "title": "Functions, Scope & Closures",
                    "slug": "functions-scope-closures",
                    "description": "Learn to define functions, manage scope, and use closures in JavaScript.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439094",
                        "title": "Function Declarations and Expressions",
                        "slug": "function-declarations-expressions",
                        "description": "Understand function declarations and expressions in JavaScript.",
                        "order": 1,
                        "content": {
                          "explanation": "Functions in JavaScript are reusable blocks of code that perform specific tasks, promoting modularity and reducing repetition. Function declarations define named functions using the 'function' keyword, followed by the name, parameters in parentheses, and the body in curly braces. They are hoisted, meaning they can be called before their definition in the code. Function expressions, on the other hand, assign a function to a variable, like 'let add = function(a, b) { return a + b; };'. These are not hoisted and must be defined before use. Anonymous functions (without names) are common in expressions, especially as callbacks. Parameters are placeholders for inputs, while arguments are actual values passed when calling the function. Functions can return values using 'return', or undefined if omitted. Understanding declarations vs. expressions is key for controlling when and how functions are available, especially in larger scripts where hoisting can lead to unexpected behavior if not managed properly. Beginners should practice naming functions descriptively and handling parameters with defaults (e.g., function greet(name = 'User') {}) to make code more robust and readable.",
                          "examples": [
                            "// Declaration\nfunction greet(name) {\n  return 'Hello, ' + name;\n}\nconsole.log(greet('Alice')); // 'Hello, Alice'",
                            "// Expression\nlet add = function(a, b) {\n  return a + b;\n};\nconsole.log(add(2, 3)); // 5"
                          ],
                          "realWorldApplication": "Functions are used to handle events (e.g., button clicks) or process data (e.g., calculating totals in a shopping cart).",
                          "expertInsights": "Use declarations for top-level functions and expressions for callbacks or when conditional definition is needed.",
                          "commonMistakes": [
                            "Calling a function expression before its declaration, causing errors",
                            "Forgetting to return values, resulting in undefined",
                            "Overloading functions with too many parameters, reducing clarity"
                          ],
                          "exercises": [
                            {
                              "title": "Create a Simple Function",
                              "prompt": "Write a function declaration that takes two numbers and returns their product.",
                              "difficulty": "easy",
                              "hints": [
                                "Use 'function' keyword",
                                "Return the result with '*' operator"
                              ],
                              "solution": "<script>\n  function multiply(a, b) {\n    return a * b;\n  }\n  console.log(multiply(4, 5)); // 20\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is hoisted in JavaScript?",
                              "options": [
                                "Function expressions",
                                "Function declarations",
                                "Arrow functions",
                                "Variables only"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does a function return if no return statement is used?",
                              "options": ["null", "undefined", "0", "Error"],
                              "correctOption": [1]
                            },
                            {
                              "question": "Which can be called before definition?",
                              "options": [
                                "Expression",
                                "Declaration",
                                "Both",
                                "Neither"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 15,
                          "resources": [
                            {
                              "title": "MDN Functions",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Functions",
                              "type": "article"
                            },
                            {
                              "title": "JavaScript Functions Video",
                              "url": "https://www.youtube.com/watch?v=example-functions-video",
                              "type": "video"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439095",
                        "title": "Arrow Functions",
                        "slug": "arrow-functions",
                        "description": "Learn concise arrow function syntax and their behavior.",
                        "order": 2,
                        "content": {
                          "explanation": "Arrow functions provide a shorter syntax for writing function expressions, introduced in ES6. They use '=>' instead of 'function', like 'const add = (a, b) => a + b;'. For single-line bodies, the return is implicit; for multi-line, use curly braces and explicit return. Arrow functions don't have their own 'this' binding, inheriting it from the parent scope, making them ideal for callbacks where 'this' context matters (e.g., in class methods or event handlers). They can't be used as constructors or with 'new', and lack 'arguments' object, using rest parameters instead (e.g., (...args) => {}). Parameters can have defaults, like (x = 1) => x * 2. Arrow functions enhance readability in functional programming patterns, like array methods (map, filter). However, their lexical 'this' can confuse beginners if not understood. Practice converting traditional functions to arrows, noting when 'this' or 'arguments' is needed, as arrows aren't suitable for all cases, like methods requiring dynamic 'this'.",
                          "examples": [
                            "const square = x => x * x;\nconsole.log(square(4)); // 16",
                            "const greet = name => {\n  let message = 'Hello, ' + name;\n  return message;\n};\nconsole.log(greet('Bob')); // 'Hello, Bob'"
                          ],
                          "realWorldApplication": "Arrow functions are common in React components for event handlers or in promises for concise asynchronous code.",
                          "expertInsights": "Use arrows for non-method functions to avoid 'this' issues, but stick to traditional methods in objects for proper binding.",
                          "commonMistakes": [
                            "Using arrow functions as object methods, losing 'this' context",
                            "Forgetting curly braces for multi-line bodies",
                            "Trying to use 'arguments' in arrows, which isn't available"
                          ],
                          "exercises": [
                            {
                              "title": "Convert to Arrow Function",
                              "prompt": "Rewrite a function expression that adds two numbers as an arrow function.",
                              "difficulty": "easy",
                              "hints": [
                                "Use '=>' syntax",
                                "Implicit return for single expression"
                              ],
                              "solution": "<script>\n  const add = (a, b) => a + b;\n  console.log(add(3, 7)); // 10\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does an arrow function inherit for 'this'?",
                              "options": [
                                "Global context",
                                "Parent scope",
                                "Its own this",
                                "Undefined"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Can arrow functions be constructors?",
                              "options": [
                                "Yes",
                                "No",
                                "Only with new",
                                "Sometimes"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "When is return implicit in arrows?",
                              "options": [
                                "Multi-line body",
                                "Single-line expression",
                                "With curly braces",
                                "Always"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What replaces 'arguments' in arrows?",
                              "options": [
                                "this",
                                "Rest parameters",
                                "Defaults",
                                "Nothing"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN Arrow Functions",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439096",
                        "title": "Scope Chain",
                        "slug": "scope-chain",
                        "description": "Understand variable scope and the scope chain in JavaScript.",
                        "order": 3,
                        "content": {
                          "explanation": "Scope determines variable accessibility in JavaScript. Global scope is outside functions, accessible anywhere. Function (local) scope is inside functions, accessible only there. Block scope (with let/const) is within {} blocks like if/loops. The scope chain is how JavaScript resolves variables: it searches the current scope, then outer scopes, up to global. If not found, it throws a ReferenceError. This chain enables closures but can cause shadowing (inner variables hiding outer ones with the same name). Understanding scope prevents bugs like unintended global variables or accessing undefined vars. Beginners should use let/const for block scope to avoid var's function scope issues. Practice tracing variable resolution in nested functions to grasp the chain, ensuring code is modular and variables are properly encapsulated to minimize side effects.",
                          "examples": [
                            "let globalVar = 'Global';\nfunction outer() {\n  let outerVar = 'Outer';\n  function inner() {\n    let innerVar = 'Inner';\n    console.log(globalVar + outerVar + innerVar); // 'GlobalOuterInner'\n  }\n  inner();\n}\nouter();",
                            "let x = 10;\nif (true) {\n  let x = 20; // Shadows outer x\n  console.log(x); // 20\n}\nconsole.log(x); // 10"
                          ],
                          "realWorldApplication": "Scope chains are crucial in modular code, like in frameworks where variables need isolation to prevent conflicts.",
                          "expertInsights": "Avoid globals; use modules or IIFEs for encapsulation, and leverage block scope for temporary variables.",
                          "commonMistakes": [
                            "Using var instead of let/const, causing unexpected scope behavior",
                            "Shadowing variables unintentionally, leading to bugs",
                            "Accessing variables outside their scope, causing ReferenceError"
                          ],
                          "exercises": [
                            {
                              "title": "Demonstrate Scope Chain",
                              "prompt": "Write nested functions to log variables from different scopes.",
                              "difficulty": "medium",
                              "hints": [
                                "Use let for block scope",
                                "Access outer variables from inner functions"
                              ],
                              "solution": "<script>\n  let outerVar = 'Outer';\n  function testScope() {\n    let innerVar = 'Inner';\n    console.log(outerVar + ' ' + innerVar);\n  }\n  testScope(); // 'Outer Inner'\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is the outermost scope?",
                              "options": [
                                "Block",
                                "Function",
                                "Global",
                                "Local"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "What happens if a variable isn't found in the scope chain?",
                              "options": [
                                "Undefined",
                                "ReferenceError",
                                "Null",
                                "Global creation"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Which keyword creates block scope?",
                              "options": ["var", "let", "function", "global"],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN Scope",
                              "url": "https://developer.mozilla.org/en-US/docs/Glossary/Scope",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439097",
                        "title": "Closures",
                        "slug": "closures",
                        "description": "Learn how closures work for data privacy and advanced patterns.",
                        "order": 4,
                        "content": {
                          "explanation": "Closures occur when a function retains access to its lexical scope even after the outer function executes. This allows inner functions to 'remember' outer variables, enabling data privacy and encapsulation. For example, a counter function can use a closure to hide the count variable, preventing external modification. Closures are created whenever a function is defined inside another, capturing the scope chain. They are memory-efficient but can cause leaks if overused, as captured variables persist. Closures power patterns like modules, currying, and memoization. Beginners should understand that every function in JavaScript is a closure in some sense, but practical use involves returning inner functions from outer ones. Experiment with closures to see how they maintain state across calls, but be mindful of performance in loops creating many closures. Explain memory: closed-over variables stay in memory until no references remain.",
                          "examples": [
                            "function makeCounter() {\n  let count = 0;\n  return function() {\n    return count++;\n  };\n}\nlet counter = makeCounter();\nconsole.log(counter()); // 0\nconsole.log(counter()); // 1",
                            "function outer() {\n  let x = 10;\n  return function inner() {\n    console.log(x);\n  };\n}\nlet func = outer();\nfunc(); // 10 (x is closed over)"
                          ],
                          "realWorldApplication": "Closures are used in event handlers to preserve state or in libraries for private data, like in React hooks.",
                          "expertInsights": "Use closures for encapsulation but avoid in performance-critical loops to prevent memory issues.",
                          "commonMistakes": [
                            "Creating unintended closures in loops, capturing the same variable",
                            "Overusing closures, leading to memory leaks",
                            "Confusing closures with global variables"
                          ],
                          "exercises": [
                            {
                              "title": "Create a Closure Counter",
                              "prompt": "Write a function that returns a counter function using closure, and explain the memory/result (count persists in memory, increments on each call).",
                              "difficulty": "medium",
                              "hints": [
                                "Return an inner function",
                                "Use let for the private variable"
                              ],
                              "solution": "<script>\n  function createCounter() {\n    let count = 0;\n    return function() {\n      return count++;\n    };\n  }\n  let myCounter = createCounter();\n  console.log(myCounter()); // 0\n  console.log(myCounter()); // 1\n  // Explanation: 'count' is closed over, persists in memory, and increments on each call without external access.\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does a closure capture?",
                              "options": [
                                "Global variables",
                                "Lexical scope",
                                "Arguments only",
                                "Nothing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Why use closures?",
                              "options": [
                                "Data privacy",
                                "Global access",
                                "Performance loss",
                                "Error creation"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What can closures cause if overused?",
                              "options": [
                                "Speed increase",
                                "Memory leaks",
                                "Code shortening",
                                "Variable deletion"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "How is a closure created?",
                              "options": [
                                "Function inside function",
                                "Global function",
                                "Arrow only",
                                "Loop inside function"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 25,
                          "resources": [
                            {
                              "title": "MDN Closures",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-13T23:29:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439100",
    "title": "JavaScript Arrays & Objects",
    "slug": "js-arrays-objects",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439101",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Learn to work with JavaScript arrays and objects for data manipulation and storage.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439102",
            "title": "JavaScript Arrays and Objects Essentials",
            "slug": "js-arrays-objects-essentials",
            "shortDescription": "A beginner-friendly course to master JavaScript arrays, objects, and their methods.",
            "longDescription": "This course covers JavaScript arrays and objects, including key array methods (map, filter, reduce), object literals, property access, and nested structures, enabling you to manage and manipulate data effectively in web applications.",
            "tags": ["JavaScript", "Arrays", "Objects", "Beginner", "Frontend"],
            "thumbnail": "https://example.com/thumbnails/js-arrays-objects.jpg",
            "levels": [
              {
                "level": "Beginner",
                "overview": "This level teaches how to use arrays and objects in JavaScript, focusing on array methods, object creation, property access, and handling nested data structures.",
                "goals": [
                  "Understand and use array methods like map, filter, and reduce",
                  "Learn to create and manipulate object literals",
                  "Master property access and nested structures",
                  "Apply arrays and objects in practical data management tasks"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439103",
                    "title": "Arrays & Objects",
                    "slug": "arrays-objects",
                    "description": "Learn to manipulate and store data using JavaScript arrays and objects.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439104",
                        "title": "Array Basics and Methods",
                        "slug": "array-basics-methods",
                        "description": "Understand arrays and key methods like map, filter, and reduce.",
                        "order": 1,
                        "content": {
                          "explanation": "Arrays in JavaScript are ordered lists that store multiple values, accessible by index (starting at 0). They are versatile for managing collections, like lists of users or tasks. Arrays come with powerful built-in methods for data manipulation. The 'map' method transforms each element, returning a new array (e.g., doubling numbers). The 'filter' method creates a new array with elements passing a test (e.g., selecting even numbers). The 'reduce' method combines elements into a single value, like summing an array. These methods are functional, meaning they don’t mutate the original array, promoting predictable code. For example, map can convert an array of numbers to their squares, filter can extract items meeting a condition, and reduce can calculate totals. Beginners should focus on understanding how these methods chain together and avoid mutating arrays directly (e.g., using push/pop sparingly). Practice chaining methods for complex transformations, but be cautious of performance with large arrays, as each method creates a new array. Arrays are iterable, making them compatible with for...of loops, and their flexibility makes them a cornerstone of JavaScript programming.",
                          "examples": [
                            "let numbers = [1, 2, 3];\nlet doubled = numbers.map(n => n * 2); // [2, 4, 6]\nlet evens = numbers.filter(n => n % 2 === 0); // [2]\nlet sum = numbers.reduce((acc, n) => acc + n, 0); // 6",
                            "let names = ['Alice', 'Bob'];\nlet greetings = names.map(name => `Hello, ${name}`); // ['Hello, Alice', 'Hello, Bob']"
                          ],
                          "realWorldApplication": "Array methods are used in web apps to render lists (e.g., product catalogs), filter user data (e.g., search results), or compute totals (e.g., cart prices).",
                          "expertInsights": "Chain map, filter, and reduce for concise data processing, but avoid overuse with large datasets to prevent performance issues.",
                          "commonMistakes": [
                            "Mutating the original array instead of using map/filter",
                            "Forgetting reduce’s initial value, causing errors with empty arrays",
                            "Misunderstanding arrow function syntax in method callbacks"
                          ],
                          "exercises": [
                            {
                              "title": "Filter and Map Todo List",
                              "prompt": "Write JavaScript to create an array of todo tasks (strings) and use filter to get tasks containing 'buy', then map to add 'Task: ' prefix.",
                              "difficulty": "medium",
                              "hints": [
                                "Use filter with includes()",
                                "Use map to transform strings"
                              ],
                              "solution": "<script>\n  let todos = ['buy milk', 'read book', 'buy bread'];\n  let buyTasks = todos.filter(task => task.includes('buy'));\n  let formatted = buyTasks.map(task => 'Task: ' + task);\n  console.log(formatted); // ['Task: buy milk', 'Task: buy bread']\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does map return?",
                              "options": [
                                "Original array",
                                "New array",
                                "Single value",
                                "Nothing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does filter do?",
                              "options": [
                                "Transforms elements",
                                "Selects matching elements",
                                "Sums elements",
                                "Removes all elements"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is reduce’s second argument?",
                              "options": [
                                "Callback",
                                "Initial value",
                                "Array",
                                "Condition"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN Array Methods",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array",
                              "type": "article"
                            },
                            {
                              "title": "JavaScript Array Methods Video",
                              "url": "https://www.youtube.com/watch?v=example-array-methods-video",
                              "type": "video"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439105",
                        "title": "Object Literals",
                        "slug": "object-literals",
                        "description": "Learn to create and use object literals for structured data.",
                        "order": 2,
                        "content": {
                          "explanation": "Object literals in JavaScript are collections of key-value pairs enclosed in curly braces {}, used to represent structured data, like a user’s profile or a product’s details. Keys are strings (or symbols), and values can be any type, including other objects or arrays. Objects are created like `const user = { name: 'Alice', age: 25 };`. Properties are accessed using dot notation (user.name) or bracket notation (user['name']), with brackets useful for dynamic keys or keys with spaces. Objects are mutable; you can add, modify, or delete properties after creation (e.g., user.email = 'alice@example.com'). Unlike arrays, objects are unordered, making them ideal for representing entities with named attributes. Beginners should practice creating objects with meaningful keys and avoid common pitfalls like undefined properties or overwriting data unintentionally. Objects are central to JavaScript, used in APIs, DOM manipulation, and frameworks, so understanding their syntax and behavior is crucial for building real-world applications like forms or data models.",
                          "examples": [
                            "const user = { name: 'Alice', age: 25 };\nconsole.log(user.name); // 'Alice'\nuser.email = 'alice@example.com';\nconsole.log(user['email']); // 'alice@example.com'",
                            "const settings = { 'font size': 16, theme: 'dark' };\nconsole.log(settings['font size']); // 16"
                          ],
                          "realWorldApplication": "Objects model data in web apps, like user profiles in social media or product details in e-commerce.",
                          "expertInsights": "Use descriptive keys and consider freezing objects (Object.freeze()) to prevent unintended changes in critical data.",
                          "commonMistakes": [
                            "Accessing undefined properties, causing errors",
                            "Using dot notation for invalid keys (e.g., spaces)",
                            "Overwriting existing properties unintentionally"
                          ],
                          "exercises": [
                            {
                              "title": "Create a Todo Object",
                              "prompt": "Write JavaScript to create an object representing a todo item with properties for task, id, and completed status, then log the task.",
                              "difficulty": "easy",
                              "hints": [
                                "Use curly braces for object literal",
                                "Access property with dot notation"
                              ],
                              "solution": "<script>\n  const todo = { task: 'Buy milk', id: 1, completed: false };\n  console.log(todo.task); // 'Buy milk'\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "How do you access a property named 'user name'?",
                              "options": [
                                "user.name",
                                "user['user name']",
                                "user(user name)",
                                "user->name"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Can you add properties to an object after creation?",
                              "options": [
                                "No",
                                "Yes",
                                "Only with const",
                                "Only with var"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What happens when accessing an undefined property?",
                              "options": ["Error", "null", "undefined", "0"],
                              "correctOption": [2]
                            },
                            {
                              "question": "Are object properties ordered?",
                              "options": [
                                "Yes",
                                "No",
                                "Only numbers",
                                "Only strings"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN Objects",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439106",
                        "title": "Property Access and Nested Structures",
                        "slug": "property-access-nested-structures",
                        "description": "Learn to access properties and work with nested objects and arrays.",
                        "order": 3,
                        "content": {
                          "explanation": "Property access in JavaScript allows you to retrieve or modify object values using dot notation (obj.prop) or bracket notation (obj['prop']). Dot notation is cleaner but limited to valid identifiers; bracket notation handles dynamic keys or special characters (e.g., obj['my-key']). Nested structures involve objects or arrays within each other, like an object with an array property or an array of objects. For example, a user object might contain an address object or a list of tasks. Accessing nested properties requires chaining notation, like user.address.city. Care must be taken to avoid errors from undefined properties (e.g., user.address.city when address is undefined). Optional chaining (?.) simplifies this (user?.address?.city). Nested structures are common in real-world data, like JSON from APIs, so beginners should practice traversing and manipulating them. Use loops or array methods to process nested arrays, and check for existence before accessing deep properties to ensure robust code.",
                          "examples": [
                            "const user = { name: 'Alice', address: { city: 'New York', zip: 10001 } };\nconsole.log(user.address.city); // 'New York'\nconsole.log(user?.address?.zip); // 10001",
                            "const todos = [{ task: 'Buy milk', id: 1 }, { task: 'Read book', id: 2 }];\nconsole.log(todos[0].task); // 'Buy milk'"
                          ],
                          "realWorldApplication": "Nested structures model complex data, like user profiles with addresses or todo lists in task management apps.",
                          "expertInsights": "Use optional chaining (?.) and nullish coalescing (??) to handle missing properties safely in nested structures.",
                          "commonMistakes": [
                            "Accessing nested properties without checking for undefined",
                            "Using dot notation for keys with spaces or dynamic keys",
                            "Not updating nested objects correctly, losing references"
                          ],
                          "exercises": [
                            {
                              "title": "Todo List Data Model",
                              "prompt": "Create an in-memory todo list as an array of objects, each with task, id, and completed properties. Log the first task’s name.",
                              "difficulty": "medium",
                              "hints": [
                                "Use array of objects",
                                "Access first element with [0]"
                              ],
                              "solution": "<script>\n  const todoList = [\n    { task: 'Buy milk', id: 1, completed: false },\n    { task: 'Read book', id: 2, completed: true }\n  ];\n  console.log(todoList[0].task); // 'Buy milk'\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "How do you access a nested property safely?",
                              "options": [
                                "obj.prop",
                                "obj['prop']",
                                "obj?.prop",
                                "obj->prop"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "What is returned for obj.prop.sub if sub is undefined?",
                              "options": [
                                "null",
                                "undefined",
                                "Error",
                                "Empty object"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "Which notation allows dynamic keys?",
                              "options": ["Dot", "Bracket", "Both", "Neither"],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN Working with Objects",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439107",
                        "title": "Closures with Arrays and Objects",
                        "slug": "closures-arrays-objects",
                        "description": "Use closures with arrays and objects for data encapsulation.",
                        "order": 4,
                        "content": {
                          "explanation": "Closures allow functions to retain access to their lexical scope, making them powerful for managing arrays and objects privately. By wrapping an array or object in an outer function, you can return an inner function that manipulates the data while keeping it inaccessible externally. For example, a closure counter can store a count in an array or object, incrementing it privately with each call. This encapsulation prevents external code from modifying the data directly, ensuring data integrity. In the context of arrays/objects, closures can manage lists (e.g., todos) or configurations, exposing only specific methods (e.g., add, get). Memory-wise, closed-over variables (like an array or object) persist in memory as long as the closure exists, which can lead to leaks if not managed. Results depend on the closure’s logic, like incrementing a counter or filtering an array. Beginners should practice creating closures to manage data structures, understanding how the scope chain preserves state and the importance of avoiding excessive closures in loops to prevent memory issues.",
                          "examples": [
                            "function createTodoManager() {\n  let todos = [];\n  return {\n    add: task => todos.push({ task, id: todos.length + 1, completed: false }),\n    get: () => todos\n  };\n}\nlet manager = createTodoManager();\nmanager.add('Buy milk');\nconsole.log(manager.get()); // [{ task: 'Buy milk', id: 1, completed: false }]",
                            "function createCounter() {\n  let countObj = { count: 0 };\n  return () => {\n    countObj.count++;\n    return countObj.count;\n  };\n}\nlet counter = createCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2"
                          ],
                          "realWorldApplication": "Closures manage private state in web apps, like tracking user actions or maintaining todo lists without exposing data.",
                          "expertInsights": "Use closures for private data but monitor memory usage, especially with arrays/objects that persist across calls.",
                          "commonMistakes": [
                            "Creating closures in loops, capturing unintended references",
                            "Not understanding memory retention of closed-over arrays/objects",
                            "Exposing private data accidentally via closure methods"
                          ],
                          "exercises": [
                            {
                              "title": "Create a Closure Counter",
                              "prompt": "Write a function that returns a counter function using closure with an object to store count. Explain memory/result (count persists in memory, increments each call).",
                              "difficulty": "medium",
                              "hints": [
                                "Use an object to store count",
                                "Return a function that increments it"
                              ],
                              "solution": "<script>\n  function createCounter() {\n    let counterObj = { count: 0 };\n    return function() {\n      return ++counterObj.count;\n    };\n  }\n  let counter = createCounter();\n  console.log(counter()); // 1\n  console.log(counter()); // 2\n  // Explanation: counterObj persists in memory, count increments on each call, inaccessible externally.\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does a closure preserve in this context?",
                              "options": [
                                "Global variables",
                                "Array/object in scope",
                                "All variables",
                                "Nothing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What can closures with arrays/objects cause?",
                              "options": [
                                "Memory leaks",
                                "Faster execution",
                                "Data deletion",
                                "Global access"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "Why use a closure with an object?",
                              "options": [
                                "Speed",
                                "Data privacy",
                                "Public access",
                                "Error handling"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What happens to a closed-over array?",
                              "options": [
                                "Deleted after call",
                                "Persists in memory",
                                "Becomes global",
                                "Resets"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 25,
                          "resources": [
                            {
                              "title": "MDN Closures",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-14T00:39:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439110",
    "title": "JavaScript DOM Manipulation & Events",
    "slug": "js-dom-manipulation-events",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439111",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Learn to manipulate the DOM and handle user interactions with JavaScript events.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439112",
            "title": "JavaScript DOM and Events Essentials",
            "slug": "js-dom-events-essentials",
            "shortDescription": "A beginner-friendly course to master DOM manipulation and event handling in JavaScript.",
            "longDescription": "This course covers JavaScript techniques for interacting with the Document Object Model (DOM), including selecting elements, creating elements, managing classes, handling events, and understanding event propagation to create interactive webpages.",
            "tags": ["JavaScript", "DOM", "Events", "Beginner", "Frontend"],
            "thumbnail": "https://example.com/thumbnails/js-dom-events.jpg",
            "levels": [
              {
                "level": "Beginner",
                "overview": "This level teaches how to manipulate the DOM and handle user events using JavaScript, enabling dynamic and interactive web experiences.",
                "goals": [
                  "Learn to select and manipulate DOM elements with querySelector and createElement",
                  "Understand how to manage classes with classList",
                  "Master event handling with addEventListener",
                  "Understand event propagation and bubbling"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439113",
                    "title": "DOM Manipulation & Events",
                    "slug": "dom-manipulation-events",
                    "description": "Learn to interact with the DOM and handle user events in JavaScript.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439114",
                        "title": "Selecting and Creating DOM Elements",
                        "slug": "selecting-creating-dom-elements",
                        "description": "Learn to select and create DOM elements using querySelector and createElement.",
                        "order": 1,
                        "content": {
                          "explanation": "The Document Object Model (DOM) represents a webpage as a tree of objects, allowing JavaScript to manipulate its structure, content, and styles. The `querySelector` method selects the first element matching a CSS selector, like `document.querySelector('.class')` for a class or `document.querySelector('#id')` for an ID. It’s versatile, supporting any valid CSS selector (e.g., `div p` for nested elements). The `querySelectorAll` method returns a NodeList of all matching elements, iterable with loops or array methods. The `createElement` method creates new DOM elements, like `document.createElement('div')`, which can be customized with attributes or content before being added to the DOM using methods like `appendChild` or `append`. These tools are foundational for dynamic webpages, enabling you to update content or create elements on the fly. Beginners should practice selecting specific elements and creating structured content, ensuring proper DOM updates to avoid errors like appending to null elements. Always check if selected elements exist to prevent runtime errors.",
                          "examples": [
                            "let heading = document.querySelector('h1');\nheading.textContent = 'Updated Heading';",
                            "let div = document.createElement('div');\ndiv.textContent = 'New Div';\ndocument.body.appendChild(div);"
                          ],
                          "realWorldApplication": "Used to dynamically update webpage content, like displaying user data or generating new form fields.",
                          "expertInsights": "Use specific selectors with querySelector to improve performance, and cache selections in variables to avoid repeated DOM queries.",
                          "commonMistakes": [
                            "Using querySelector on non-existent elements, causing null errors",
                            "Forgetting to append created elements to the DOM",
                            "Overusing querySelectorAll without converting NodeList to array for method chaining"
                          ],
                          "exercises": [
                            {
                              "title": "Create and Append an Element",
                              "prompt": "Write JavaScript to create a paragraph element with text 'Hello, DOM!' and append it to the body.",
                              "difficulty": "easy",
                              "hints": [
                                "Use document.createElement('p')",
                                "Set textContent and appendChild"
                              ],
                              "solution": "<script>\n  let para = document.createElement('p');\n  para.textContent = 'Hello, DOM!';\n  document.body.appendChild(para);\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does querySelector return?",
                              "options": [
                                "All matching elements",
                                "First matching element",
                                "NodeList",
                                "Array"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What creates a new DOM element?",
                              "options": [
                                "querySelector",
                                "createElement",
                                "appendChild",
                                "getElementById"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "How do you add an element to the DOM?",
                              "options": [
                                "appendChild",
                                "textContent",
                                "querySelector",
                                "classList"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 15,
                          "resources": [
                            {
                              "title": "MDN DOM Introduction",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction",
                              "type": "article"
                            },
                            {
                              "title": "DOM Manipulation Video",
                              "url": "https://www.youtube.com/watch?v=example-dom-video",
                              "type": "video"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439115",
                        "title": "Managing Classes with classList",
                        "slug": "managing-classes-classlist",
                        "description": "Learn to manipulate element classes using the classList API.",
                        "order": 2,
                        "content": {
                          "explanation": "The `classList` property is a DOM API for managing an element’s CSS classes without directly manipulating the `className` string, which can be error-prone. It provides methods like `add` to apply a class, `remove` to delete one, `toggle` to add or remove based on presence, and `contains` to check if a class exists. For example, `element.classList.add('active')` adds the 'active' class, while `element.classList.toggle('hidden')` toggles visibility. This API is safer than setting `className`, as it avoids overwriting existing classes. It’s commonly used for dynamic styling, like highlighting a selected item or showing/hiding elements. Beginners should practice toggling classes for interactive effects and check for class existence before modifications. The `classList` methods are chainable and work seamlessly with CSS, making them essential for responsive, event-driven interfaces. Be cautious of typos in class names, as `classList` doesn’t validate against defined CSS rules.",
                          "examples": [
                            "let btn = document.querySelector('.btn');\nbtn.classList.add('active');\nconsole.log(btn.classList.contains('active')); // true",
                            "let menu = document.querySelector('#menu');\nmenu.classList.toggle('hidden'); // Toggles hidden class"
                          ],
                          "realWorldApplication": "Used to toggle navigation menus, highlight active tabs, or apply conditional styles in web apps.",
                          "expertInsights": "Use classList over className for safer class manipulation, and combine with CSS transitions for smooth effects.",
                          "commonMistakes": [
                            "Using className instead of classList, overwriting classes",
                            "Misspelling class names in classList methods",
                            "Not checking contains before toggling, causing redundant operations"
                          ],
                          "exercises": [
                            {
                              "title": "Toggle a Class",
                              "prompt": "Write JavaScript to toggle the 'highlight' class on a div with class='box'.",
                              "difficulty": "easy",
                              "hints": [
                                "Use querySelector to select the div",
                                "Use classList.toggle"
                              ],
                              "solution": "<script>\n  let box = document.querySelector('.box');\n  box.classList.toggle('highlight');\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does classList.toggle do?",
                              "options": [
                                "Adds a class",
                                "Removes a class",
                                "Adds or removes a class",
                                "Checks a class"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "Which method checks if a class exists?",
                              "options": [
                                "add",
                                "remove",
                                "contains",
                                "toggle"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "Why use classList over className?",
                              "options": [
                                "Faster",
                                "Safer manipulation",
                                "Required",
                                "Simpler syntax"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Can classList.add apply multiple classes?",
                              "options": [
                                "No",
                                "Yes",
                                "Only one",
                                "Only with toggle"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN classList",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/API/Element/classList",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439116",
                        "title": "Event Handling with addEventListener",
                        "slug": "event-handling-addeventlistener",
                        "description": "Learn to handle user interactions using addEventListener.",
                        "order": 3,
                        "content": {
                          "explanation": "The `addEventListener` method attaches event handlers to DOM elements, enabling responses to user actions like clicks, keypresses, or mouseovers. It takes an event type (e.g., 'click'), a callback function, and optional options (e.g., { once: true } to run once). Unlike inline handlers (e.g., onclick), `addEventListener` allows multiple handlers for the same event and is more maintainable. The callback receives an event object with details like `event.target` (the element triggering the event). Events drive interactivity, such as submitting forms or toggling menus. Beginners should practice common events (click, input, submit) and ensure handlers are attached after the DOM loads (e.g., using 'DOMContentLoaded'). Be cautious of memory leaks by removing unused listeners with `removeEventListener`. Understanding event properties and preventing default behaviors (e.g., `event.preventDefault()` for forms) is key to building robust interactive features.",
                          "examples": [
                            "let btn = document.querySelector('.btn');\nbtn.addEventListener('click', () => console.log('Clicked!'));",
                            "document.querySelector('#input').addEventListener('input', e => console.log(e.target.value));"
                          ],
                          "realWorldApplication": "Used for button clicks, form submissions, or real-time input validation in web applications.",
                          "expertInsights": "Use event delegation for dynamic elements, and always clean up listeners in long-running apps to prevent memory issues.",
                          "commonMistakes": [
                            "Attaching listeners before DOM elements exist",
                            "Not removing unused listeners, causing memory leaks",
                            "Using inline event handlers instead of addEventListener"
                          ],
                          "exercises": [
                            {
                              "title": "Add a Click Handler",
                              "prompt": "Write JavaScript to add a click event listener to a button with class='btn' that logs 'Button clicked!'.",
                              "difficulty": "easy",
                              "hints": [
                                "Use querySelector for the button",
                                "Use addEventListener with 'click'"
                              ],
                              "solution": "<script>\n  let btn = document.querySelector('.btn');\n  btn.addEventListener('click', () => console.log('Button clicked!'));\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does addEventListener do?",
                              "options": [
                                "Creates elements",
                                "Handles events",
                                "Styles elements",
                                "Selects elements"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is passed to the event callback?",
                              "options": [
                                "Element",
                                "Event object",
                                "String",
                                "Number"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "How do you remove an event listener?",
                              "options": [
                                "removeEventListener",
                                "deleteEvent",
                                "remove",
                                "detach"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN addEventListener",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439117",
                        "title": "Event Propagation and Bubbling",
                        "slug": "event-propagation-bubbling",
                        "description": "Understand event propagation and bubbling in the DOM.",
                        "order": 4,
                        "content": {
                          "explanation": "Event propagation describes how events travel through the DOM. In the bubbling phase, an event starts at the target element (e.g., a clicked button) and bubbles up through its ancestors (parent, grandparent, etc.) to the document. By default, `addEventListener` handles events in the bubbling phase, meaning parent elements can respond to events from their children. For example, clicking a button inside a div triggers the button’s handler, then the div’s, unless stopped. The `event.stopPropagation()` method prevents further bubbling, while `event.preventDefault()` stops default actions (e.g., form submission). Event delegation leverages bubbling by attaching a single listener to a parent to handle events from dynamic children, improving performance. Beginners should practice identifying event targets and using delegation for lists or dynamic content. Be cautious of stopping propagation unnecessarily, as it may break expected behaviors in complex interfaces.",
                          "examples": [
                            "<div id='parent'><button id='btn'>Click</button></div>\n<script>\n  document.querySelector('#parent').addEventListener('click', () => console.log('Parent clicked'));\n  document.querySelector('#btn').addEventListener('click', e => {\n    console.log('Button clicked');\n    e.stopPropagation();\n  });\n</script>",
                            "document.querySelector('form').addEventListener('submit', e => e.preventDefault());"
                          ],
                          "realWorldApplication": "Used in dropdown menus or dynamic lists where parent listeners handle child events efficiently.",
                          "expertInsights": "Use event delegation for scalability, but avoid overuse of stopPropagation to maintain predictable event flow.",
                          "commonMistakes": [
                            "Stopping propagation unintentionally, breaking parent handlers",
                            "Not using event.target for delegation",
                            "Confusing preventDefault with stopPropagation"
                          ],
                          "exercises": [
                            {
                              "title": "Interactive Profile Page",
                              "prompt": "Create an interactive profile page with a button to toggle a menu (class 'menu' with 'hidden' class) and an input to update a bio (id 'bio'). Use event listeners and classList.",
                              "difficulty": "medium",
                              "hints": [
                                "Use addEventListener for click and input events",
                                "Toggle 'hidden' class for menu",
                                "Update bio textContent with input value"
                              ],
                              "solution": "<script>\n  let menuBtn = document.querySelector('#menu-btn');\n  let menu = document.querySelector('.menu');\n  let bioInput = document.querySelector('#bio-input');\n  let bio = document.querySelector('#bio');\n  menuBtn.addEventListener('click', () => menu.classList.toggle('hidden'));\n  bioInput.addEventListener('input', e => bio.textContent = e.target.value);\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is event bubbling?",
                              "options": [
                                "Events stop at target",
                                "Events move up DOM",
                                "Events move down DOM",
                                "Events skip parents"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does event.stopPropagation do?",
                              "options": [
                                "Stops default action",
                                "Stops bubbling",
                                "Removes listener",
                                "Triggers event"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is event.target?",
                              "options": [
                                "Parent element",
                                "Clicked element",
                                "Document",
                                "Listener"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does event.preventDefault do?",
                              "options": [
                                "Stops bubbling",
                                "Stops default action",
                                "Removes class",
                                "Adds listener"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 25,
                          "resources": [
                            {
                              "title": "MDN Event Propagation",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/API/Event/Event_bubbling",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T02:50:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439120",
    "title": "JavaScript Forms, Validation & Small UI Behavior",
    "slug": "js-forms-validation-ui",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439121",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Learn to handle forms, validate user input, and create interactive UI behaviors with JavaScript.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439122",
            "title": "JavaScript Forms and Validation Essentials",
            "slug": "js-forms-validation-essentials",
            "shortDescription": "A beginner-friendly course to master form handling, validation, and UI interactions in JavaScript.",
            "longDescription": "This course covers JavaScript techniques for working with form fields, handling input events, preventing default actions, and implementing client-side validation patterns to create user-friendly, interactive forms.",
            "tags": ["JavaScript", "Forms", "Validation", "UI", "Beginner"],
            "thumbnail": "https://example.com/thumbnails/js-forms-validation.jpg",
            "levels": [
              {
                "level": "Beginner",
                "overview": "This level teaches how to manage forms, handle user inputs, validate data, and enhance UI behavior with JavaScript for interactive web experiences.",
                "goals": [
                  "Understand form fields and their properties",
                  "Learn to handle input events for real-time interaction",
                  "Master preventing default form actions",
                  "Implement basic client-side validation with error messaging"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439123",
                    "title": "Forms, Validation & Small UI Behavior",
                    "slug": "forms-validation-ui",
                    "description": "Learn to manage forms, validate input, and create responsive UI behaviors.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439124",
                        "title": "Working with Form Fields",
                        "slug": "working-with-form-fields",
                        "description": "Understand form fields and their properties for user input.",
                        "order": 1,
                        "content": {
                          "explanation": "HTML forms collect user input through elements like `<input>`, `<textarea>`, and `<select>`, which are essential for interactive web applications. JavaScript accesses these fields via the DOM, using methods like `document.querySelector('input')` to select elements. Each form field has properties such as `value` (user-entered data), `type` (e.g., text, email), `name` (for form submission), and `required` (enforces input). The `value` property gets or sets the field’s content, enabling dynamic updates. Other properties, like `disabled` or `placeholder`, enhance usability. For example, you can retrieve a user’s input with `input.value` or set a default with `input.value = 'Default'`. Forms are wrapped in `<form>` tags, which group fields for submission. Beginners should practice selecting fields, accessing their values, and updating them dynamically, ensuring proper selectors and handling edge cases like empty inputs. Understanding form fields is the foundation for validation and interactivity, as they bridge user input with JavaScript logic.",
                          "examples": [
                            "<form><input type='text' id='name' value='John'></form>\n<script>\n  let input = document.querySelector('#name');\n  console.log(input.value); // 'John'\n  input.value = 'Jane';\n</script>",
                            "<form><textarea id='bio'>Default bio</textarea></form>\n<script>\n  let textarea = document.querySelector('#bio');\n  console.log(textarea.value); // 'Default bio'\n</script>"
                          ],
                          "realWorldApplication": "Forms are used in login pages, contact forms, and surveys to collect and process user data dynamically.",
                          "expertInsights": "Use specific selectors for form fields and cache them in variables to avoid repeated DOM queries for better performance.",
                          "commonMistakes": [
                            "Selecting non-existent fields, causing null errors",
                            "Not handling empty or invalid input values",
                            "Overlooking accessibility attributes like aria-label"
                          ],
                          "exercises": [
                            {
                              "title": "Access Form Field Value",
                              "prompt": "Write JavaScript to select an input with id='email' and log its value.",
                              "difficulty": "easy",
                              "hints": [
                                "Use querySelector with #id",
                                "Access the value property"
                              ],
                              "solution": "<script>\n  let emailInput = document.querySelector('#email');\n  console.log(emailInput.value);\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What property gets an input’s content?",
                              "options": [
                                "text",
                                "value",
                                "content",
                                "innerHTML"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Which element wraps form fields?",
                              "options": ["div", "form", "section", "input"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does the 'required' attribute do?",
                              "options": [
                                "Disables input",
                                "Enforces input",
                                "Hides input",
                                "Styles input"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 15,
                          "resources": [
                            {
                              "title": "MDN HTML Forms",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form",
                              "type": "article"
                            },
                            {
                              "title": "JavaScript Forms Video",
                              "url": "https://www.youtube.com/watch?v=example-forms-video",
                              "type": "video"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439125",
                        "title": "Handling Input Events",
                        "slug": "handling-input-events",
                        "description": "Learn to handle input events for real-time user interaction.",
                        "order": 2,
                        "content": {
                          "explanation": "Input events in JavaScript allow real-time responses to user actions in form fields, enhancing interactivity. The `input` event fires every time a field’s value changes (e.g., typing in a text input), while `change` fires when the value is committed (e.g., selecting a dropdown option). The `addEventListener` method attaches handlers to these events, with the callback receiving an event object containing details like `event.target.value`. For example, you can update a display as a user types or validate input instantly. Events like `focus` and `blur` manage field activation and deactivation, useful for showing hints or clearing errors. Beginners should focus on the `input` event for text fields and practice accessing `event.target` to manipulate form data dynamically. Be cautious of performance with frequent events; debounce heavy operations if needed. Input events are critical for creating responsive forms, like live search bars or instant feedback in registration forms.",
                          "examples": [
                            "<input id='username'>\n<script>\n  let input = document.querySelector('#username');\n  input.addEventListener('input', e => console.log(e.target.value));\n</script>",
                            "<input id='email'>\n<script>\n  let email = document.querySelector('#email');\n  email.addEventListener('focus', () => console.log('Field focused'));\n</script>"
                          ],
                          "realWorldApplication": "Used for live form validation, auto-suggestions in search fields, or updating previews as users type.",
                          "expertInsights": "Use the input event for real-time feedback but consider throttling for resource-intensive tasks to optimize performance.",
                          "commonMistakes": [
                            "Using change instead of input for real-time updates",
                            "Not accessing event.target correctly",
                            "Attaching listeners before DOM elements load"
                          ],
                          "exercises": [
                            {
                              "title": "Real-Time Input Display",
                              "prompt": "Write JavaScript to listen for input events on a text field with id='name' and log the current value.",
                              "difficulty": "easy",
                              "hints": [
                                "Use addEventListener with 'input'",
                                "Access event.target.value"
                              ],
                              "solution": "<script>\n  let nameInput = document.querySelector('#name');\n  nameInput.addEventListener('input', e => console.log(e.target.value));\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "Which event fires on every value change?",
                              "options": ["change", "input", "focus", "blur"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does event.target represent?",
                              "options": [
                                "Parent element",
                                "Event type",
                                "Triggered element",
                                "Form"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "When does the focus event fire?",
                              "options": [
                                "On value change",
                                "On field selection",
                                "On form submit",
                                "On blur"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What event is best for real-time typing?",
                              "options": ["change", "input", "submit", "click"],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN Input Events",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/input_event",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439126",
                        "title": "Preventing Default Form Actions",
                        "slug": "preventing-default-form-actions",
                        "description": "Learn to prevent default form behaviors for custom handling.",
                        "order": 3,
                        "content": {
                          "explanation": "Forms in HTML have default behaviors, like submitting data to a server and reloading the page, triggered by the `submit` event. JavaScript can override this using `event.preventDefault()` in a submit event handler, allowing custom logic like client-side validation or AJAX submissions. For example, you can check if fields are valid before submitting, preventing page reloads. The `submit` event is attached to the `<form>` element, not individual inputs, and fires when a submit button is clicked or Enter is pressed in a field. Preventing default is crucial for single-page applications where navigation shouldn’t occur. Beginners should practice stopping submissions, processing form data, and providing feedback without refreshing. Be cautious to ensure alternative actions (e.g., showing errors) are implemented, as preventing default without follow-up can confuse users. This technique enhances user experience by keeping interactions seamless and controlled.",
                          "examples": [
                            "<form id='myForm'><input type='text'><button type='submit'>Submit</button></form>\n<script>\n  document.querySelector('#myForm').addEventListener('submit', e => {\n    e.preventDefault();\n    console.log('Form submission stopped');\n  });\n</script>",
                            "<form id='form'><input id='name' required></form>\n<script>\n  document.querySelector('#form').addEventListener('submit', e => {\n    e.preventDefault();\n    let name = document.querySelector('#name').value;\n    console.log('Name:', name);\n  });\n</script>"
                          ],
                          "realWorldApplication": "Used in login forms or contact forms to validate input before sending data or to handle submissions via AJAX.",
                          "expertInsights": "Always provide user feedback after preventing default to avoid confusion, and consider accessibility for keyboard users.",
                          "commonMistakes": [
                            "Forgetting preventDefault, causing page reloads",
                            "Attaching submit listeners to buttons instead of forms",
                            "Not handling form data after preventing submission"
                          ],
                          "exercises": [
                            {
                              "title": "Prevent Form Submission",
                              "prompt": "Write JavaScript to prevent default submission on a form with id='contact' and log 'Submission stopped'.",
                              "difficulty": "easy",
                              "hints": [
                                "Use addEventListener with 'submit'",
                                "Call event.preventDefault()"
                              ],
                              "solution": "<script>\n  let form = document.querySelector('#contact');\n  form.addEventListener('submit', e => {\n    e.preventDefault();\n    console.log('Submission stopped');\n  });\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does event.preventDefault do?",
                              "options": [
                                "Stops bubbling",
                                "Stops default action",
                                "Removes listener",
                                "Submits form"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Which event triggers form submission?",
                              "options": ["click", "input", "submit", "change"],
                              "correctOption": [2]
                            },
                            {
                              "question": "Where should submit listeners be attached?",
                              "options": ["Button", "Form", "Input", "Body"],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN Form Events",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/API/HTMLFormElement/submit_event",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439127",
                        "title": "Client-Side Validation Patterns",
                        "slug": "client-side-validation-patterns",
                        "description": "Learn basic client-side validation with inline error messages.",
                        "order": 4,
                        "content": {
                          "explanation": "Client-side validation checks user input in the browser before submission, improving user experience by providing immediate feedback. Common patterns include checking for required fields (value.length > 0), valid email formats (using regex like /^\\S+@\\S+\\.\\S+$/), or minimum lengths. Validation occurs in `submit` or input event handlers, often combined with preventDefault to stop invalid submissions. Inline error messages are displayed by creating elements (e.g., <span>) or updating existing ones, styled with CSS for visibility. For example, if an email field is empty, you can show a red error message below it. Beginners should validate on both input (real-time feedback) and submit (final check), ensuring messages are clear and accessible (e.g., using aria-live for screen readers). Be cautious of regex complexity and ensure fallback validation on the server, as client-side checks can be bypassed. This technique creates robust, user-friendly forms by catching errors early.",
                          "examples": [
                            "<form id='form'><input id='email' type='email'><span id='error'></span></form>\n<script>\n  let form = document.querySelector('#form');\n  let email = document.querySelector('#email');\n  let error = document.querySelector('#error');\n  form.addEventListener('submit', e => {\n    e.preventDefault();\n    if (!email.value.includes('@')) {\n      error.textContent = 'Invalid email';\n    } else {\n      error.textContent = '';\n    }\n  });\n</script>",
                            "<input id='name' required>\n<script>\n  let nameInput = document.querySelector('#name');\n  nameInput.addEventListener('input', () => {\n    nameInput.style.border = nameInput.value ? '1px solid green' : '1px solid red';\n  });\n</script>"
                          ],
                          "realWorldApplication": "Used in contact forms, sign-up pages, or checkout processes to ensure valid data before server submission.",
                          "expertInsights": "Combine HTML5 validation (e.g., required, pattern) with JavaScript for flexibility, and always validate server-side for security.",
                          "commonMistakes": [
                            "Relying solely on client-side validation, risking security",
                            "Not clearing error messages when input becomes valid",
                            "Using complex regex without testing edge cases"
                          ],
                          "exercises": [
                            {
                              "title": "Simple Contact Form with Validation",
                              "prompt": "Create a contact form with name and email inputs. Validate on submit: name must not be empty, email must include '@'. Show inline error messages in a span below each field.",
                              "difficulty": "medium",
                              "hints": [
                                "Use preventDefault in submit handler",
                                "Create spans for errors",
                                "Check value.length and includes('@')"
                              ],
                              "solution": "<form id='contact'>\n  <input id='name' type='text'><span id='name-error'></span>\n  <input id='email' type='email'><span id='email-error'></span>\n  <button type='submit'>Submit</button>\n</form>\n<script>\n  let form = document.querySelector('#contact');\n  let nameInput = document.querySelector('#name');\n  let emailInput = document.querySelector('#email');\n  let nameError = document.querySelector('#name-error');\n  let emailError = document.querySelector('#email-error');\n  form.addEventListener('submit', e => {\n    e.preventDefault();\n    nameError.textContent = nameInput.value ? '' : 'Name is required';\n    emailError.textContent = emailInput.value.includes('@') ? '' : 'Invalid email';\n  });\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "Why use client-side validation?",
                              "options": [
                                "Security",
                                "Immediate feedback",
                                "Server replacement",
                                "Styling"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What checks an email format?",
                              "options": [
                                "length",
                                "includes()",
                                "Regex",
                                "value"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "Where should error messages be displayed?",
                              "options": [
                                "Console",
                                "Inline",
                                "Alert",
                                "Footer"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What must complement client-side validation?",
                              "options": [
                                "CSS",
                                "Server-side validation",
                                "Loops",
                                "Events"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 25,
                          "resources": [
                            {
                              "title": "MDN Form Validation",
                              "url": "https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T03:10:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439130",
    "title": "Asynchronous JavaScript: Fetch & Promises",
    "slug": "js-async-fetch-promises",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439131",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Learn to handle asynchronous operations in JavaScript using Promises and the fetch API.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439132",
            "title": "Asynchronous JavaScript Essentials",
            "slug": "js-async-essentials",
            "shortDescription": "A beginner-friendly course to master asynchronous JavaScript with Promises, fetch, and async/await.",
            "longDescription": "This course covers asynchronous JavaScript concepts, including callbacks, Promises, the fetch API, async/await syntax, and error handling, enabling you to fetch and process data from APIs for dynamic web applications.",
            "tags": [
              "JavaScript",
              "Asynchronous",
              "Promises",
              "Fetch",
              "Beginner"
            ],
            "thumbnail": "https://example.com/thumbnails/js-async.jpg",
            "levels": [
              {
                "level": "Beginner",
                "overview": "This level teaches asynchronous JavaScript, focusing on callbacks, Promises, fetch API, async/await, and error handling to manage data fetching and dynamic updates.",
                "goals": [
                  "Understand callbacks and their role in asynchronous code",
                  "Learn to create and use Promises for async operations",
                  "Master the fetch API for retrieving data",
                  "Implement async/await and handle errors effectively"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439133",
                    "title": "Asynchronous JavaScript",
                    "slug": "asynchronous-javascript",
                    "description": "Learn to handle asynchronous operations with Promises, fetch, and async/await.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439134",
                        "title": "Callbacks",
                        "slug": "callbacks",
                        "description": "Understand callbacks for asynchronous programming.",
                        "order": 1,
                        "content": {
                          "explanation": "Callbacks are functions passed as arguments to other functions, executed when an asynchronous operation completes. They are a foundational concept for handling tasks like timers, API calls, or file loading in JavaScript, where operations don’t block execution. For example, `setTimeout(callback, 1000)` runs the callback after a delay. Callbacks allow non-blocking code, letting the program continue while waiting for results. However, nesting multiple callbacks (callback hell) can make code hard to read and maintain. A callback typically receives data or an error as arguments, depending on the operation’s outcome. Beginners should practice passing functions as arguments and handling results, while being cautious of deeply nested callbacks. Callbacks are still used in older APIs or simple tasks, but modern JavaScript favors Promises or async/await for complex async flows. Understanding callbacks is crucial, as they underpin other async patterns and are common in event-driven programming.",
                          "examples": [
                            "setTimeout(() => console.log('Delayed!'), 1000);",
                            "function fetchData(callback) {\n  setTimeout(() => callback('Data received'), 1000);\n}\nfetchData(data => console.log(data)); // 'Data received'"
                          ],
                          "realWorldApplication": "Callbacks are used in event listeners, timers, or older APIs to handle asynchronous responses like user clicks or data loading.",
                          "expertInsights": "Avoid callback hell by keeping functions shallow; use Promises or async/await for cleaner async code.",
                          "commonMistakes": [
                            "Nesting callbacks too deeply, reducing readability",
                            "Not handling errors in callbacks",
                            "Assuming synchronous execution for async callbacks"
                          ],
                          "exercises": [
                            {
                              "title": "Simple Callback",
                              "prompt": "Write a function that uses setTimeout to log 'Hello!' after 2 seconds using a callback.",
                              "difficulty": "easy",
                              "hints": [
                                "Use setTimeout with a callback",
                                "Set delay to 2000ms"
                              ],
                              "solution": "<script>\n  function delayedLog(callback) {\n    setTimeout(callback, 2000);\n  }\n  delayedLog(() => console.log('Hello!'));\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is a callback?",
                              "options": [
                                "A variable",
                                "A function passed as an argument",
                                "A loop",
                                "An object"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "When does a callback execute?",
                              "options": [
                                "Immediately",
                                "After async operation",
                                "Before calling function",
                                "On error"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is a common issue with callbacks?",
                              "options": [
                                "Callback hell",
                                "Too fast",
                                "Synchronous",
                                "No errors"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 15,
                          "resources": [
                            {
                              "title": "MDN Callbacks",
                              "url": "https://developer.mozilla.org/en-US/docs/Glossary/Callback_function",
                              "type": "article"
                            },
                            {
                              "title": "JavaScript Callbacks Video",
                              "url": "https://www.youtube.com/watch?v=example-callbacks-video",
                              "type": "video"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439135",
                        "title": "Promises",
                        "slug": "promises",
                        "description": "Learn to create and use Promises for asynchronous operations.",
                        "order": 2,
                        "content": {
                          "explanation": "Promises are objects representing the eventual completion (or failure) of an asynchronous operation, providing a cleaner alternative to callbacks. A Promise has three states: pending (initial), fulfilled (success), or rejected (failure). Created with `new Promise((resolve, reject) => {})`, it executes a callback with `resolve` for success or `reject` for errors. The `.then()` method handles fulfilled results, while `.catch()` handles rejections. Promises chain, allowing sequential async operations without nesting. For example, `promise.then(data => data).then(result => console.log(result))` processes data step-by-step. Promises simplify error handling and improve readability over callbacks. Beginners should practice creating Promises for tasks like timeouts or API calls and chaining `.then()` for multiple steps. Be cautious of unhandled rejections, which can cause silent failures. Promises are widely used in modern APIs, making them essential for fetching data or handling async logic in web applications.",
                          "examples": [
                            "let promise = new Promise((resolve, reject) => {\n  setTimeout(() => resolve('Success!'), 1000);\n});\npromise.then(data => console.log(data)); // 'Success!'",
                            "let errorPromise = new Promise((resolve, reject) => {\n  setTimeout(() => reject('Failed!'), 1000);\n});\nerrorPromise.catch(err => console.log(err)); // 'Failed!'"
                          ],
                          "realWorldApplication": "Promises are used in APIs like fetch to handle HTTP requests or in async workflows like loading user data.",
                          "expertInsights": "Always handle rejections with .catch() and use Promise.all for parallel async tasks to optimize performance.",
                          "commonMistakes": [
                            "Forgetting to handle rejections with .catch()",
                            "Nesting Promises instead of chaining",
                            "Not returning values in .then() for chaining"
                          ],
                          "exercises": [
                            {
                              "title": "Create a Promise",
                              "prompt": "Write a Promise that resolves with 'Done!' after 1 second and logs the result.",
                              "difficulty": "easy",
                              "hints": [
                                "Use new Promise with setTimeout",
                                "Resolve with 'Done!'"
                              ],
                              "solution": "<script>\n  let promise = new Promise((resolve, reject) => {\n    setTimeout(() => resolve('Done!'), 1000);\n  });\n  promise.then(result => console.log(result));\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is a Promise’s initial state?",
                              "options": [
                                "Fulfilled",
                                "Rejected",
                                "Pending",
                                "Resolved"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "What method handles Promise errors?",
                              "options": ["then", "catch", "resolve", "reject"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does .then() return?",
                              "options": [
                                "String",
                                "New Promise",
                                "Number",
                                "Undefined"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Why use Promises over callbacks?",
                              "options": [
                                "Faster",
                                "Cleaner chaining",
                                "Synchronous",
                                "No errors"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN Promises",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439136",
                        "title": "Fetch API",
                        "slug": "fetch-api",
                        "description": "Learn to use the fetch API for retrieving data.",
                        "order": 3,
                        "content": {
                          "explanation": "The fetch API is a modern interface for making HTTP requests, like fetching JSON from a server, returning a Promise for easy async handling. The `fetch(url)` function initiates a request, resolving to a Response object with properties like `.json()` to parse JSON data. For example, `fetch('https://api.example.com/data').then(res => res.json())` retrieves and parses JSON. Fetch supports GET (default) and POST requests with options like `{ method: 'POST', body: JSON.stringify(data) }`. CORS (Cross-Origin Resource Sharing) governs cross-domain requests; APIs must allow your domain to avoid errors (e.g., blocked requests). Beginners should practice fetching from public APIs (e.g., JSONPlaceholder) and handling responses. Be aware of CORS restrictions: browsers block requests to different origins unless the server permits it via headers. Always check response status (e.g., `res.ok`) to ensure success. Fetch is essential for dynamic apps, enabling data retrieval for user interfaces like lists or profiles.",
                          "examples": [
                            "fetch('https://jsonplaceholder.typicode.com/posts')\n  .then(res => res.json())\n  .then(data => console.log(data));",
                            "fetch('https://jsonplaceholder.typicode.com/users')\n  .then(res => {\n    if (!res.ok) throw new Error('Failed');\n    return res.json();\n  })\n  .then(data => console.log(data));"
                          ],
                          "realWorldApplication": "Used to fetch user data, posts, or products in web apps like social media or e-commerce platforms.",
                          "expertInsights": "Check response status and handle CORS issues by ensuring APIs support your origin or use a proxy if needed.",
                          "commonMistakes": [
                            "Not parsing response with .json()",
                            "Ignoring response status, assuming success",
                            "Not handling CORS restrictions"
                          ],
                          "exercises": [
                            {
                              "title": "Fetch JSON Placeholder",
                              "prompt": "Write JavaScript to fetch posts from 'https://jsonplaceholder.typicode.com/posts' and log the titles. Explain CORS basics: browsers restrict cross-origin requests unless the server allows via headers.",
                              "difficulty": "medium",
                              "hints": [
                                "Use fetch and .json()",
                                "Map over data to get titles"
                              ],
                              "solution": "<script>\n  fetch('https://jsonplaceholder.typicode.com/posts')\n    .then(res => res.json())\n    .then(posts => posts.map(post => console.log(post.title)));\n  // CORS: Browsers block requests to different origins unless the server includes CORS headers (e.g., Access-Control-Allow-Origin) to permit access.\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does fetch return?",
                              "options": ["JSON", "Promise", "String", "Array"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What method parses JSON from a fetch response?",
                              "options": ["parse", "json", "text", "blob"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is CORS?",
                              "options": [
                                "A styling rule",
                                "Cross-origin restriction",
                                "A fetch method",
                                "An error type"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN Fetch API",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439137",
                        "title": "Async/Await and Error Handling",
                        "slug": "async-await-error-handling",
                        "description": "Learn async/await syntax and error handling for asynchronous code.",
                        "order": 4,
                        "content": {
                          "explanation": "Async/await is a modern syntax for handling Promises, making asynchronous code look synchronous and easier to read. An `async` function returns a Promise, and `await` pauses execution until the Promise resolves, used only inside async functions. For example, `async function getData() { let data = await fetch(url); }` waits for the fetch to complete. Error handling uses try/catch blocks: `try { await fetch(url); } catch (error) { console.error(error); }`. This catches network errors or rejections. Async/await simplifies chaining and error management compared to `.then()/.catch()`. Beginners should practice converting Promise-based code to async/await and always include try/catch for robustness. Be cautious of unhandled rejections and ensure async functions are called correctly. This pattern is widely used in modern web apps for fetching data or handling async workflows, providing clarity and maintainability in complex operations.",
                          "examples": [
                            "async function getData() {\n  try {\n    let res = await fetch('https://jsonplaceholder.typicode.com/posts');\n    let data = await res.json();\n    console.log(data);\n  } catch (error) {\n    console.error('Error:', error);\n  }\n}\ngetData();",
                            "async function checkStatus() {\n  let res = await fetch('https://jsonplaceholder.typicode.com/users');\n  if (!res.ok) throw new Error('Failed to fetch');\n  return await res.json();\n}\ncheckStatus().catch(err => console.error(err));"
                          ],
                          "realWorldApplication": "Used in single-page apps to fetch and display data, like user profiles or posts, with clear error feedback.",
                          "expertInsights": "Use async/await for readability but combine with Promise.all for parallel tasks to optimize performance.",
                          "commonMistakes": [
                            "Using await outside async functions",
                            "Not catching errors, leading to unhandled rejections",
                            "Mixing async/await with .then() unnecessarily"
                          ],
                          "exercises": [
                            {
                              "title": "Fetch and Render List",
                              "prompt": "Write an async function to fetch posts from 'https://jsonplaceholder.typicode.com/posts', render titles in a ul element, and handle errors. Explain CORS: browsers block cross-origin requests unless allowed by server headers.",
                              "difficulty": "medium",
                              "hints": [
                                "Use async/await with fetch",
                                "Create li elements for titles",
                                "Use try/catch for errors"
                              ],
                              "solution": "<ul id='post-list'></ul>\n<script>\n  async function renderPosts() {\n    try {\n      let res = await fetch('https://jsonplaceholder.typicode.com/posts');\n      if (!res.ok) throw new Error('Failed to fetch');\n      let posts = await res.json();\n      let ul = document.querySelector('#post-list');\n      posts.forEach(post => {\n        let li = document.createElement('li');\n        li.textContent = post.title;\n        ul.appendChild(li);\n      });\n    } catch (error) {\n      console.error('Error:', error);\n    }\n  }\n  renderPosts();\n  // CORS: Browsers restrict cross-origin requests; servers must send headers like Access-Control-Allow-Origin to allow access.\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does async return?",
                              "options": [
                                "String",
                                "Promise",
                                "Array",
                                "Object"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Where can await be used?",
                              "options": [
                                "Any function",
                                "Async function",
                                "Callback",
                                "Global scope"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "How do you handle errors in async/await?",
                              "options": [
                                ".then()",
                                "try/catch",
                                ".catch()",
                                "Both b and c"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What happens with unhandled async errors?",
                              "options": [
                                "Silent failure",
                                "Console log",
                                "App crash",
                                "Retry"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 25,
                          "resources": [
                            {
                              "title": "MDN Async/Await",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T03:30:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439140",
    "title": "ES6+ Modern JavaScript",
    "slug": "js-es6-modern",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439141",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Learn modern JavaScript features introduced in ES6 and beyond for cleaner, more efficient code.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439142",
            "title": "Modern JavaScript Essentials",
            "slug": "js-modern-essentials",
            "shortDescription": "A beginner-friendly course to master ES6+ features like destructuring, template literals, and modules.",
            "longDescription": "This course covers modern JavaScript (ES6+) features, including destructuring, template literals, spread/rest operators, modules (import/export), and an overview of classes, enabling you to write concise and modular code for web applications.",
            "tags": ["JavaScript", "ES6", "Modules", "Modern", "Beginner"],
            "thumbnail": "https://example.com/thumbnails/js-es6.jpg",
            "levels": [
              {
                "level": "Beginner",
                "overview": "This level introduces ES6+ JavaScript features, focusing on destructuring, template literals, spread/rest, modules, and classes to enhance code readability and organization.",
                "goals": [
                  "Learn to use destructuring for arrays and objects",
                  "Master template literals for dynamic strings",
                  "Understand spread/rest operators for flexible data handling",
                  "Implement modules and classes for modular code"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439143",
                    "title": "ES6+ Modern JavaScript",
                    "slug": "es6-modern-javascript",
                    "description": "Learn modern JavaScript features to write cleaner, more efficient code.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439144",
                        "title": "Destructuring Arrays and Objects",
                        "slug": "destructuring-arrays-objects",
                        "description": "Learn to destructure arrays and objects for concise variable assignment.",
                        "order": 1,
                        "content": {
                          "explanation": "Destructuring is an ES6 feature that allows unpacking values from arrays or objects into distinct variables, making code more concise and readable. For arrays, you assign elements to variables by their position, like `const [a, b] = [1, 2];`. For objects, you use property names, like `const { name, age } = { name: 'Alice', age: 25 };`. Destructuring supports defaults (`const { name = 'Unknown' } = obj;`), renaming (`const { name: userName } = obj;`), and nested structures (`const { address: { city } } = user;`). It’s commonly used to extract data from function parameters, API responses, or arrays. Beginners should practice destructuring in function arguments and avoid common errors like missing properties or incorrect syntax. Destructuring reduces boilerplate, making code cleaner, but requires understanding the source data structure to avoid undefined values or errors.",
                          "examples": [
                            "const [first, second] = [1, 2, 3];\nconsole.log(first, second); // 1, 2",
                            "const { name, age } = { name: 'Bob', age: 30 };\nconsole.log(name, age); // 'Bob', 30"
                          ],
                          "realWorldApplication": "Used to extract data from API responses (e.g., user objects) or simplify function parameters in web apps.",
                          "expertInsights": "Use destructuring in function parameters for clarity, but provide defaults to handle missing properties safely.",
                          "commonMistakes": [
                            "Destructuring non-existent properties, causing undefined errors",
                            "Using incorrect syntax, like missing brackets or braces",
                            "Overcomplicating nested destructuring, reducing readability"
                          ],
                          "exercises": [
                            {
                              "title": "Destructure an Object",
                              "prompt": "Write JavaScript to destructure the name and email from an object { name: 'Alice', email: 'alice@example.com' } and log them.",
                              "difficulty": "easy",
                              "hints": [
                                "Use curly braces for object destructuring",
                                "Log the variables"
                              ],
                              "solution": "<script>\n  const user = { name: 'Alice', email: 'alice@example.com' };\n  const { name, email } = user;\n  console.log(name, email);\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does array destructuring use?",
                              "options": [
                                "Curly braces",
                                "Square brackets",
                                "Parentheses",
                                "Quotes"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What happens if a destructured property is missing?",
                              "options": ["Error", "undefined", "null", "0"],
                              "correctOption": [1]
                            },
                            {
                              "question": "How do you set a default in destructuring?",
                              "options": [
                                "name: default",
                                "name = default",
                                "default: name",
                                "name => default"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 15,
                          "resources": [
                            {
                              "title": "MDN Destructuring",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment",
                              "type": "article"
                            },
                            {
                              "title": "ES6 Destructuring Video",
                              "url": "https://www.youtube.com/watch?v=example-destructuring-video",
                              "type": "video"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439145",
                        "title": "Template Literals",
                        "slug": "template-literals",
                        "description": "Learn to use template literals for dynamic string creation.",
                        "order": 2,
                        "content": {
                          "explanation": "Template literals, introduced in ES6, are strings enclosed in backticks (`) that support embedded expressions and multi-line text. Expressions are included with `${expression}`, like `Hello, ${name}!`. Unlike regular strings, they allow complex string building without concatenation, improving readability. For example, you can embed variables, calculations, or function calls directly. Multi-line strings don’t require \n, making HTML or long text easier to write. Template literals also support tagged templates, where a function processes the string, though this is advanced. Beginners should practice using template literals for dynamic content, like generating HTML or user messages. Be cautious of unescaped user input to prevent security issues (e.g., XSS). Template literals are widely used in modern JavaScript for rendering UI elements, logging formatted data, or constructing API payloads, making them a key tool for clean, expressive code.",
                          "examples": [
                            "const name = 'Alice';\nconsole.log(`Hello, ${name}!`); // 'Hello, Alice!'",
                            "const a = 5, b = 10;\nconsole.log(`${a} + ${b} = ${a + b}`); // '5 + 10 = 15'"
                          ],
                          "realWorldApplication": "Used in React components for dynamic HTML, logging formatted messages, or building API request bodies.",
                          "expertInsights": "Use template literals for all string interpolation, but sanitize user input to prevent injection attacks.",
                          "commonMistakes": [
                            "Using single/double quotes instead of backticks",
                            "Not wrapping expressions in ${}",
                            "Overusing concatenation instead of template literals"
                          ],
                          "exercises": [
                            {
                              "title": "Create a Template Literal",
                              "prompt": "Write a template literal to create a greeting with a variable name and age, like 'Hello, Alice! You are 25.'",
                              "difficulty": "easy",
                              "hints": [
                                "Use backticks and ${}",
                                "Include variables in the string"
                              ],
                              "solution": "<script>\n  const name = 'Alice';\n  const age = 25;\n  console.log(`Hello, ${name}! You are ${age}.`);\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What encloses a template literal?",
                              "options": [
                                "Quotes",
                                "Backticks",
                                "Brackets",
                                "Parentheses"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "How do you embed an expression?",
                              "options": ["#{}", "${}", "{}", "[]"],
                              "correctOption": [1]
                            },
                            {
                              "question": "Can template literals span multiple lines?",
                              "options": [
                                "No",
                                "Yes",
                                "Only with \n",
                                "Only in functions"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What’s a benefit of template literals?",
                              "options": [
                                "Faster",
                                "Cleaner strings",
                                "More secure",
                                "No variables"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 15,
                          "resources": [
                            {
                              "title": "MDN Template Literals",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439146",
                        "title": "Spread and Rest Operators",
                        "slug": "spread-rest-operators",
                        "description": "Learn to use spread and rest operators for flexible data handling.",
                        "order": 3,
                        "content": {
                          "explanation": "The spread (`...`) and rest operators, introduced in ES6, use the same syntax but serve different purposes. Spread expands elements, like copying arrays (`[...arr]`) or merging objects (`{ ...obj1, ...obj2 }`). It’s useful for cloning, combining arrays, or passing arguments, like `Math.max(...numbers)`. Rest collects remaining elements into a single variable, used in function parameters (`function sum(...nums)`) or destructuring (`const [first, ...rest] = arr;`). Rest simplifies handling variable-length arguments or extracting parts of arrays/objects. For example, spread can duplicate an array without mutating it, while rest captures all arguments in a function. Beginners should practice using spread for copying and rest for flexible parameters, ensuring not to confuse their roles. These operators enhance code flexibility and are common in modern frameworks for state management or data manipulation.",
                          "examples": [
                            "const arr1 = [1, 2];\nconst arr2 = [...arr1, 3, 4]; // [1, 2, 3, 4]\nconsole.log(arr2);",
                            "function sum(...numbers) {\n  return numbers.reduce((a, b) => a + b, 0);\n}\nconsole.log(sum(1, 2, 3)); // 6"
                          ],
                          "realWorldApplication": "Spread is used to merge state in React, while rest simplifies API functions with variable inputs.",
                          "expertInsights": "Use spread for immutable operations and rest for dynamic arguments, but avoid spreading large objects for performance.",
                          "commonMistakes": [
                            "Confusing spread and rest purposes",
                            "Using spread on non-iterables, causing errors",
                            "Overusing spread, impacting memory with large data"
                          ],
                          "exercises": [
                            {
                              "title": "Use Spread and Rest",
                              "prompt": "Write a function that uses rest to collect numbers and returns their sum, then use spread to pass an array to it.",
                              "difficulty": "medium",
                              "hints": [
                                "Use ... in function parameters for rest",
                                "Use ... to spread an array"
                              ],
                              "solution": "<script>\n  function sum(...numbers) {\n    return numbers.reduce((a, b) => a + b, 0);\n  }\n  const nums = [1, 2, 3];\n  console.log(sum(...nums)); // 6\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does spread do?",
                              "options": [
                                "Collects elements",
                                "Expands elements",
                                "Deletes elements",
                                "Loops elements"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Where is rest used?",
                              "options": [
                                "Array copying",
                                "Function parameters",
                                "Object merging",
                                "String splitting"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Can spread be used on objects?",
                              "options": [
                                "No",
                                "Yes",
                                "Only arrays",
                                "Only strings"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN Spread and Rest",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439147",
                        "title": "Modules and Classes",
                        "slug": "modules-and-classes",
                        "description": "Learn to use ES6 modules and classes for modular code.",
                        "order": 4,
                        "content": {
                          "explanation": "ES6 modules organize code into reusable files using `import` and `export`. Default exports (`export default`) allow one main export per module, imported with any name (`import myFunc from './file.js'`). Named exports (`export function name() {}`) allow multiple exports, imported with exact names (`import { name } from './file.js'`). Modules promote encapsulation, reducing global scope pollution. Classes provide a syntax for object-oriented programming, defining blueprints with `class MyClass {}`. They include constructors (`constructor() {}`), methods, and properties. For example, `class Todo { constructor(task) { this.task = task; } }` creates reusable objects. Classes support inheritance via `extends`. Beginners should practice splitting code into modules and creating simple classes, ensuring proper file imports. Modules require a server or `type='module'` in HTML to work in browsers. These features are key for scalable, maintainable code in modern web development.",
                          "examples": [
                            "// todo.js\nexport default function addTodo(task) {\n  return { task, done: false };\n}\n// main.js\nimport addTodo from './todo.js';\nconsole.log(addTodo('Buy milk'));",
                            "class Todo {\n  constructor(task) {\n    this.task = task;\n  }\n  complete() {\n    return `${this.task} done`;\n  }\n}\nconst todo = new Todo('Read');\nconsole.log(todo.complete()); // 'Read done'"
                          ],
                          "realWorldApplication": "Modules organize large apps (e.g., React components), while classes model entities like users or tasks.",
                          "expertInsights": "Use modules for all projects and prefer composition over deep class inheritance for flexibility.",
                          "commonMistakes": [
                            "Forgetting type='module' in script tags",
                            "Using incorrect import/export syntax",
                            "Overusing classes for simple data structures"
                          ],
                          "exercises": [
                            {
                              "title": "Refactor to Modules and Modern Syntax",
                              "prompt": "Refactor a todo list script (e.g., from Module 9) to use ES6 modules, destructuring, template literals, and a class. Create a module to add todos and a main script to render them.",
                              "difficulty": "medium",
                              "hints": [
                                "Use export/import for functions",
                                "Use class for Todo",
                                "Apply destructuring and template literals"
                              ],
                              "solution": "<!-- index.html -->\n<script type='module' src='main.js'></script>\n<ul id='list'></ul>\n\n// todo.js\n<script type='module'>\n  export default class Todo {\n    constructor(task) {\n      this.task = task;\n      this.done = false;\n    }\n    complete() {\n      this.done = true;\n      return `${this.task} is done!`;\n    }\n  }\n  export function addTodo(task) {\n    return new Todo(task);\n  }\n</script>\n\n// main.js\n<script type='module'>\n  import Todo, { addTodo } from './todo.js';\n  const todos = [addTodo('Buy milk'), addTodo('Read book')];\n  const ul = document.querySelector('#list');\n  todos.forEach(({ task, done }) => {\n    const li = document.createElement('li');\n    li.textContent = `${task} - ${done ? 'Done' : 'Pending'}`;\n    ul.appendChild(li);\n  });\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does export default allow?",
                              "options": [
                                "Multiple exports",
                                "One main export",
                                "No exports",
                                "Global export"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What defines a class in ES6?",
                              "options": [
                                "function",
                                "class",
                                "object",
                                "module"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is needed for modules in HTML?",
                              "options": [
                                "type='module'",
                                "async",
                                "defer",
                                "src"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What does class inheritance use?",
                              "options": [
                                "extends",
                                "super",
                                "this",
                                "Both a and b"
                              ],
                              "correctOption": [3]
                            }
                          ],
                          "estimatedTime": 25,
                          "resources": [
                            {
                              "title": "MDN ES6 Modules",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules",
                              "type": "article"
                            },
                            {
                              "title": "MDN Classes",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T03:50:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439150",
    "title": "JavaScript Debugging, Tooling & Build Basics",
    "slug": "js-debugging-tooling",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439151",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Learn essential tools and techniques for debugging and building JavaScript applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439152",
            "title": "JavaScript Debugging and Tooling Essentials",
            "slug": "js-debugging-tooling-essentials",
            "shortDescription": "A beginner-friendly course to master debugging, linting, and build tools in JavaScript.",
            "longDescription": "This course covers debugging with Chrome DevTools, breakpoints, console techniques, linting with ESLint, and an introduction to bundlers like Vite and Webpack, along with source maps, to improve code quality and development workflows.",
            "tags": ["JavaScript", "Debugging", "Tooling", "Build", "Beginner"],
            "thumbnail": "https://example.com/thumbnails/js-debugging.jpg",
            "levels": [
              {
                "level": "Beginner",
                "overview": "This level introduces debugging and tooling techniques, including Chrome DevTools, linting with ESLint, and build concepts with bundlers and source maps.",
                "goals": [
                  "Learn to use Chrome DevTools for debugging",
                  "Understand breakpoints and console techniques",
                  "Implement basic linting with ESLint",
                  "Grasp bundlers and source maps for modern development"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439153",
                    "title": "Debugging, Tooling & Build Basics",
                    "slug": "debugging-tooling-build",
                    "description": "Learn to debug, lint, and build JavaScript applications effectively.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439154",
                        "title": "Chrome DevTools and Breakpoints",
                        "slug": "chrome-devtools-breakpoints",
                        "description": "Learn to use Chrome DevTools and breakpoints for debugging.",
                        "order": 1,
                        "content": {
                          "explanation": "Chrome DevTools is a powerful suite of tools built into the Chrome browser for debugging and optimizing web applications. Accessible via right-click 'Inspect' or F12, it includes panels like Elements (for DOM/CSS), Console (for logs/errors), and Sources (for debugging JavaScript). Breakpoints pause code execution at specific lines, allowing you to inspect variables, step through code, and identify issues. You can set breakpoints by clicking line numbers in the Sources panel or using `debugger;` in code. Types include line breakpoints, conditional breakpoints (pause only if a condition is true), and event listener breakpoints (e.g., for clicks). Debugging with breakpoints helps trace logic errors, like incorrect loops or null references. Beginners should practice setting breakpoints, stepping through code (step into/over), and inspecting variables in the Scope panel. Be cautious of browser-specific behaviors and ensure DevTools is used in development, not production, to avoid performance overhead.",
                          "examples": [
                            "// In script.js\nfunction buggyFunction() {\n  let x = null;\n  debugger; // Pauses here\n  console.log(x.length); // Causes error\n}\nbuggyFunction();",
                            "// Set breakpoint in DevTools on line below\nlet sum = 0;\nfor (let i = 0; i < 5; i++) {\n  sum += i;\n}\nconsole.log(sum);"
                          ],
                          "realWorldApplication": "Used to debug UI issues, trace API call failures, or inspect variable states in web apps.",
                          "expertInsights": "Use conditional breakpoints for specific cases and watch expressions to monitor variables dynamically.",
                          "commonMistakes": [
                            "Not enabling breakpoints before running code",
                            "Ignoring call stack to trace function calls",
                            "Forgetting to remove debugger; statements in production"
                          ],
                          "exercises": [
                            {
                              "title": "Set a Breakpoint",
                              "prompt": "Write a function with a loop that sums numbers 1-5. Add a debugger statement and suggest using DevTools to inspect the sum variable.",
                              "difficulty": "easy",
                              "hints": [
                                "Use debugger; inside the loop",
                                "Open DevTools Sources panel"
                              ],
                              "solution": "<script>\n  function sumNumbers() {\n    let sum = 0;\n    for (let i = 1; i <= 5; i++) {\n      debugger;\n      sum += i;\n    }\n    console.log(sum);\n  }\n  sumNumbers();\n  // In DevTools, set breakpoint on sum += i; to inspect sum.\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "How do you open Chrome DevTools?",
                              "options": ["F12", "F5", "Ctrl+C", "Alt+X"],
                              "correctOption": [0]
                            },
                            {
                              "question": "What pauses code execution?",
                              "options": [
                                "console.log",
                                "debugger",
                                "alert",
                                "throw"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Where are breakpoints set?",
                              "options": [
                                "Console",
                                "Elements",
                                "Sources",
                                "Network"
                              ],
                              "correctOption": [2]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "MDN Chrome DevTools",
                              "url": "https://developer.chrome.com/docs/devtools/",
                              "type": "article"
                            },
                            {
                              "title": "DevTools Debugging Video",
                              "url": "https://www.youtube.com/watch?v=example-devtools-video",
                              "type": "video"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439155",
                        "title": "Console Tricks",
                        "slug": "console-tricks",
                        "description": "Learn advanced console techniques for debugging.",
                        "order": 2,
                        "content": {
                          "explanation": "The Chrome DevTools Console is not just for logging; it offers powerful methods to debug and analyze code. Beyond `console.log()`, methods like `console.error()` highlight errors, `console.warn()` shows warnings, and `console.table()` displays arrays/objects in a tabular format. `console.group()` organizes logs into collapsible groups, useful for tracing nested operations. `console.assert(condition, message)` logs errors if a condition is false, aiding quick checks. For example, `console.table(users)` makes object arrays readable, and `console.time('label')`/`console.timeEnd('label')` measures execution time. Beginners should practice these methods to log structured data, time operations, or group related logs. Be cautious of excessive logging in production, as it can slow performance. Console tricks enhance debugging by providing clear, organized output, making it easier to diagnose issues in loops, API responses, or DOM interactions.",
                          "examples": [
                            "console.table([{ name: 'Alice', age: 25 }, { name: 'Bob', age: 30 }]); // Displays table",
                            "console.time('loop');\nfor (let i = 0; i < 1000; i++) {}\nconsole.timeEnd('loop'); // Logs time taken"
                          ],
                          "realWorldApplication": "Used to log API data, measure performance, or group event logs in complex web apps.",
                          "expertInsights": "Use console.table for structured data and console.time for performance profiling; avoid console logs in production.",
                          "commonMistakes": [
                            "Overusing console.log, cluttering output",
                            "Not using console.table for arrays/objects",
                            "Leaving console logs in production code"
                          ],
                          "exercises": [
                            {
                              "title": "Use Console Table",
                              "prompt": "Write JavaScript to log an array of objects [{id: 1, task: 'Buy milk'}, {id: 2, task: 'Read'}] using console.table.",
                              "difficulty": "easy",
                              "hints": [
                                "Create an array of objects",
                                "Use console.table()"
                              ],
                              "solution": "<script>\n  const todos = [{ id: 1, task: 'Buy milk' }, { id: 2, task: 'Read' }];\n  console.table(todos);\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What displays data as a table?",
                              "options": [
                                "console.log",
                                "console.table",
                                "console.error",
                                "console.group"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What measures execution time?",
                              "options": [
                                "console.log",
                                "console.time",
                                "console.assert",
                                "console.warn"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does console.assert do?",
                              "options": [
                                "Logs always",
                                "Logs if true",
                                "Logs if false",
                                "Groups logs"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "What organizes logs?",
                              "options": [
                                "console.table",
                                "console.group",
                                "console.time",
                                "console.error"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 15,
                          "resources": [
                            {
                              "title": "MDN Console API",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/API/Console",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439156",
                        "title": "Linting with ESLint",
                        "slug": "linting-eslint",
                        "description": "Learn to use ESLint for code quality and consistency.",
                        "order": 3,
                        "content": {
                          "explanation": "ESLint is a popular linting tool that analyzes JavaScript code for errors, style issues, and best practices. It enforces rules like consistent indentation, no unused variables, or preferring `const` over `var`. Installed via npm (`npm install eslint --save-dev`), it’s configured with a `.eslintrc.json` file specifying rules (e.g., `'no-unused-vars': 'error'`). Running `eslint script.js` checks code and reports issues. Linting improves code quality, catches bugs early, and ensures team consistency. Beginners should start with basic rules, like `no-undef` or `semi`, and integrate ESLint into editors (e.g., VS Code) for real-time feedback. Be cautious of overly strict rules that hinder productivity; customize rules to fit project needs. ESLint is widely used in professional development to maintain clean, maintainable codebases, especially in large teams or open-source projects.",
                          "examples": [
                            "// .eslintrc.json\n{\n  \"env\": { \"browser\": true, \"es2021\": true },\n  \"rules\": { \"no-unused-vars\": \"error\" }\n}",
                            "// script.js (will fail ESLint)\nlet unused = 5;\nconsole.log('Hello'); // ESLint error: 'unused' is defined but never used"
                          ],
                          "realWorldApplication": "Used in projects to enforce coding standards, catch errors, and improve maintainability in collaborative environments.",
                          "expertInsights": "Customize ESLint rules for your team and integrate with CI/CD pipelines for automated checks.",
                          "commonMistakes": [
                            "Not initializing ESLint with a config file",
                            "Ignoring ESLint warnings, missing potential bugs",
                            "Using incompatible rules for project environment"
                          ],
                          "exercises": [
                            {
                              "title": "Add an ESLint Rule",
                              "prompt": "Write a broken script with an unused variable. Provide an ESLint config to catch it with the 'no-unused-vars' rule.",
                              "difficulty": "medium",
                              "hints": [
                                "Create .eslintrc.json with no-unused-vars",
                                "Write a script with an unused variable"
                              ],
                              "solution": "// .eslintrc.json\n{\n  \"env\": { \"browser\": true, \"es2021\": true },\n  \"rules\": { \"no-unused-vars\": \"error\" }\n}\n\n// script.js\n<script>\n  let unused = 10; // ESLint will flag this\n  console.log('Test');\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does ESLint do?",
                              "options": [
                                "Compiles code",
                                "Checks code quality",
                                "Runs tests",
                                "Bundles files"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Where are ESLint rules defined?",
                              "options": [
                                ".eslintrc.json",
                                "package.json",
                                "script.js",
                                "index.html"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What does 'no-unused-vars' check?",
                              "options": [
                                "Syntax errors",
                                "Unused variables",
                                "Indentation",
                                "Comments"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 20,
                          "resources": [
                            {
                              "title": "ESLint Documentation",
                              "url": "https://eslint.org/docs/latest/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439157",
                        "title": "Bundlers and Source Maps",
                        "slug": "bundlers-source-maps",
                        "description": "Understand bundlers like Vite/Webpack and source maps.",
                        "order": 4,
                        "content": {
                          "explanation": "Bundlers like Vite and Webpack combine JavaScript, CSS, and other assets into optimized files for production. They resolve module dependencies (import/export), minify code, and handle assets like images. Vite is fast for development with hot module replacement, while Webpack is robust for complex builds. Source maps map minified production code back to original source files, enabling debugging in DevTools despite compression. For example, a source map lets you set breakpoints in your original `script.js` instead of a minified `bundle.js`. Bundlers use a config file (e.g., `vite.config.js`) to define entry points and plugins. Beginners should understand bundlers as tools to prepare code for browsers, using source maps to debug. Be cautious of complex configs; start with defaults from tools like Vite. These tools are essential for modern web apps, enabling modular code and efficient deployment.",
                          "examples": [
                            "// vite.config.js\n{\n  plugins: [],\n  build: { sourcemap: true }\n}",
                            "// main.js (bundled by Vite/Webpack)\nimport { greet } from './utils.js';\nconsole.log(greet('Alice')); // Source map maps to original file"
                          ],
                          "realWorldApplication": "Used in React/Vue apps to bundle code, optimize assets, and debug minified production builds.",
                          "expertInsights": "Use Vite for simple projects and Webpack for advanced needs; always enable source maps in development.",
                          "commonMistakes": [
                            "Not enabling source maps, complicating debugging",
                            "Misconfiguring bundler entry points",
                            "Ignoring bundle size, impacting performance"
                          ],
                          "exercises": [
                            {
                              "title": "Debug a Broken Script",
                              "prompt": "Debug a script with a null error (e.g., accessing length of null). Add an ESLint rule for 'no-undef'. Suggest using DevTools breakpoints and a source map.",
                              "difficulty": "medium",
                              "hints": [
                                "Use debugger; to pause",
                                "Add no-undef in .eslintrc.json",
                                "Mention source maps for bundled code"
                              ],
                              "solution": "// .eslintrc.json\n{\n  \"env\": { \"browser\": true, \"es2021\": true },\n  \"rules\": { \"no-undef\": \"error\" }\n}\n\n// script.js\n<script>\n  let data = null;\n  debugger; // Set breakpoint here\n  console.log(data.length); // Error: Cannot read property 'length' of null\n  // Fix: Check if data exists, e.g., if (data) {}\n  // Use source maps in Vite/Webpack to debug original code.\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do bundlers do?",
                              "options": [
                                "Debug code",
                                "Combine assets",
                                "Run tests",
                                "Style pages"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What do source maps map?",
                              "options": [
                                "Original to minified code",
                                "CSS to JS",
                                "HTML to DOM",
                                "Errors to logs"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "Which is a popular bundler?",
                              "options": ["ESLint", "Vite", "Chrome", "Node"],
                              "correctOption": [1]
                            },
                            {
                              "question": "Why use source maps?",
                              "options": [
                                "Faster builds",
                                "Debug minified code",
                                "Smaller bundles",
                                "Linting"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 25,
                          "resources": [
                            {
                              "title": "Vite Documentation",
                              "url": "https://vitejs.dev/guide/",
                              "type": "article"
                            },
                            {
                              "title": "Webpack Source Maps",
                              "url": "https://webpack.js.org/guides/development/#using-source-maps",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T04:10:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439160",
    "title": "JavaScript Mini Projects & Final Capstone",
    "slug": "js-mini-projects-capstone",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439161",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Combine HTML, CSS, and JavaScript to build practical projects and a capstone application.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439162",
            "title": "JavaScript Mini Projects and Capstone",
            "slug": "js-mini-projects-capstone",
            "shortDescription": "A beginner-friendly course to build small projects and a capstone using HTML, CSS, and JavaScript.",
            "longDescription": "This course guides you through building an interactive quiz app, a todo app with localStorage, and a portfolio page with deployment, culminating in a capstone project assessed for functionality, accessibility, responsiveness, and code quality.",
            "tags": ["JavaScript", "HTML", "CSS", "Projects", "Beginner"],
            "thumbnail": "https://example.com/thumbnails/js-projects.jpg",
            "levels": [
              {
                "level": "Beginner",
                "overview": "This level combines HTML, CSS, and JavaScript to create practical mini projects and a capstone, focusing on real-world application development and deployment.",
                "goals": [
                  "Build an interactive quiz app with dynamic scoring",
                  "Create a todo app with localStorage persistence",
                  "Develop and deploy a portfolio page",
                  "Complete a capstone project meeting functionality, accessibility, responsiveness, and code quality standards"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439163",
                    "title": "Mini Projects & Capstone",
                    "slug": "mini-projects-capstone",
                    "description": "Build practical projects and a capstone to apply HTML, CSS, and JavaScript skills.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439164",
                        "title": "Interactive Quiz App",
                        "slug": "interactive-quiz-app",
                        "description": "Build an interactive quiz app with dynamic scoring.",
                        "order": 1,
                        "content": {
                          "explanation": "An interactive quiz app combines HTML for structure, CSS for styling, and JavaScript for dynamic behavior. The app displays questions, accepts user input (e.g., radio buttons), calculates scores, and shows results. HTML creates a form with questions, CSS styles the layout (e.g., flexbox for alignment), and JavaScript handles events, validates answers, and updates the DOM. Use `querySelector` to access inputs, `addEventListener` for submit events, and arrays to store questions/answers. For example, an array of objects `{ question: '2+2?', answer: '4', options: ['2', '4', '6'] }` can drive the quiz. JavaScript calculates scores by comparing user inputs to correct answers. Beginners should focus on modular code (e.g., separate question rendering and scoring logic) and basic accessibility (e.g., `aria-label` for inputs). Test edge cases, like no selections, and use CSS for responsive design. This project teaches DOM manipulation, event handling, and user feedback in a real-world context.",
                          "examples": [
                            "<form id='quiz'><div>2+2? <input type='radio' name='q1' value='4'>4</div></form>\n<script>\n  document.querySelector('#quiz').addEventListener('submit', e => {\n    e.preventDefault();\n    let score = document.querySelector('input[name=\"q1\"]:checked')?.value === '4' ? 1 : 0;\n    console.log('Score:', score);\n  });\n</script>",
                            "<style>.quiz { display: flex; flex-direction: column; }</style>"
                          ],
                          "realWorldApplication": "Used in educational platforms, trivia games, or training apps to engage users with interactive content.",
                          "expertInsights": "Use arrays for questions, ensure accessibility with labels, and make the quiz responsive with CSS media queries.",
                          "commonMistakes": [
                            "Not preventing form default submission",
                            "Ignoring accessibility for inputs",
                            "Hardcoding questions instead of using data structures"
                          ],
                          "exercises": [
                            {
                              "title": "Build a Quiz App",
                              "prompt": "Create a quiz with 2 questions using HTML, CSS, and JavaScript. Calculate and display the score on submit.",
                              "difficulty": "medium",
                              "hints": [
                                "Use a form with radio inputs",
                                "Store questions in an array",
                                "Update DOM with score"
                              ],
                              "solution": "<form id='quiz'>\n  <div>1+1? <input type='radio' name='q1' value='2'>2</div>\n  <div>2+2? <input type='radio' name='q2' value='4'>4</div>\n  <button type='submit'>Submit</button>\n</form>\n<div id='result'></div>\n<style>.quiz { display: flex; flex-direction: column; gap: 10px; }</style>\n<script>\n  const quiz = document.querySelector('#quiz');\n  const result = document.querySelector('#result');\n  quiz.addEventListener('submit', e => {\n    e.preventDefault();\n    let score = 0;\n    if (document.querySelector('input[name=\"q1\"]:checked')?.value === '2') score++;\n    if (document.querySelector('input[name=\"q2\"]:checked')?.value === '4') score++;\n    result.textContent = `Score: ${score}/2`;\n  });\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What handles quiz form submission?",
                              "options": ["click", "submit", "input", "change"],
                              "correctOption": [1]
                            },
                            {
                              "question": "How do you ensure responsiveness?",
                              "options": [
                                "JavaScript",
                                "CSS media queries",
                                "HTML tags",
                                "Console"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What improves input accessibility?",
                              "options": [
                                "CSS",
                                "aria-label",
                                "Loops",
                                "Promises"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 25,
                          "resources": [
                            {
                              "title": "MDN Forms",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/HTML/Element/form",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439165",
                        "title": "Todo App with localStorage",
                        "slug": "todo-app-localstorage",
                        "description": "Build a todo app with localStorage for persistence.",
                        "order": 2,
                        "content": {
                          "explanation": "A todo app with localStorage combines HTML for input forms, CSS for styling, and JavaScript for managing tasks and persistence. Users add tasks via a form, which are stored in an array and saved to `localStorage` using `localStorage.setItem('todos', JSON.stringify(todos))`. On page load, tasks are retrieved with `JSON.parse(localStorage.getItem('todos'))`. JavaScript handles adding, deleting, and toggling tasks, updating both the DOM and localStorage. CSS ensures a clean, responsive layout (e.g., grid or flexbox). Use event listeners for form submission and button clicks, and array methods like `map` or `filter` for task management. Beginners should focus on data persistence, DOM updates, and basic validation (e.g., non-empty tasks). Ensure accessibility with proper labels and responsive design for mobile. This project teaches data storage, DOM manipulation, and state management in a practical, reusable app.",
                          "examples": [
                            "<form id='todo-form'><input id='task' required><button>Add</button></form>\n<ul id='todos'></ul>\n<script>\n  let todos = JSON.parse(localStorage.getItem('todos')) || [];\n  const form = document.querySelector('#todo-form');\n  form.addEventListener('submit', e => {\n    e.preventDefault();\n    todos.push({ task: e.target.task.value, done: false });\n    localStorage.setItem('todos', JSON.stringify(todos));\n  });\n</script>",
                            "<style>#todos { list-style: none; display: grid; gap: 5px; }</style>"
                          ],
                          "realWorldApplication": "Used in task management apps, note-taking tools, or personal productivity trackers.",
                          "expertInsights": "Use localStorage for simple persistence, but consider databases for larger apps; ensure responsive CSS and accessibility.",
                          "commonMistakes": [
                            "Not parsing/stringifying localStorage data",
                            "Forgetting to update localStorage after changes",
                            "Ignoring empty input validation"
                          ],
                          "exercises": [
                            {
                              "title": "Build a Todo App",
                              "prompt": "Create a todo app with a form to add tasks and a list to display them. Save tasks to localStorage and load them on page refresh.",
                              "difficulty": "medium",
                              "hints": [
                                "Use localStorage.setItem and getItem",
                                "Update DOM with tasks",
                                "Validate input"
                              ],
                              "solution": "<form id='todo-form'><input id='task' required><button>Add</button></form>\n<ul id='todos'></ul>\n<style>#todos { list-style: none; display: grid; gap: 5px; }</style>\n<script>\n  let todos = JSON.parse(localStorage.getItem('todos')) || [];\n  const form = document.querySelector('#todo-form');\n  const list = document.querySelector('#todos');\n  function renderTodos() {\n    list.innerHTML = '';\n    todos.forEach(todo => {\n      const li = document.createElement('li');\n      li.textContent = todo.task;\n      list.appendChild(li);\n    });\n  }\n  form.addEventListener('submit', e => {\n    e.preventDefault();\n    const task = e.target.task.value;\n    if (task) {\n      todos.push({ task, done: false });\n      localStorage.setItem('todos', JSON.stringify(todos));\n      renderTodos();\n      e.target.reset();\n    }\n  });\n  renderTodos();\n</script>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "How do you save to localStorage?",
                              "options": [
                                "setItem",
                                "saveItem",
                                "store",
                                "push"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What format does localStorage use?",
                              "options": ["JSON", "Array", "Object", "String"],
                              "correctOption": [3]
                            },
                            {
                              "question": "What ensures tasks persist?",
                              "options": [
                                "CSS",
                                "localStorage",
                                "DOM",
                                "Fetch"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "How do you load tasks on refresh?",
                              "options": [
                                "getItem",
                                "setItem",
                                "render",
                                "parse"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 30,
                          "resources": [
                            {
                              "title": "MDN localStorage",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439166",
                        "title": "Portfolio Page with Deployment",
                        "slug": "portfolio-page-deployment",
                        "description": "Build and deploy a simple portfolio page.",
                        "order": 3,
                        "content": {
                          "explanation": "A portfolio page showcases personal projects using HTML for structure, CSS for styling, and JavaScript for interactivity (e.g., toggling sections). HTML organizes sections like about, projects, and contact, styled with CSS (e.g., grid for project cards, media queries for responsiveness). JavaScript adds features like a toggleable menu or form submission feedback. Deployment involves hosting the site on platforms like GitHub Pages or Netlify, requiring a `git` repository and build process (e.g., pushing files to GitHub). Use modern ES6+ (e.g., template literals, modules) and ensure accessibility (e.g., `aria-label` for navigation). Beginners should focus on clean code, responsive design, and simple deployment steps. Test for mobile-friendliness and accessibility (e.g., keyboard navigation). Deployment makes the portfolio publicly accessible, teaching real-world hosting and project presentation skills.",
                          "examples": [
                            "<nav id='menu'><button id='toggle'>Menu</button></nav>\n<style>@media (max-width: 600px) { #menu { display: none; } }</style>\n<script>\n  document.querySelector('#toggle').addEventListener('click', () => {\n    document.querySelector('#menu').classList.toggle('active');\n  });\n</script>",
                            "<section class='projects'><div class='card'>Project 1</div></section>\n<style>.projects { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); }</style>"
                          ],
                          "realWorldApplication": "Used for personal branding, showcasing projects to employers, or hosting freelancer portfolios.",
                          "expertInsights": "Use a static site generator or bundler like Vite for deployment; prioritize accessibility and SEO.",
                          "commonMistakes": [
                            "Not testing responsiveness on mobile",
                            "Ignoring accessibility for navigation",
                            "Misconfiguring deployment settings"
                          ],
                          "exercises": [
                            {
                              "title": "Build and Deploy Portfolio",
                              "prompt": "Create a portfolio page with an about section and a toggleable project list. Style with CSS grid and deploy to GitHub Pages.",
                              "difficulty": "medium",
                              "hints": [
                                "Use grid for projects",
                                "Toggle with classList",
                                "Push to GitHub for deployment"
                              ],
                              "solution": "<section class='about'>About Me</section>\n<section class='projects' id='projects'><button id='toggle'>Toggle Projects</button><div class='card'>Project 1</div></section>\n<style>.projects { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); } .hidden { display: none; } @media (max-width: 600px) { .card { font-size: 14px; } }</style>\n<script>\n  document.querySelector('#toggle').addEventListener('click', () => {\n    document.querySelector('#projects').classList.toggle('hidden');\n  });\n</script>\n<!-- Deploy: Push to GitHub repository, enable GitHub Pages in settings -->"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What makes a portfolio responsive?",
                              "options": [
                                "JavaScript",
                                "Media queries",
                                "localStorage",
                                "Fetch"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What hosts a portfolio for free?",
                              "options": [
                                "GitHub Pages",
                                "ESLint",
                                "Vite",
                                "Console"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What improves navigation accessibility?",
                              "options": [
                                "CSS",
                                "aria-label",
                                "Loops",
                                "Promises"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 30,
                          "resources": [
                            {
                              "title": "GitHub Pages Guide",
                              "url": "https://docs.github.com/en/pages",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439167",
                        "title": "Capstone Project",
                        "slug": "capstone-project",
                        "description": "Build a capstone project assessed on functionality, accessibility, responsiveness, and code quality.",
                        "order": 4,
                        "content": {
                          "explanation": "The capstone project integrates HTML, CSS, and JavaScript to build a complete web application, such as an enhanced todo app, quiz, or portfolio, assessed on four criteria: functionality (core features work, e.g., add/delete tasks), accessibility (e.g., keyboard navigation, ARIA attributes), responsiveness (adapts to mobile/desktop via media queries), and code quality (clean, modular code with ES6+ and linting). For example, a todo app might use localStorage, ES6 modules, and a responsive grid layout. Use Chrome DevTools for debugging, ESLint for code quality, and a platform like Netlify for deployment. Beginners should plan features, test thoroughly, and follow a rubric: functionality (50%), accessibility (20%), responsiveness (20%), code quality (10%). Document code and ensure no errors. This project showcases full-stack front-end skills, preparing you for real-world development.",
                          "examples": [
                            "<form id='app'><input id='task' required><button>Add</button></form>\n<ul id='list'></ul>\n<style>#list { display: grid; gap: 10px; } @media (max-width: 600px) { #list { font-size: 14px; } }</style>\n<script type='module'>\n  import { addTodo } from './todo.js';\n  const list = document.querySelector('#list');\n  document.querySelector('#app').addEventListener('submit', e => {\n    e.preventDefault();\n    const li = document.createElement('li');\n    li.textContent = addTodo(e.target.task.value).task;\n    list.appendChild(li);\n  });\n</script>",
                            "// todo.js\nexport function addTodo(task) {\n  return { task, done: false };\n}"
                          ],
                          "realWorldApplication": "Capstones mirror real-world apps like task managers or portfolios, showcasing skills to employers.",
                          "expertInsights": "Plan features upfront, use ES6 modules, test accessibility, and deploy for a polished project.",
                          "commonMistakes": [
                            "Neglecting accessibility or responsiveness",
                            "Writing monolithic code instead of modular",
                            "Not testing edge cases or debugging"
                          ],
                          "exercises": [
                            {
                              "title": "Capstone: Enhanced Todo App",
                              "prompt": "Build a todo app with add/delete, localStorage, responsive CSS, and accessibility. Follow rubric: functionality (add/delete works), accessibility (ARIA labels), responsiveness (mobile-friendly), code quality (ES6, linted).",
                              "difficulty": "hard",
                              "hints": [
                                "Use ES6 modules",
                                "Add ARIA attributes",
                                "Test with DevTools"
                              ],
                              "solution": "<form id='todo-app' role='form' aria-label='Todo Form'>\n  <input id='task' required aria-label='Enter task'>\n  <button type='submit'>Add</button>\n</form>\n<ul id='todos' role='list'></ul>\n<style>#todos { display: grid; gap: 10px; } @media (max-width: 600px) { #todos { font-size: 14px; } }</style>\n<script type='module'>\n  import { addTodo, deleteTodo } from './todo.js';\n  let todos = JSON.parse(localStorage.getItem('todos')) || [];\n  const form = document.querySelector('#todo-app');\n  const list = document.querySelector('#todos');\n  function render() {\n    list.innerHTML = '';\n    todos.forEach((todo, i) => {\n      const li = document.createElement('li');\n      li.innerHTML = `${todo.task} <button aria-label='Delete ${todo.task}' onclick='deleteTodo(${i})'>X</button>`;\n      list.appendChild(li);\n    });\n    localStorage.setItem('todos', JSON.stringify(todos));\n  }\n  form.addEventListener('submit', e => {\n    e.preventDefault();\n    todos.push(addTodo(e.target.task.value));\n    render();\n    e.target.reset();\n  });\n  window.deleteTodo = i => {\n    todos = deleteTodo(todos, i);\n    render();\n  };\n  render();\n</script>\n\n// todo.js\n<script type='module'>\n  export function addTodo(task) {\n    return { task, done: false };\n  }\n  export function deleteTodo(todos, index) {\n    return todos.filter((_, i) => i !== index);\n  }\n</script>\n\n// .eslintrc.json\n{\n  \"env\": { \"browser\": true, \"es2021\": true },\n  \"rules\": { \"no-unused-vars\": \"error\" }\n}\n<!-- Rubric: Functionality (add/delete, localStorage: 50%), Accessibility (ARIA: 20%), Responsiveness (media queries: 20%), Code Quality (ES6, linted: 10%) -->"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does the capstone assess?",
                              "options": [
                                "Speed",
                                "Functionality",
                                "Colors",
                                "Fonts"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What improves accessibility?",
                              "options": [
                                "CSS",
                                "ARIA attributes",
                                "Loops",
                                "Fetch"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What ensures code quality?",
                              "options": [
                                "ESLint",
                                "localStorage",
                                "CSS",
                                "DOM"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What makes a project responsive?",
                              "options": [
                                "Media queries",
                                "Modules",
                                "Promises",
                                "Events"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 40,
                          "resources": [
                            {
                              "title": "MDN Web Accessibility",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/Accessibility",
                              "type": "article"
                            },
                            {
                              "title": "Netlify Deployment Guide",
                              "url": "https://docs.netlify.com/get-started/",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T04:30:00Z",
      "version": "1.0"
    }
  },

  {
    "learningModuleId": "507f1f77bcf86cd799439170",
    "title": "Modern Frontend Architecture",
    "slug": "modern-frontend-architecture",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439171",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Explore comprehensive full-stack development, integrating frontend and backend technologies for building robust web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439172",
            "title": "Modern Frontend Architecture (React Advanced + Patterns)",
            "slug": "modern-frontend-architecture-react",
            "shortDescription": "An intermediate course on advanced React patterns, component architecture, and performance optimization in full-stack contexts.",
            "longDescription": "This course dives into modern frontend architecture using React, covering component patterns, composition, performance optimization, SSR vs CSR, and accessibility, while considering full-stack integration points like API consumption and state management.",
            "tags": [
              "React",
              "Frontend",
              "Patterns",
              "Performance",
              "Intermediate"
            ],
            "thumbnail": "https://example.com/thumbnails/react-advanced.jpg",
            "levels": [
              {
                "level": "Intermediate",
                "overview": "This intermediate level focuses on advanced React techniques for building scalable, performant frontend architectures in full-stack applications.",
                "goals": [
                  "Master component composition and patterns for reusable UI",
                  "Optimize render performance and handle large datasets",
                  "Implement advanced state management patterns",
                  "Understand code splitting, lazy loading, and server-side rendering basics",
                  "Apply accessibility patterns at scale in React apps"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439173",
                    "title": "Modern Frontend Architecture",
                    "slug": "modern-frontend-architecture",
                    "description": "Explore advanced patterns and optimizations in React for full-stack development.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439174",
                        "title": "Component Composition & Compound Components",
                        "slug": "component-composition-compound",
                        "description": "Learn to compose components and build compound components for reusable UI.",
                        "order": 1,
                        "content": {
                          "explanation": "Component composition in React involves combining smaller components to build complex UIs, promoting reusability and separation of concerns. Compound components are a pattern where multiple related components work together, sharing state implicitly (e.g., via Context). For example, a Tabs component might include Tab and TabPanel sub-components that coordinate without props drilling. This pattern enhances flexibility, allowing users to arrange components as needed. In full-stack contexts, composition helps integrate backend data seamlessly, like rendering dynamic lists from APIs. Beginners at intermediate level should practice building compound components, using React.Children or Context for state sharing, and ensuring props are intuitive. Be cautious of over-engineering; start simple and add complexity as needed. This technique is crucial for scalable UIs, reducing redundancy and improving maintainability in large applications.",
                          "examples": [
                            "const Tabs = ({ children }) => {\n  const [active, setActive] = React.useState(0);\n  return <div>{React.Children.map(children, (child, i) => React.cloneElement(child, { active: i === active, setActive }))}</div>;\n};\nconst Tab = ({ label, active, setActive }) => <button onClick={setActive}>{label}</button>;"
                          ],
                          "realWorldApplication": "Used in UI libraries like Material-UI for components like Accordions or Tabs, integrating with backend data in full-stack apps.",
                          "expertInsights": "Use Context for implicit state sharing in compounds, but avoid deep nesting to maintain performance.",
                          "commonMistakes": [
                            "Overusing props drilling instead of Context",
                            "Not handling dynamic children counts",
                            "Forgetting to clone elements for prop injection"
                          ],
                          "exercises": [
                            {
                              "title": "Refactor Messy UI to Compound Components",
                              "prompt": "Refactor a flat component structure into a compound Accordion component with multiple panels.",
                              "difficulty": "medium",
                              "hints": [
                                "Use React.Context for state",
                                "Clone children to pass props"
                              ],
                              "solution": "const Accordion = ({ children }) => {\n  const [open, setOpen] = React.useState(null);\n  return React.Children.map(children, (child, i) => React.cloneElement(child, { isOpen: i === open, onToggle: () => setOpen(i === open ? null : i) }));\n};\nconst Panel = ({ title, isOpen, onToggle, children }) => (\n  <div>\n    <button onClick={onToggle}>{title}</button>\n    {isOpen && <div>{children}</div>}\n  </div>\n);"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is component composition?",
                              "options": [
                                "Combining components",
                                "Styling",
                                "State management",
                                "API calls"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What shares state in compound components?",
                              "options": [
                                "Props",
                                "Context",
                                "Redux",
                                "Local state"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Why use React.cloneElement?",
                              "options": [
                                "Copy elements",
                                "Inject props",
                                "Delete elements",
                                "Style"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "React Composition Patterns",
                              "url": "https://reactjs.org/docs/composition-vs-inheritance.html",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439175",
                        "title": "Render Performance",
                        "slug": "render-performance",
                        "description": "Optimize React render performance with memo, useMemo, and virtualization.",
                        "order": 2,
                        "content": {
                          "explanation": "Render performance in React involves minimizing unnecessary re-renders to improve app speed. `React.memo` wraps functional components to prevent re-renders if props are shallow-equal. `useMemo` caches expensive computations, recomputing only when dependencies change. Virtualization (e.g., react-window) renders only visible items in long lists, reducing DOM overhead. For example, in a full-stack app fetching large datasets, virtualization prevents lag. Measure performance with React Profiler in DevTools. Intermediate learners should profile apps, apply memoization judiciously (as it has memory cost), and use virtualization for lists >100 items. Be cautious of over-optimization, which can complicate code. These techniques are vital for scalable full-stack apps handling real-time data or large UIs.",
                          "examples": [
                            "const MemoComponent = React.memo(({ prop }) => <div>{prop}</div>);",
                            "const cachedValue = useMemo(() => expensiveCalc(data), [data]);\n<FixedSizeList height={300} itemCount={1000} itemSize={35}>...</FixedSizeList>"
                          ],
                          "realWorldApplication": "Used in dashboards with large data tables or infinite scrolling feeds in social apps.",
                          "expertInsights": "Profile before optimizing; use useCallback for memoized functions passed as props.",
                          "commonMistakes": [
                            "Memoizing everything, causing memory issues",
                            "Not updating dependencies in useMemo",
                            "Ignoring virtualization for long lists"
                          ],
                          "exercises": [
                            {
                              "title": "Add Virtualization to Long List",
                              "prompt": "Refactor a React list rendering 1000 items to use react-window for virtualization.",
                              "difficulty": "medium",
                              "hints": [
                                "Import FixedSizeList",
                                "Set height, itemCount, itemSize"
                              ],
                              "solution": "import { FixedSizeList } from 'react-window';\n<FixedSizeList height={400} itemCount={1000} itemSize={50} width={300}>\n  {({ index, style }) => <div style={style}>Item {index}</div>}\n</FixedSizeList>;"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does React.memo prevent?",
                              "options": [
                                "All re-renders",
                                "Unnecessary re-renders",
                                "State changes",
                                "Prop updates"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What caches computations?",
                              "options": [
                                "useEffect",
                                "useMemo",
                                "useState",
                                "memo"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does virtualization do?",
                              "options": [
                                "Renders all items",
                                "Renders visible items",
                                "Styles lists",
                                "Fetches data"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Where do you measure performance?",
                              "options": [
                                "Console",
                                "Profiler",
                                "Sources",
                                "Network"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "React Performance",
                              "url": "https://reactjs.org/docs/optimizing-performance.html",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439176",
                        "title": "Context, Render-Props and Custom Hooks Patterns",
                        "slug": "context-render-props-custom-hooks",
                        "description": "Explore advanced state management patterns in React.",
                        "order": 3,
                        "content": {
                          "explanation": "Context provides a way to pass data through the component tree without props drilling, using Provider and Consumer. Render-props is a pattern where a component's children are functions receiving shared state/logic. Custom hooks encapsulate reusable logic, like `useFetch` for data fetching. These patterns solve state management in full-stack apps, e.g., sharing user data via Context. For example, `useContext` simplifies accessing Context values. Intermediate learners should create custom hooks for common tasks and use render-props for flexible components. Be cautious of overusing Context for global state; prefer Redux for complex apps. These patterns enhance reusability and maintainability.",
                          "examples": [
                            "const MyContext = React.createContext();\n<MyContext.Provider value={value}><Child /></MyContext.Provider>;\nconst value = useContext(MyContext);",
                            "function CustomHookComponent() {\n  const data = useFetch('url');\n  return <div>{data}</div>;\n}"
                          ],
                          "realWorldApplication": "Used in apps for theme toggling (Context), data fetching (hooks), or dynamic rendering (render-props).",
                          "expertInsights": "Compose hooks for complex logic; use render-props for inversion of control.",
                          "commonMistakes": [
                            "Using Context for frequently updating state, causing re-renders",
                            "Not memoizing values in Context",
                            "Creating hooks with side effects outside useEffect"
                          ],
                          "exercises": [
                            {
                              "title": "Create a Custom Hook",
                              "prompt": "Write a custom hook useCounter that increments a count with a button.",
                              "difficulty": "medium",
                              "hints": [
                                "Use useState for count",
                                "Return count and increment function"
                              ],
                              "solution": "function useCounter() {\n  const [count, setCount] = React.useState(0);\n  return { count, increment: () => setCount(c => c + 1) };\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What avoids props drilling?",
                              "options": ["Hooks", "Context", "Props", "State"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is a render-prop?",
                              "options": [
                                "Function as child",
                                "Styled prop",
                                "State prop",
                                "Event prop"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What encapsulates logic?",
                              "options": [
                                "Context",
                                "Custom hooks",
                                "Render-props",
                                "Classes"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "React Context",
                              "url": "https://reactjs.org/docs/context.html",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439177",
                        "title": "Code Splitting, Lazy Loading, SSR/SSG Basics",
                        "slug": "code-splitting-lazy-ssr",
                        "description": "Learn code optimization and rendering strategies with Next.js.",
                        "order": 4,
                        "content": {
                          "explanation": "Code splitting divides app code into smaller bundles, loading only needed parts. Lazy loading defers component loading with `React.lazy` and `Suspense`. SSR (Server-Side Rendering) renders pages on the server for faster initial loads and SEO, while CSR (Client-Side Rendering) handles it in the browser. SSG (Static Site Generation) pre-renders pages at build time. Next.js simplifies these with `getServerSideProps` for SSR and `getStaticProps` for SSG. In full-stack, SSR/SSG integrates backend data at render time. Intermediate learners should use lazy for non-critical components and Next.js for hybrid rendering. Be cautious of hydration mismatches in SSR. These techniques improve load times and performance in production apps.",
                          "examples": [
                            "const LazyComponent = React.lazy(() => import('./Component'));\n<Suspense fallback={<div>Loading...</div>}><LazyComponent /></Suspense>",
                            "// Next.js page\nexport async function getServerSideProps() {\n  const data = await fetchData();\n  return { props: { data } };\n}"
                          ],
                          "realWorldApplication": "Used in e-commerce sites for fast loads (SSR/SSG) and apps with heavy components (lazy loading).",
                          "expertInsights": "Use dynamic imports for lazy loading; prefer SSG for static content and SSR for dynamic.",
                          "commonMistakes": [
                            "Not providing Suspense fallback",
                            "Hydration errors in SSR from mismatched HTML",
                            "Over-splitting code, increasing HTTP requests"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Lazy Loading",
                              "prompt": "Lazy load a component with Suspense in a React app.",
                              "difficulty": "medium",
                              "hints": [
                                "Use React.lazy and dynamic import",
                                "Wrap with Suspense"
                              ],
                              "solution": "const LazyComp = React.lazy(() => import('./Comp'));\n<Suspense fallback={<div>Load...</div>}><LazyComp /></Suspense>;"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does code splitting do?",
                              "options": [
                                "Merges code",
                                "Splits bundles",
                                "Styles code",
                                "Tests code"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is SSR?",
                              "options": [
                                "Client rendering",
                                "Server rendering",
                                "Static generation",
                                "Lazy loading"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What defers component loading?",
                              "options": [
                                "Suspense",
                                "React.lazy",
                                "getStaticProps",
                                "import"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is Next.js used for?",
                              "options": [
                                "SSR/SSG",
                                "Debugging",
                                "Linting",
                                "Bundling only"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "Next.js Docs",
                              "url": "https://nextjs.org/docs",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439178",
                        "title": "Accessibility at Scale",
                        "slug": "accessibility-scale",
                        "description": "Apply accessibility patterns in large React applications.",
                        "order": 5,
                        "content": {
                          "explanation": "Accessibility (A11y) ensures apps are usable by people with disabilities, using ARIA attributes, semantic HTML, and keyboard navigation. In React, use `role`, `aria-label`, and `aria-live` for dynamic content. Patterns include focus management (e.g., `useRef` for focusing elements), skip links for navigation, and screen reader-friendly forms. For scale, use libraries like react-aria or test with tools like Lighthouse. In full-stack, ensure backend data supports A11y (e.g., alt text for images). Intermediate learners should audit apps with WAVE or AXE, add ARIA to custom components, and test with screen readers. Be cautious of ARIA overuse, which can confuse users. A11y at scale improves inclusivity and SEO, making apps compliant with standards like WCAG.",
                          "examples": [
                            "<button aria-label='Close' onClick={handleClose}>X</button>",
                            "<div role='alert' aria-live='polite'>Error occurred</div>"
                          ],
                          "realWorldApplication": "Used in public-facing apps to meet legal requirements and reach wider audiences.",
                          "expertInsights": "Automate A11y tests; use semantic elements over ARIA when possible.",
                          "commonMistakes": [
                            "Using non-semantic elements without ARIA",
                            "Not managing focus in modals",
                            "Ignoring keyboard navigation"
                          ],
                          "exercises": [
                            {
                              "title": "Add A11y to Component",
                              "prompt": "Add ARIA attributes to a custom button component for accessibility.",
                              "difficulty": "easy",
                              "hints": [
                                "Use role='button'",
                                "Add aria-label if needed"
                              ],
                              "solution": "const CustomButton = ({ children, onClick }) => (\n  <div role='button' tabIndex={0} onClick={onClick} aria-label='Custom button'>\n    {children}\n  </div>\n);"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does ARIA stand for?",
                              "options": [
                                "Accessible Rich Internet Applications",
                                "Advanced React Integration Architecture",
                                "Automated Rendering Interface App",
                                "Accessibility Rules In Action"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What manages dynamic announcements?",
                              "options": [
                                "aria-label",
                                "aria-live",
                                "role",
                                "tabIndex"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What tool audits A11y?",
                              "options": [
                                "ESLint",
                                "Lighthouse",
                                "Webpack",
                                "Vite"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "React Accessibility",
                              "url": "https://reactjs.org/docs/accessibility.html",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T04:50:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439180",
    "title": "State Management & Data Flow",
    "slug": "state-management-and-data-flow",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439181",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master state management and data flow for scalable full-stack web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439182",
            "title": "State Management & Data Flow",
            "slug": "state-management-data-flow",
            "shortDescription": "An intermediate course on managing state and data flow in full-stack applications with modern tools.",
            "longDescription": "This course explores scalable state management in full-stack applications, covering local vs global state tradeoffs, modern libraries like Redux Toolkit, Zustand, and Jotai, server-state management with React Query and SWR, and advanced patterns like optimistic updates and cache invalidation.",
            "tags": [
              "React",
              "State Management",
              "Data Flow",
              "Full-Stack",
              "Intermediate"
            ],
            "thumbnail": "https://example.com/thumbnails/state-management.jpg",
            "levels": [
              {
                "level": "Intermediate",
                "overview": "This intermediate level focuses on managing state and data flow in full-stack applications, balancing local and global state, leveraging modern libraries, and optimizing server-state interactions.",
                "goals": [
                  "Understand tradeoffs between local and global state",
                  "Implement state management with Redux Toolkit, Zustand, or Jotai",
                  "Manage server-state with caching using React Query or SWR",
                  "Apply optimistic updates and cache invalidation for responsive UIs"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439183",
                    "title": "State Management & Data Flow",
                    "slug": "state-management-data-flow",
                    "description": "Learn to manage client and server state for scalable full-stack applications.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439184",
                        "title": "Local State vs Global State Tradeoffs",
                        "slug": "local-vs-global-state",
                        "description": "Understand the tradeoffs between local and global state in React applications.",
                        "order": 1,
                        "content": {
                          "explanation": "State management in React involves choosing between local state (managed with `useState` or `useReducer`) and global state (managed with Context or libraries like Redux). Local state is ideal for component-specific data, like form inputs, but becomes unwieldy with prop drilling across deep trees. Global state centralizes data for shared concerns, like user authentication, but can introduce complexity and performance overhead. In full-stack apps, local state suits isolated UI components, while global state handles shared data from backend APIs. Tradeoffs include simplicity (local) vs scalability (global), and performance (fewer re-renders with local) vs consistency (global). Intermediate learners should practice identifying when to use each, starting with `useState` for simple components and Context for small-scale global state. Be cautious of overusing global state, which can lead to unnecessary re-renders or debugging challenges. This understanding is critical for building maintainable full-stack apps.",
                          "examples": [
                            "// Local state\nconst Form = () => {\n  const [input, setInput] = React.useState('');\n  return <input value={input} onChange={e => setInput(e.target.value)} />;\n};",
                            "// Global state with Context\nconst UserContext = React.createContext();\nconst App = () => (\n  <UserContext.Provider value={{ user: 'Alice' }}>\n    <Child />\n  </UserContext.Provider>\n);"
                          ],
                          "realWorldApplication": "Local state for form inputs; global state for user sessions or app-wide settings in full-stack apps.",
                          "expertInsights": "Start with useState; scale to Context for small apps or libraries for complex state. Profile re-renders with React DevTools.",
                          "commonMistakes": [
                            "Using global state for component-specific data",
                            "Causing re-renders with poorly managed Context",
                            "Overcomplicating with global state when props suffice"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Local and Global State",
                              "prompt": "Create a form with local state for input and a Context to share a global theme toggle state.",
                              "difficulty": "medium",
                              "hints": [
                                "Use useState for form input",
                                "Use createContext and useContext for theme"
                              ],
                              "solution": "const ThemeContext = React.createContext();\nconst App = () => {\n  const [theme, setTheme] = React.useState('light');\n  return (\n    <ThemeContext.Provider value={{ theme, toggle: () => setTheme(theme === 'light' ? 'dark' : 'light') }}>\n      <Form />\n    </ThemeContext.Provider>\n  );\n};\nconst Form = () => {\n  const [input, setInput] = React.useState('');\n  const { theme } = React.useContext(ThemeContext);\n  return <input value={input} onChange={e => setInput(e.target.value)} style={{ background: theme === 'light' ? '#fff' : '#333' }} />;\n};"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is local state best for?",
                              "options": [
                                "App-wide data",
                                "Component-specific data",
                                "API data",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What problem does global state solve?",
                              "options": [
                                "Prop drilling",
                                "Re-rendering",
                                "Styling",
                                "Fetching"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What can global state cause?",
                              "options": [
                                "Faster renders",
                                "Unnecessary re-renders",
                                "Smaller bundles",
                                "No issues"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "React State Management",
                              "url": "https://reactjs.org/docs/state-and-lifecycle.html",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439185",
                        "title": "Redux Toolkit, Zustand, Jotai Comparison",
                        "slug": "redux-toolkit-zustand-jotai",
                        "description": "Compare and implement state management with modern libraries.",
                        "order": 2,
                        "content": {
                          "explanation": "Redux Toolkit, Zustand, and Jotai are modern libraries for global state management in React. Redux Toolkit simplifies Redux with utilities like `createSlice` for actions/reducers, ideal for complex apps with predictable state. Zustand offers a lightweight, hook-based API for simpler global state, using a single store with minimal boilerplate. Jotai provides an atomic approach, managing state as small, independent atoms for fine-grained updates. In full-stack apps, these libraries integrate with backend APIs for data like user profiles or todos. Redux Toolkit suits large-scale apps, Zustand for medium-sized projects, and Jotai for minimal, reactive state. Intermediate learners should compare setup complexity and performance, starting with Zustand for simplicity. Be cautious of Redux’s boilerplate or Jotai’s learning curve for complex state. These tools ensure scalable state management in full-stack development.",
                          "examples": [
                            "// Redux Toolkit\nconst slice = createSlice({ name: 'todos', initialState: [], reducers: { addTodo: (state, action) => [...state, action.payload] } });",
                            "// Zustand\nconst useStore = create(set => ({ todos: [], addTodo: todo => set(state => ({ todos: [...state.todos, todo] })) }));",
                            "// Jotai\nconst todoAtom = atom([]);\nconst TodoList = () => { const [todos, setTodos] = useAtom(todoAtom); };"
                          ],
                          "realWorldApplication": "Used in e-commerce for cart state (Redux Toolkit), dashboards (Zustand), or dynamic UIs (Jotai).",
                          "expertInsights": "Choose Zustand for small-to-medium apps; use Redux Toolkit for large teams needing strict patterns; Jotai for fine-grained control.",
                          "commonMistakes": [
                            "Overcomplicating with Redux for simple apps",
                            "Not memoizing Zustand selectors",
                            "Using Jotai atoms without understanding reactivity"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Zustand Store",
                              "prompt": "Create a Zustand store to manage a todo list with add and remove actions.",
                              "difficulty": "medium",
                              "hints": [
                                "Use create from Zustand",
                                "Define addTodo and removeTodo"
                              ],
                              "solution": "import create from 'zustand';\nconst useStore = create(set => ({\n  todos: [],\n  addTodo: todo => set(state => ({ todos: [...state.todos, todo] })),\n  removeTodo: index => set(state => ({ todos: state.todos.filter((_, i) => i !== index) }))\n}));\nconst TodoApp = () => {\n  const { todos, addTodo } = useStore();\n  return <button onClick={() => addTodo('New task')}>Add</button>;\n};"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What simplifies Redux?",
                              "options": [
                                "Zustand",
                                "Redux Toolkit",
                                "Jotai",
                                "Context"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is Jotai’s approach?",
                              "options": [
                                "Atomic",
                                "Centralized",
                                "Hook-based",
                                "Reducer-based"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "Which is lightest for small apps?",
                              "options": [
                                "Redux",
                                "Zustand",
                                "Jotai",
                                "Both b and c"
                              ],
                              "correctOption": [3]
                            },
                            {
                              "question": "What does createSlice do?",
                              "options": [
                                "Creates atoms",
                                "Defines reducers",
                                "Fetches data",
                                "Styles components"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "Redux Toolkit Docs",
                              "url": "https://redux-toolkit.js.org/",
                              "type": "article"
                            },
                            {
                              "title": "Zustand Docs",
                              "url": "https://docs.pmnd.rs/zustand/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439186",
                        "title": "Server-State & Caching",
                        "slug": "server-state-caching",
                        "description": "Manage server-state with React Query or SWR for efficient data fetching.",
                        "order": 3,
                        "content": {
                          "explanation": "Server-state management handles data from backend APIs, distinct from client state. React Query and SWR simplify fetching, caching, and synchronizing server data in React. React Query uses `useQuery` for fetching and caching (e.g., `{ data } = useQuery('todos', fetchTodos)`), with features like stale-while-revalidate and automatic retries. SWR offers a similar hook-based API with lightweight caching (`useSWR('/api/todos', fetcher)`). Both integrate with full-stack backends, caching API responses to reduce requests and improve performance. Intermediate learners should use React Query for complex apps with refetching needs or SWR for simpler setups. Be cautious of stale data; configure cache times appropriately. These tools streamline data flow, ensuring responsive UIs with minimal server load in full-stack applications.",
                          "examples": [
                            "// React Query\nconst { data } = useQuery('todos', () => fetch('/api/todos').then(res => res.json()));",
                            "// SWR\nconst { data } = useSWR('/api/todos', url => fetch(url).then(res => res.json()));"
                          ],
                          "realWorldApplication": "Used in dashboards for fetching real-time data or e-commerce for product listings with caching.",
                          "expertInsights": "Use React Query for advanced features like mutations; configure SWR for minimal setups with aggressive caching.",
                          "commonMistakes": [
                            "Not handling loading/error states",
                            "Using long cache times for dynamic data",
                            "Ignoring refetch strategies"
                          ],
                          "exercises": [
                            {
                              "title": "Add React Query to Todo App",
                              "prompt": "Use React Query to fetch and display todos from an API endpoint (/api/todos).",
                              "difficulty": "medium",
                              "hints": [
                                "Use useQuery with a fetch function",
                                "Handle loading and error states"
                              ],
                              "solution": "import { useQuery } from '@tanstack/react-query';\nconst TodoList = () => {\n  const { data, isLoading, error } = useQuery(['todos'], () => fetch('/api/todos').then(res => res.json()));\n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  return <ul>{data?.map(todo => <li key={todo.id}>{todo.task}</li>)}</ul>;\n};"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does React Query manage?",
                              "options": [
                                "Local state",
                                "Server state",
                                "CSS",
                                "Routing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What feature does SWR emphasize?",
                              "options": [
                                "Stale-while-revalidate",
                                "Redux integration",
                                "Atomic state",
                                "Server rendering"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What must you handle in useQuery?",
                              "options": [
                                "Loading state",
                                "Styles",
                                "Components",
                                "Props"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "React Query Docs",
                              "url": "https://tanstack.com/query/latest/docs/react/overview",
                              "type": "article"
                            },
                            {
                              "title": "SWR Docs",
                              "url": "https://swr.vercel.app/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439187",
                        "title": "Optimistic Updates & Cache Invalidation",
                        "slug": "optimistic-updates-cache-invalidation",
                        "description": "Implement optimistic updates and cache invalidation for responsive UIs.",
                        "order": 4,
                        "content": {
                          "explanation": "Optimistic updates enhance UX by updating the UI immediately after a user action (e.g., adding a todo), assuming the backend request will succeed, then syncing with the server. React Query’s `useMutation` supports this with `onMutate` to update cache optimistically and rollback on failure. Cache invalidation ensures stale data is refreshed, using `queryClient.invalidateQueries` to trigger refetching. In full-stack apps, optimistic updates make interactions feel instant, while invalidation keeps data consistent with the backend. Intermediate learners should implement mutations with rollback and test invalidation strategies. Be cautious of optimistic failures without proper rollback, which can mislead users. These patterns are key for responsive, data-driven full-stack applications.",
                          "examples": [
                            "// Optimistic update with React Query\nconst { mutate } = useMutation(addTodo, {\n  onMutate: async todo => {\n    await queryClient.cancelQueries('todos');\n    const previous = queryClient.getQueryData('todos');\n    queryClient.setQueryData('todos', old => [...old, todo]);\n    return { previous };\n  },\n  onError: (err, todo, context) => queryClient.setQueryData('todos', context.previous)\n});",
                            "// Cache invalidation\nqueryClient.invalidateQueries('todos');"
                          ],
                          "realWorldApplication": "Used in social apps for instant likes or task apps for quick todo updates.",
                          "expertInsights": "Combine optimistic updates with error boundaries; use invalidation for critical data sync.",
                          "commonMistakes": [
                            "Not rolling back failed optimistic updates",
                            "Invalidating cache too frequently, causing refetch overload",
                            "Ignoring mutation error states"
                          ],
                          "exercises": [
                            {
                              "title": "Optimistic UI for Todo App",
                              "prompt": "Implement an optimistic update in a todo app using React Query, adding a todo instantly with rollback on failure.",
                              "difficulty": "hard",
                              "hints": [
                                "Use useMutation with onMutate",
                                "Update cache optimistically",
                                "Handle rollback in onError"
                              ],
                              "solution": "import { useMutation, useQueryClient } from '@tanstack/react-query';\nconst TodoList = () => {\n  const queryClient = useQueryClient();\n  const { mutate } = useMutation(\n    todo => fetch('/api/todos', { method: 'POST', body: JSON.stringify(todo) }).then(res => res.json()),\n    {\n      onMutate: async todo => {\n        await queryClient.cancelQueries(['todos']);\n        const previous = queryClient.getQueryData(['todos']);\n        queryClient.setQueryData(['todos'], old => [...old, todo]);\n        return { previous };\n      },\n      onError: (err, todo, context) => queryClient.setQueryData(['todos'], context.previous),\n      onSettled: () => queryClient.invalidateQueries(['todos'])\n    }\n  );\n  return <button onClick={() => mutate({ task: 'New todo' })}>Add Todo</button>;\n};"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does an optimistic update do?",
                              "options": [
                                "Waits for server",
                                "Updates UI instantly",
                                "Invalidates cache",
                                "Retries requests"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What triggers refetching?",
                              "options": [
                                "useQuery",
                                "invalidateQueries",
                                "useMutation",
                                "setQueryData"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What handles mutation errors?",
                              "options": [
                                "onMutate",
                                "onError",
                                "onSuccess",
                                "onSettled"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Why rollback optimistic updates?",
                              "options": [
                                "Improve speed",
                                "Prevent stale data",
                                "Ensure consistency",
                                "Reduce requests"
                              ],
                              "correctOption": [2]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "React Query Mutations",
                              "url": "https://tanstack.com/query/latest/docs/react/guides/mutations",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T20:22:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439190",
    "title": "TypeScript for Full-Stack",
    "slug": "typeScript-for-full-stack",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439191",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master TypeScript for building type-safe full-stack applications with robust frontend and backend integration.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439192",
            "title": "TypeScript for Full-Stack",
            "slug": "typescript-full-stack",
            "shortDescription": "An intermediate course on using TypeScript for type-safe frontend and backend development.",
            "longDescription": "This course explores practical TypeScript usage in full-stack development, covering strict configurations, typed React patterns, shared types between client and server, and runtime validation with tools like Zod, ensuring robust and maintainable applications.",
            "tags": [
              "TypeScript",
              "React",
              "Full-Stack",
              "Type Safety",
              "Intermediate"
            ],
            "thumbnail": "https://example.com/thumbnails/typescript-full-stack.jpg",
            "levels": [
              {
                "level": "Intermediate",
                "overview": "This intermediate level focuses on leveraging TypeScript for type-safe full-stack applications, integrating frontend and backend with strict types and runtime validation.",
                "goals": [
                  "Configure strict TypeScript for robust applications",
                  "Implement typed React components and hooks",
                  "Share types between client and server for consistency",
                  "Apply runtime validation for type-safe API contracts"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439193",
                    "title": "TypeScript for Full-Stack",
                    "slug": "typescript-full-stack",
                    "description": "Learn to use TypeScript for type-safe full-stack development on both frontend and backend.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439194",
                        "title": "Strict TS Config and Practical Types",
                        "slug": "strict-ts-config-types",
                        "description": "Learn to configure strict TypeScript and use utility types effectively.",
                        "order": 1,
                        "content": {
                          "explanation": "TypeScript enhances JavaScript with static types, improving code reliability in full-stack apps. A strict `tsconfig.json` (e.g., enabling `strict`, `noImplicitAny`, `strictNullChecks`) catches errors early. Utility types like `Partial<T>`, `Pick<T, K>`, and `Omit<T, K>` simplify type manipulation. For example, `Partial<User>` makes all properties optional. In full-stack development, strict configs ensure robust APIs and UIs by enforcing type safety. Intermediate learners should set up a strict `tsconfig`, use utility types for reusable interfaces, and type backend routes or frontend state. Be cautious of overly permissive types (e.g., `any`) that undermine safety. Strict configs and utility types are foundational for scalable full-stack projects, reducing runtime errors and improving maintainability.",
                          "examples": [
                            "// tsconfig.json\n{\n  \"compilerOptions\": { \"strict\": true, \"noImplicitAny\": true, \"strictNullChecks\": true }\n}",
                            "interface User { id: number; name: string; }\ntype PartialUser = Partial<User>; // { id?: number; name?: string; }"
                          ],
                          "realWorldApplication": "Used in full-stack apps to type API responses, database models, or UI state for error-free code.",
                          "expertInsights": "Enable strict mode always; use utility types to reduce boilerplate and ensure type consistency across layers.",
                          "commonMistakes": [
                            "Using 'any' to bypass type errors",
                            "Disabling strict checks in tsconfig",
                            "Not leveraging utility types for complex interfaces"
                          ],
                          "exercises": [
                            {
                              "title": "Convert JS Module to TS",
                              "prompt": "Convert a JavaScript function that adds a user to TypeScript with a strict tsconfig and utility types.",
                              "difficulty": "medium",
                              "hints": [
                                "Define an interface for user",
                                "Use Partial for optional fields"
                              ],
                              "solution": "// tsconfig.json\n{\n  \"compilerOptions\": { \"strict\": true, \"noImplicitAny\": true }\n}\n\n// user.ts\ninterface User { id: number; name: string; email?: string; }\nfunction addUser(user: Partial<User> & Pick<User, 'name'>): User {\n  return { id: Date.now(), name: user.name, email: user.email };\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does 'strict' enable in tsconfig?",
                              "options": [
                                "Loose typing",
                                "All strict checks",
                                "No types",
                                "Only null checks"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does Partial<T> do?",
                              "options": [
                                "Removes properties",
                                "Makes properties optional",
                                "Adds properties",
                                "Enforces types"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Why avoid 'any' type?",
                              "options": [
                                "Slows code",
                                "Reduces type safety",
                                "Increases size",
                                "Breaks JSX"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "TypeScript Handbook",
                              "url": "https://www.typescriptlang.org/docs/handbook/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439195",
                        "title": "Typed React Patterns",
                        "slug": "typed-react-patterns",
                        "description": "Learn to type React components, props, generics, and hooks.",
                        "order": 2,
                        "content": {
                          "explanation": "TypeScript in React ensures type-safe components, props, state, and hooks, improving frontend reliability in full-stack apps. Use interfaces or types for props (e.g., `interface Props { name: string; }`), generics for reusable components (e.g., `function List<T>({ items }: { items: T[] })`), and typed hooks like `useState<string>` for state. Patterns include typing event handlers (`React.MouseEvent`) and custom hooks with return types. For example, typing a form component ensures correct prop usage and prevents runtime errors. Intermediate learners should type props, use generics for flexible components, and handle hook return types. Be cautious of overcomplicating generics or omitting types for events. Typed React patterns enhance maintainability, especially when integrating with typed backend APIs.",
                          "examples": [
                            "interface Props { name: string; onClick: (e: React.MouseEvent) => void; }\nconst Button: React.FC<Props> = ({ name, onClick }) => <button onClick={onClick}>{name}</button>;",
                            "function List<T>({ items }: { items: T[] }) {\n  return <ul>{items.map(item => <li>{String(item)}</li>)}</ul>;\n}"
                          ],
                          "realWorldApplication": "Used in React apps for type-safe forms, lists, or API-driven components in full-stack systems.",
                          "expertInsights": "Use React.FC for functional components; leverage generics for reusable UI; type hooks explicitly for clarity.",
                          "commonMistakes": [
                            "Not typing event handlers",
                            "Using 'any' for generic types",
                            "Omitting props types, causing runtime issues"
                          ],
                          "exercises": [
                            {
                              "title": "Type a React Component",
                              "prompt": "Create a typed React component for a todo item with props for task and toggle function.",
                              "difficulty": "medium",
                              "hints": [
                                "Define an interface for props",
                                "Use React.FC for typing"
                              ],
                              "solution": "interface TodoProps { task: string; toggle: (e: React.MouseEvent) => void; }\nconst Todo: React.FC<TodoProps> = ({ task, toggle }) => (\n  <li onClick={toggle}>{task}</li>\n);"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "How do you type props in React?",
                              "options": [
                                "interface",
                                "class",
                                "function",
                                "array"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What does React.FC provide?",
                              "options": [
                                "State",
                                "Children typing",
                                "CSS",
                                "Routing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What are generics used for?",
                              "options": [
                                "Styling",
                                "Reusable components",
                                "Events",
                                "APIs"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What types a click event?",
                              "options": [
                                "React.MouseEvent",
                                "React.Event",
                                "Event",
                                "ClickEvent"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "TypeScript with React",
                              "url": "https://react-typescript-cheatsheet.netlify.app/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439196",
                        "title": "Shared Types Between Client & Server",
                        "slug": "shared-types-client-server",
                        "description": "Learn to share TypeScript types between frontend and backend.",
                        "order": 3,
                        "content": {
                          "explanation": "Sharing types between client and server ensures consistency in full-stack apps, especially for API payloads and responses. Use a monorepo (e.g., with Yarn workspaces) or a shared npm package to define interfaces like `User` or `Todo`. For example, a `types` package exports `interface User { id: number; name: string; }` used by both React frontend and Node.js backend. This prevents mismatches in API contracts. Tools like `tsc` or `esbuild` compile shared types. Intermediate learners should set up a shared types folder, import in both client and server, and ensure types match API schemas. Be cautious of circular dependencies or environment-specific types (e.g., browser vs Node). Shared types streamline development and reduce errors in full-stack systems.",
                          "examples": [
                            "// shared/types.ts\nexport interface User { id: number; name: string; }\n// client/src/App.tsx\nimport { User } from 'shared/types';\n// server/src/index.ts\nimport { User } from 'shared/types';",
                            "// package.json (monorepo)\n{\n  \"workspaces\": [\"client\", \"server\", \"shared\"]\n}"
                          ],
                          "realWorldApplication": "Used in full-stack apps to align frontend UI and backend API data structures, like user profiles or product data.",
                          "expertInsights": "Use a monorepo for simplicity; publish shared types as a package for distributed systems; validate with JSON Schema.",
                          "commonMistakes": [
                            "Duplicating types in client and server",
                            "Not updating shared types after API changes",
                            "Including environment-specific code in shared types"
                          ],
                          "exercises": [
                            {
                              "title": "Create Shared Types",
                              "prompt": "Define a shared TypeScript interface for a todo and use it in a React component and a Node.js route.",
                              "difficulty": "medium",
                              "hints": [
                                "Create a shared/types.ts file",
                                "Import in both client and server"
                              ],
                              "solution": "// shared/types.ts\nexport interface Todo { id: number; task: string; }\n\n// client/src/Todo.tsx\nimport { Todo } from 'shared/types';\nconst TodoList: React.FC<{ todos: Todo[] }> = ({ todos }) => (\n  <ul>{todos.map(todo => <li key={todo.id}>{todo.task}</li>)}</ul>\n);\n\n// server/src/index.ts\nimport { Todo } from 'shared/types';\napp.get('/todos', (req, res) => res.json([{ id: 1, task: 'Code' } as Todo]));"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What ensures client-server type consistency?",
                              "options": [
                                "Shared types",
                                "Local types",
                                "CSS",
                                "Hooks"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What is a monorepo?",
                              "options": [
                                "Single repository",
                                "Multiple repositories",
                                "Database",
                                "Server"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What can shared types prevent?",
                              "options": [
                                "Styling issues",
                                "API mismatches",
                                "Re-renders",
                                "Caching"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "TypeScript Monorepos",
                              "url": "https://www.typescriptlang.org/docs/handbook/module-resolution.html",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439197",
                        "title": "Runtime Validation & Type-Safe APIs",
                        "slug": "runtime-validation-type-safe-apis",
                        "description": "Implement runtime validation with Zod and type-safe API contracts.",
                        "order": 4,
                        "content": {
                          "explanation": "Runtime validation ensures API data matches expected types at runtime, complementing TypeScript’s static checks. Zod is a schema validation library that defines schemas (e.g., `z.object({ id: z.number(), name: z.string() })`) and infers TypeScript types (`z.infer<typeof schema>`). io-ts is similar but more functional. In full-stack apps, validate API inputs/outputs to prevent invalid data. For example, a backend route validates incoming POST data with Zod, while the frontend uses the inferred type for type-safe fetching. Type-safe API contracts align client and server expectations. Intermediate learners should define Zod schemas, infer types, and validate API routes. Be cautious of complex schemas impacting performance. This approach ensures robust, error-free data flow in full-stack systems.",
                          "examples": [
                            "// shared/schema.ts\nimport { z } from 'zod';\nexport const UserSchema = z.object({ id: z.number(), name: z.string() });\nexport type User = z.infer<typeof UserSchema>;\n// server route\nimport { UserSchema } from 'shared/schema';\napp.post('/users', (req, res) => {\n  const user = UserSchema.parse(req.body);\n  res.json(user);\n});",
                            "// client fetch\nimport { User } from 'shared/schema';\nconst { data } = useQuery(['user'], () => fetch('/users').then(res => UserSchema.parse(res.json())));"
                          ],
                          "realWorldApplication": "Used in full-stack apps to validate user inputs, API responses, or database payloads for reliability.",
                          "expertInsights": "Use Zod for simple validation; combine with tRPC or OpenAPI for end-to-end type safety.",
                          "commonMistakes": [
                            "Not validating API responses",
                            "Using Zod without inferring types",
                            "Overcomplicating schemas for simple data"
                          ],
                          "exercises": [
                            {
                              "title": "Add Zod Validation to API Route",
                              "prompt": "Create a Zod schema for a todo object and validate it in a Node.js POST route.",
                              "difficulty": "hard",
                              "hints": [
                                "Define schema with z.object",
                                "Use schema.parse in route"
                              ],
                              "solution": "// shared/schema.ts\nimport { z } from 'zod';\nexport const TodoSchema = z.object({ id: z.number(), task: z.string() });\nexport type Todo = z.infer<typeof TodoSchema>;\n\n// server/src/index.ts\nimport { TodoSchema } from 'shared/schema';\napp.post('/todos', (req, res) => {\n  try {\n    const todo = TodoSchema.parse(req.body);\n    res.json(todo);\n  } catch (e) {\n    res.status(400).json({ error: e.message });\n  }\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does Zod validate?",
                              "options": [
                                "Styles",
                                "Runtime data",
                                "Static types",
                                "Components"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What infers TypeScript types from Zod?",
                              "options": [
                                "z.object",
                                "z.infer",
                                "z.parse",
                                "z.type"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Why validate API inputs?",
                              "options": [
                                "Improve speed",
                                "Ensure data integrity",
                                "Reduce code",
                                "Style UI"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What happens on validation failure?",
                              "options": [
                                "Throws error",
                                "Logs warning",
                                "Continues",
                                "Retries"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "Zod Documentation",
                              "url": "https://zod.dev/",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T20:26:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439200",
    "title": "Advanced JavaScript Features",
    "slug": "advanced-javascript",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439201",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Explore advanced JavaScript and ECMAScript features to enhance code quality and architecture in web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439202",
            "title": "Advanced JavaScript / ECMAScript Features",
            "slug": "advanced-js-ecmascript",
            "shortDescription": "An intermediate course on modern JavaScript features for improved code quality and architecture.",
            "longDescription": "This course dives into advanced JavaScript and ECMAScript features, including async patterns with cancellations, proxies, generators, iterators, and module patterns with bundler optimizations, enabling scalable and maintainable web applications.",
            "tags": [
              "JavaScript",
              "ECMAScript",
              "Async",
              "Modules",
              "Intermediate"
            ],
            "thumbnail": "https://example.com/thumbnails/advanced-js.jpg",
            "levels": [
              {
                "level": "Intermediate",
                "overview": "This intermediate level focuses on leveraging advanced JavaScript features to enhance code quality, performance, and architecture in web applications.",
                "goals": [
                  "Master advanced async patterns with cancellations",
                  "Use proxies, generators, and iterators effectively",
                  "Optimize module patterns with bundlers for performance"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439203",
                    "title": "Advanced JavaScript / ECMAScript Features",
                    "slug": "advanced-js-ecmascript",
                    "description": "Learn modern JavaScript features to improve code quality and application architecture.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439204",
                        "title": "Advanced Async Patterns",
                        "slug": "advanced-async-patterns",
                        "description": "Learn to handle cancellations and advanced async patterns with AbortController.",
                        "order": 1,
                        "content": {
                          "explanation": "Advanced async patterns in JavaScript manage asynchronous operations with greater control, particularly cancellations. `AbortController` allows canceling fetch requests or other async tasks by signaling abortion via `AbortSignal`. For example, `controller.abort()` cancels a `fetch` call, useful in components unmounting before data arrives. Patterns include wrapping async tasks in try-catch for error handling and using `Promise.race` for timeouts. In web apps, cancellations prevent memory leaks and stale data updates. Intermediate learners should practice canceling fetch requests in React useEffect and handling abort errors. Be cautious of unhandled abort errors or missing cleanup in async tasks. These patterns ensure robust, responsive applications, especially in data-heavy UIs.",
                          "examples": [
                            "const controller = new AbortController();\nfetch('/api/data', { signal: controller.signal }).catch(err => {\n  if (err.name === 'AbortError') console.log('Fetch canceled');\n});\ncontroller.abort();",
                            "// React useEffect with cleanup\nconst useFetch = url => {\n  const [data, setData] = React.useState(null);\n  React.useEffect(() => {\n    const controller = new AbortController();\n    fetch(url, { signal: controller.signal }).then(res => res.json()).then(setData);\n    return () => controller.abort();\n  }, [url]);\n  return data;\n};"
                          ],
                          "realWorldApplication": "Used in search bars with debounced fetches or dashboards canceling outdated API calls on user navigation.",
                          "expertInsights": "Always clean up async tasks in useEffect; use AbortController for all cancellable async operations.",
                          "commonMistakes": [
                            "Not handling AbortError in catch blocks",
                            "Forgetting cleanup in React useEffect",
                            "Using AbortController without signal"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Request Cancellation",
                              "prompt": "Create a React component that fetches data and cancels the request on unmount using AbortController.",
                              "difficulty": "medium",
                              "hints": [
                                "Use AbortController in useEffect",
                                "Return cleanup function to abort"
                              ],
                              "solution": "const FetchComponent = () => {\n  const [data, setData] = React.useState(null);\n  React.useEffect(() => {\n    const controller = new AbortController();\n    fetch('/api/data', { signal: controller.signal })\n      .then(res => res.json())\n      .then(setData)\n      .catch(err => { if (err.name !== 'AbortError') console.error(err); });\n    return () => controller.abort();\n  }, []);\n  return <div>{data ? data.name : 'Loading...'}</div>;\n};"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What cancels a fetch request?",
                              "options": [
                                "fetch.stop",
                                "AbortController",
                                "Promise.cancel",
                                "try-catch"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does AbortController.signal do?",
                              "options": [
                                "Starts fetch",
                                "Cancels fetch",
                                "Handles errors",
                                "Parses JSON"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What error does abort trigger?",
                              "options": [
                                "TypeError",
                                "AbortError",
                                "FetchError",
                                "CancelError"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 80,
                          "resources": [
                            {
                              "title": "MDN AbortController",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/API/AbortController",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439205",
                        "title": "Proxies, Generators, and Iterators",
                        "slug": "proxies-generators-iterators",
                        "description": "Learn to use proxies, generators, and iterators for advanced JavaScript patterns.",
                        "order": 2,
                        "content": {
                          "explanation": "Proxies, generators, and iterators offer powerful ways to manipulate objects and control flow in JavaScript. Proxies wrap objects to intercept operations like property access (`get`, `set`), enabling custom behavior (e.g., logging or validation). Generators (`function*`) yield values one at a time, pausing execution, ideal for lazy evaluation or async iteration. Iterators provide custom iteration with `[Symbol.iterator]`, used in `for...of` loops. For example, a Proxy can enforce read-only properties, while generators handle large datasets incrementally. Intermediate learners should use Proxies for dynamic object behavior, generators for sequential data, and iterators for custom loops. Be cautious of Proxy performance overhead or generator complexity. These features enhance code flexibility in web apps, like reactive data layers or custom iteration logic.",
                          "examples": [
                            "// Proxy\nconst obj = new Proxy({ x: 1 }, {\n  get: (target, prop) => target[prop],\n  set: () => { throw new Error('Read-only'); }\n});",
                            "// Generator\nfunction* idGenerator() {\n  let id = 0;\n  while (true) yield id++;\n}\nconst gen = idGenerator();\nconsole.log(gen.next().value); // 0"
                          ],
                          "realWorldApplication": "Proxies for reactive state in frameworks; generators for streaming data; iterators for custom data structures.",
                          "expertInsights": "Use Proxies sparingly due to performance; combine generators with async/await for async iteration.",
                          "commonMistakes": [
                            "Overusing Proxies, causing slowdowns",
                            "Not handling generator termination",
                            "Misimplementing iterator protocols"
                          ],
                          "exercises": [
                            {
                              "title": "Create a Generator for Data",
                              "prompt": "Write a generator function that yields numbers from 1 to 5.",
                              "difficulty": "medium",
                              "hints": [
                                "Use function* syntax",
                                "Yield values in a loop"
                              ],
                              "solution": "function* numberGenerator() {\n  for (let i = 1; i <= 5; i++) {\n    yield i;\n  }\n}\nconst gen = numberGenerator();\nconsole.log([...gen]); // [1, 2, 3, 4, 5]"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does a Proxy intercept?",
                              "options": [
                                "Functions",
                                "Object operations",
                                "Loops",
                                "Promises"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does a generator yield?",
                              "options": [
                                "Promises",
                                "Values",
                                "Errors",
                                "Objects"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What enables for...of loops?",
                              "options": [
                                "Proxies",
                                "Iterators",
                                "Generators",
                                "Both b and c"
                              ],
                              "correctOption": [3]
                            },
                            {
                              "question": "What is a generator’s purpose?",
                              "options": [
                                "Lazy evaluation",
                                "Styling",
                                "Fetching",
                                "Bundling"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 80,
                          "resources": [
                            {
                              "title": "MDN Proxies",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
                              "type": "article"
                            },
                            {
                              "title": "MDN Generators",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439206",
                        "title": "Module Patterns and Bundler Optimizations",
                        "slug": "module-patterns-bundler-optimizations",
                        "description": "Learn module patterns and optimize with bundlers for performance.",
                        "order": 3,
                        "content": {
                          "explanation": "Module patterns organize JavaScript code using ES modules (`import`/`export`) for encapsulation and reusability. Patterns include default exports for single entities, named exports for utilities, and barrel files (`index.js`) to group exports. Bundlers like Webpack or Vite optimize modules via tree-shaking (removing unused code), code splitting, and minification. For example, dynamic imports (`import()` with `React.lazy`) enable lazy loading. In web apps, modules structure components or services, while bundlers reduce bundle size for faster loads. Intermediate learners should use named exports for utilities, dynamic imports for large modules, and configure bundlers for tree-shaking. Be cautious of circular imports or unoptimized bundles. These techniques ensure scalable, performant web applications.",
                          "examples": [
                            "// utils.js\nexport const add = x => x + 1;\nexport const subtract = x => x - 1;\n// index.js\nexport * from './utils.js';",
                            "// Lazy-loaded module\nimport React, { lazy } from 'react';\nconst LazyComponent = lazy(() => import('./Component'));",
                            "// vite.config.js\n{\n  build: { rollupOptions: { output: { manualChunks: { vendor: ['react'] } } } }\n}"
                          ],
                          "realWorldApplication": "Used in large React apps for modular codebases and optimized production builds.",
                          "expertInsights": "Use barrel files for clean imports; enable tree-shaking and code splitting in bundlers; profile bundle size.",
                          "commonMistakes": [
                            "Creating circular module dependencies",
                            "Not enabling tree-shaking in bundlers",
                            "Overusing dynamic imports, increasing HTTP requests"
                          ],
                          "exercises": [
                            {
                              "title": "Optimize Module Imports",
                              "prompt": "Create a module with named exports for utilities and import it in a React component with lazy loading.",
                              "difficulty": "medium",
                              "hints": [
                                "Use export for utilities",
                                "Use React.lazy for component"
                              ],
                              "solution": "// utils.js\nexport const formatDate = date => new Date(date).toLocaleString();\n\n// App.jsx\nimport React, { lazy } from 'react';\nimport { formatDate } from './utils';\nconst LazyComp = lazy(() => import('./Comp'));\nconst App = () => <div>{formatDate(new Date())}</div>;"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does tree-shaking remove?",
                              "options": [
                                "Used code",
                                "Unused code",
                                "Styles",
                                "Dependencies"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What enables lazy loading?",
                              "options": [
                                "import()",
                                "export",
                                "fetch",
                                "require"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What groups module exports?",
                              "options": [
                                "Barrel file",
                                "Config file",
                                "Bundle file",
                                "Script file"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 80,
                          "resources": [
                            {
                              "title": "MDN ES Modules",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules",
                              "type": "article"
                            },
                            {
                              "title": "Vite Optimization",
                              "url": "https://vitejs.dev/guide/optimization",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T20:33:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439210",
    "title": "API Design for Web Development",
    "slug": "api-design",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439211",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master the design and implementation of predictable, versioned, and secure APIs for web applications using REST and GraphQL.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439212",
            "title": "API Design (REST & GraphQL)",
            "slug": "api-design-rest-graphql",
            "shortDescription": "An intermediate course on designing and implementing REST and GraphQL APIs for robust web applications.",
            "longDescription": "This course covers designing predictable, versioned, and secure APIs using REST principles with pagination and error handling, GraphQL schema design with queries and mutations, versioning strategies, HATEOAS considerations, and effective API documentation with tools like OpenAPI and GraphQL Playground.",
            "tags": [
              "REST",
              "GraphQL",
              "API Design",
              "Web Development",
              "Intermediate"
            ],
            "thumbnail": "https://example.com/thumbnails/api-design.jpg",
            "levels": [
              {
                "level": "Intermediate",
                "overview": "This intermediate level focuses on designing and implementing REST and GraphQL APIs, ensuring predictability, scalability, and security in web applications.",
                "goals": [
                  "Design REST APIs with proper pagination, filtering, and error handling",
                  "Build GraphQL schemas with queries and mutations",
                  "Implement versioning and HATEOAS for API evolution",
                  "Document APIs using OpenAPI/Swagger and GraphQL Playground"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439213",
                    "title": "API Design (REST & GraphQL)",
                    "slug": "api-design-rest-graphql",
                    "description": "Learn to design and implement predictable, versioned, and secure APIs using REST and GraphQL.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439214",
                        "title": "REST Principles, Pagination, Filtering, Error Handling",
                        "slug": "rest-principles",
                        "description": "Learn core REST principles, pagination, filtering, and error handling for robust APIs.",
                        "order": 1,
                        "content": {
                          "explanation": "REST (Representational State Transfer) is an architectural style for designing APIs using HTTP methods (GET, POST, PUT, DELETE) and resources identified by URLs. Core principles include statelessness, client-server separation, and uniform interfaces. Pagination (e.g., `?page=2&limit=10`) manages large datasets, filtering (e.g., `?status=active`) narrows results, and error handling uses standard HTTP status codes (e.g., 400 for bad requests, 404 for not found). For example, a GET `/users?page=1&limit=20` endpoint returns paginated user data. Intermediate learners should design REST endpoints with clear resource paths, implement query parameters for pagination/filtering, and return consistent error responses. Be cautious of over-fetching data or inconsistent error formats, which can confuse clients. These practices ensure scalable and predictable APIs for web applications.",
                          "examples": [
                            "// GET /users?page=1&limit=10\napp.get('/users', (req, res) => {\n  const { page = 1, limit = 10 } = req.query;\n  const users = db.users.slice((page - 1) * limit, page * limit);\n  res.json({ users, total: db.users.length });\n});",
                            "// Error handling\napp.get('/users/:id', (req, res) => {\n  const user = db.users.find(u => u.id === req.params.id);\n  if (!user) return res.status(404).json({ error: 'User not found' });\n  res.json(user);\n});"
                          ],
                          "realWorldApplication": "Used in e-commerce APIs for product listings, user management, or order processing with pagination and filtering.",
                          "expertInsights": "Use query parameters for pagination/filtering; return metadata (e.g., total count); standardize error responses with JSON.",
                          "commonMistakes": [
                            "Not implementing pagination for large datasets",
                            "Inconsistent error response formats",
                            "Using non-standard HTTP methods for REST"
                          ],
                          "exercises": [
                            {
                              "title": "Design a REST API",
                              "prompt": "Create a REST API endpoint for a todo resource with pagination and error handling.",
                              "difficulty": "medium",
                              "hints": [
                                "Use query parameters for page/limit",
                                "Return 404 for invalid IDs"
                              ],
                              "solution": "const express = require('express');\nconst app = express();\nconst todos = [{ id: 1, task: 'Code' }, { id: 2, task: 'Test' }];\napp.get('/todos', (req, res) => {\n  const { page = 1, limit = 10 } = req.query;\n  const start = (page - 1) * limit;\n  const paginated = todos.slice(start, start + Number(limit));\n  res.json({ todos: paginated, total: todos.length });\n});\napp.get('/todos/:id', (req, res) => {\n  const todo = todos.find(t => t.id === Number(req.params.id));\n  if (!todo) return res.status(404).json({ error: 'Todo not found' });\n  res.json(todo);\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does REST emphasize?",
                              "options": [
                                "Stateful servers",
                                "Uniform interfaces",
                                "Complex URLs",
                                "Custom methods"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What handles large datasets in REST?",
                              "options": [
                                "Pagination",
                                "Caching",
                                "Compression",
                                "Encoding"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What status code for not found?",
                              "options": ["200", "400", "404", "500"],
                              "correctOption": [2]
                            }
                          ],
                          "estimatedTime": 100,
                          "resources": [
                            {
                              "title": "REST API Design",
                              "url": "https://restfulapi.net/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439215",
                        "title": "GraphQL Basics, Schema Design, Queries vs Mutations",
                        "slug": "graphql-basics",
                        "description": "Learn GraphQL schema design, queries, and mutations for flexible APIs.",
                        "order": 2,
                        "content": {
                          "explanation": "GraphQL is a query language for APIs, allowing clients to request exactly the data needed via a single endpoint. Schemas define types (e.g., `type User { id: Int!, name: String }`) and operations: queries (read data) and mutations (modify data). For example, a query `{ users { name } }` fetches user names, while a mutation `mutation { addUser(name: \"Alice\") { id } }` creates a user. GraphQL’s type system ensures predictable responses. Intermediate learners should design schemas with clear types, use queries for fetching, and mutations for updates. Be cautious of over-fetching in nested queries (N+1 problem) or complex resolvers impacting performance. GraphQL is ideal for web apps needing flexible data retrieval, complementing REST in full-stack systems.",
                          "examples": [
                            "// Schema\ntype Query { users: [User!]! }\ntype Mutation { addUser(name: String!): User! }\ntype User { id: Int!; name: String! }",
                            "// Query\n{ users { id name } }\n// Mutation\nmutation { addUser(name: \"Alice\") { id name } }"
                          ],
                          "realWorldApplication": "Used in content management systems or e-commerce for dynamic data fetching with precise client control.",
                          "expertInsights": "Use non-null types (`!`) for reliability; optimize resolvers to avoid N+1 issues; use fragments for reusable fields.",
                          "commonMistakes": [
                            "Overly nested queries causing performance issues",
                            "Not distinguishing queries and mutations",
                            "Ignoring schema validation"
                          ],
                          "exercises": [
                            {
                              "title": "Design a GraphQL Endpoint",
                              "prompt": "Create a GraphQL schema and resolver for a todo resource with a query to fetch todos and a mutation to add a todo.",
                              "difficulty": "medium",
                              "hints": [
                                "Define a Todo type",
                                "Create query and mutation resolvers"
                              ],
                              "solution": "const { ApolloServer, gql } = require('apollo-server');\nconst todos = [{ id: 1, task: 'Code' }];\nconst typeDefs = gql`\n  type Todo { id: Int!, task: String! }\n  type Query { todos: [Todo!]! }\n  type Mutation { addTodo(task: String!): Todo! }\n`;\nconst resolvers = {\n  Query: { todos: () => todos },\n  Mutation: { addTodo: (_, { task }) => {\n    const todo = { id: todos.length + 1, task };\n    todos.push(todo);\n    return todo;\n  } }\n};\nconst server = new ApolloServer({ typeDefs, resolvers });"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does a GraphQL query do?",
                              "options": [
                                "Modifies data",
                                "Fetches data",
                                "Deletes data",
                                "Styles data"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What defines GraphQL types?",
                              "options": [
                                "Schema",
                                "Resolver",
                                "Mutation",
                                "Endpoint"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What is a mutation used for?",
                              "options": [
                                "Fetching",
                                "Modifying",
                                "Filtering",
                                "Paginating"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is a GraphQL benefit?",
                              "options": [
                                "Multiple endpoints",
                                "Precise data fetching",
                                "Complex URLs",
                                "Stateless"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 100,
                          "resources": [
                            {
                              "title": "GraphQL Documentation",
                              "url": "https://graphql.org/learn/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439216",
                        "title": "Versioning Strategies, HATEOAS Considerations",
                        "slug": "versioning-hateoas",
                        "description": "Explore API versioning and HATEOAS for evolving APIs.",
                        "order": 3,
                        "content": {
                          "explanation": "API versioning ensures backward compatibility as APIs evolve, using strategies like URL versioning (e.g., `/v1/users`), query parameters (`?version=1`), or headers (`Accept: application/vnd.api.v1+json`). HATEOAS (Hypermedia as the Engine of Application State) embeds navigation links in responses (e.g., `{ user: { id: 1, name: 'Alice', links: { self: '/users/1' } } }`), guiding clients through API resources. Versioning prevents breaking changes, while HATEOAS enhances discoverability. Intermediate learners should implement URL versioning for simplicity and include HATEOAS links in responses. Be cautious of overcomplicating HATEOAS or frequent versioning, which can confuse clients. These practices ensure long-term maintainability in web APIs.",
                          "examples": [
                            "// URL versioning\napp.get('/v1/users', (req, res) => res.json({ users: [] }));",
                            "// HATEOAS response\nres.json({ id: 1, name: 'Alice', links: { self: '/v1/users/1', todos: '/v1/users/1/todos' } });"
                          ],
                          "realWorldApplication": "Used in public APIs (e.g., GitHub) for versioning and hypermedia-driven navigation.",
                          "expertInsights": "Prefer URL versioning for simplicity; use HATEOAS sparingly for critical navigation; plan versioning early.",
                          "commonMistakes": [
                            "Not versioning APIs, breaking clients",
                            "Overusing HATEOAS links, increasing payload size",
                            "Inconsistent versioning schemes"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Versioned REST API",
                              "prompt": "Create a versioned REST API endpoint for todos with HATEOAS links.",
                              "difficulty": "medium",
                              "hints": [
                                "Use /v1/todos path",
                                "Include self link in response"
                              ],
                              "solution": "const express = require('express');\nconst app = express();\nconst todos = [{ id: 1, task: 'Code' }];\napp.get('/v1/todos', (req, res) => {\n  res.json({\n    todos: todos.map(t => ({ ...t, links: { self: `/v1/todos/${t.id}` } })),\n    links: { self: '/v1/todos' }\n  });\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is a versioning strategy?",
                              "options": [
                                "URL versioning",
                                "Styling",
                                "Caching",
                                "Compression"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What does HATEOAS provide?",
                              "options": [
                                "Data",
                                "Navigation links",
                                "Styles",
                                "Errors"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Why version APIs?",
                              "options": [
                                "Speed",
                                "Compatibility",
                                "Security",
                                "Size"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "REST Versioning",
                              "url": "https://restfulapi.net/versioning/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439217",
                        "title": "API Documentation",
                        "slug": "api-documentation",
                        "description": "Learn to document APIs using OpenAPI/Swagger and GraphQL Playground.",
                        "order": 4,
                        "content": {
                          "explanation": "API documentation ensures usability by describing endpoints, schemas, and usage. OpenAPI (Swagger) defines REST APIs in YAML/JSON (e.g., paths, parameters, responses), generating interactive docs with tools like Swagger UI. GraphQL Playground provides an interactive interface for exploring schemas, queries, and mutations. For example, an OpenAPI spec lists `/todos` with GET/POST details, while GraphQL Playground auto-generates docs from the schema. Intermediate learners should write OpenAPI specs for REST and use Playground for GraphQL, ensuring clear parameter and response descriptions. Be cautious of incomplete docs or outdated schemas, which mislead users. Good documentation is critical for developer adoption in web APIs.",
                          "examples": [
                            "# OpenAPI YAML\npaths:\n  /todos:\n    get:\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  type: object\n                  properties:\n                    id: { type: integer }\n                    task: { type: string }",
                            "// GraphQL Playground Query\n{ todos { id task } }"
                          ],
                          "realWorldApplication": "Used in public APIs (e.g., Stripe) for developer-friendly documentation and testing interfaces.",
                          "expertInsights": "Automate OpenAPI generation with tools like swagger-jsdoc; keep GraphQL schemas self-documenting with descriptions.",
                          "commonMistakes": [
                            "Incomplete OpenAPI specs missing responses",
                            "Not updating docs after API changes",
                            "Ignoring GraphQL schema descriptions"
                          ],
                          "exercises": [
                            {
                              "title": "Document REST and GraphQL APIs",
                              "prompt": "Create an OpenAPI spec for a todo REST API and a GraphQL schema with documentation for a todo query.",
                              "difficulty": "hard",
                              "hints": [
                                "Use YAML for OpenAPI",
                                "Add descriptions to GraphQL schema"
                              ],
                              "solution": "# openapi.yaml\nopenapi: 3.0.0\npaths:\n  /todos:\n    get:\n      summary: Get todos\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  type: object\n                  properties:\n                    id: { type: integer }\n                    task: { type: string }\n\n// schema.graphql\nconst typeDefs = gql`\n  type Todo { id: Int!, task: String! @description \"The todo task\" }\n  type Query { todos: [Todo!]! @description \"Fetch all todos\" }\n`;"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does OpenAPI define?",
                              "options": [
                                "Styles",
                                "REST endpoints",
                                "GraphQL schemas",
                                "Components"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What tool visualizes OpenAPI?",
                              "options": [
                                "GraphQL Playground",
                                "Swagger UI",
                                "Postman",
                                "DevTools"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does GraphQL Playground do?",
                              "options": [
                                "Tests REST",
                                "Explores schemas",
                                "Bundles code",
                                "Styles APIs"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Why document APIs?",
                              "options": [
                                "Speed",
                                "Usability",
                                "Security",
                                "Compression"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "OpenAPI Specification",
                              "url": "https://swagger.io/specification/",
                              "type": "article"
                            },
                            {
                              "title": "GraphQL Playground",
                              "url": "https://www.apollographql.com/docs/apollo-server/testing/graphql-playground/",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T20:36:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439220",
    "title": "Databases & Data Modeling",
    "slug": "databases-data-modeling",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439221",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master database selection, data modeling, and management for scalable web applications using SQL and NoSQL databases.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439222",
            "title": "Databases & Data Modeling (SQL & NoSQL)",
            "slug": "databases-data-modeling-sql-nosql",
            "shortDescription": "An intermediate course on designing and managing SQL and NoSQL databases for web applications.",
            "longDescription": "This course covers relational modeling with normalization, indexing, and transactions in Postgres, NoSQL document modeling and denormalization in MongoDB, ORMs and query builders like Prisma and TypeORM, and strategies for migrations, backups, and schema evolution to support robust web applications.",
            "tags": [
              "SQL",
              "NoSQL",
              "Data Modeling",
              "Databases",
              "Intermediate"
            ],
            "thumbnail": "https://example.com/thumbnails/databases.jpg",
            "levels": [
              {
                "level": "Intermediate",
                "overview": "This intermediate level focuses on choosing and modeling databases for web applications, implementing efficient queries, and managing schema evolution with migrations and backups.",
                "goals": [
                  "Design relational models with normalization and transactions in Postgres",
                  "Implement NoSQL document models with denormalization in MongoDB",
                  "Use ORMs and query builders for efficient database interactions",
                  "Apply migrations, backups, and schema evolution strategies"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439223",
                    "title": "Databases & Data Modeling",
                    "slug": "databases-data-modeling",
                    "description": "Learn to design and manage SQL and NoSQL databases for scalable web applications.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439224",
                        "title": "Relational Modeling, Normalization, Indexes, Transactions",
                        "slug": "relational-modeling-postgres",
                        "description": "Learn relational data modeling, normalization, indexing, and transactions in Postgres.",
                        "order": 1,
                        "content": {
                          "explanation": "Relational modeling organizes data into tables with relationships defined by keys (primary, foreign). Normalization (e.g., 1NF, 2NF, 3NF) eliminates redundancy and ensures data integrity. For example, an e-commerce app might have `users`, `orders`, and `products` tables, with foreign keys linking `orders` to `users` and `products`. Indexes improve query performance (e.g., `CREATE INDEX ON orders(user_id)`) but increase write time. Transactions ensure atomic operations, using `BEGIN`, `COMMIT`, or `ROLLBACK` in Postgres. Intermediate learners should design normalized schemas, add indexes for frequent queries, and use transactions for multi-step operations. Be cautious of over-normalization, which can complicate queries, or missing indexes, which slow performance. These practices ensure efficient and reliable data management in SQL-based web applications.",
                          "examples": [
                            "-- Create tables\nCREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR(100));\nCREATE TABLE orders (id SERIAL PRIMARY KEY, user_id INTEGER REFERENCES users(id));",
                            "-- Transaction\nBEGIN;\nINSERT INTO users (name) VALUES ('Alice');\nINSERT INTO orders (user_id) VALUES (currval('users_id_seq'));\nCOMMIT;"
                          ],
                          "realWorldApplication": "Used in e-commerce for order management, user accounts, or inventory tracking with reliable data operations.",
                          "expertInsights": "Normalize to 3NF for most apps; use indexes for frequently queried columns; wrap critical operations in transactions.",
                          "commonMistakes": [
                            "Over-normalizing, causing complex joins",
                            "Not indexing frequently queried columns",
                            "Ignoring transaction isolation levels"
                          ],
                          "exercises": [
                            {
                              "title": "Design E-commerce Schema",
                              "prompt": "Design a Postgres schema for an e-commerce cart with users, products, and carts, including indexes and a transaction to add a cart item.",
                              "difficulty": "medium",
                              "hints": [
                                "Use foreign keys for relationships",
                                "Add index on user_id in carts",
                                "Use a transaction for inserting cart items"
                              ],
                              "solution": "-- Schema\nCREATE TABLE users (id SERIAL PRIMARY KEY, name VARCHAR(100));\nCREATE TABLE products (id SERIAL PRIMARY KEY, name VARCHAR(100), price DECIMAL);\nCREATE TABLE carts (id SERIAL PRIMARY KEY, user_id INTEGER REFERENCES users(id), product_id INTEGER REFERENCES products(id), quantity INTEGER);\nCREATE INDEX idx_cart_user ON carts(user_id);\n\n-- Transaction\nBEGIN;\nINSERT INTO users (name) VALUES ('Alice');\nINSERT INTO carts (user_id, product_id, quantity) VALUES (currval('users_id_seq'), 1, 2);\nCOMMIT;"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does normalization reduce?",
                              "options": [
                                "Query speed",
                                "Redundancy",
                                "Indexes",
                                "Transactions"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What improves query performance?",
                              "options": [
                                "Normalization",
                                "Indexes",
                                "Denormalization",
                                "Joins"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What ensures atomic operations?",
                              "options": [
                                "Indexes",
                                "Transactions",
                                "Foreign keys",
                                "Schemas"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Postgres Documentation",
                              "url": "https://www.postgresql.org/docs/current/index.html",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439225",
                        "title": "NoSQL Patterns (Document Modeling, Denormalization)",
                        "slug": "nosql-patterns-mongodb",
                        "description": "Learn document modeling and denormalization in MongoDB for NoSQL databases.",
                        "order": 2,
                        "content": {
                          "explanation": "NoSQL databases like MongoDB use document modeling, storing data as JSON-like documents. Unlike relational databases, denormalization embeds related data (e.g., user and order details in one document) to optimize read performance. For example, a MongoDB `users` collection might include an array of `orders` within each user document. Indexes (e.g., `db.users.createIndex({ email: 1 })`) improve query speed, while aggregation pipelines handle complex queries. Intermediate learners should design denormalized schemas for read-heavy use cases, add indexes for frequent queries, and use MongoDB’s aggregation for analytics. Be cautious of excessive denormalization, which increases write overhead, or missing indexes, which slows queries. These patterns suit flexible, scalable web applications like content platforms or e-commerce.",
                          "examples": [
                            "// Document\n{\n  \"_id\": 1,\n  \"name\": \"Alice\",\n  \"orders\": [{ \"id\": 101, \"product\": \"Laptop\", \"price\": 999 }]\n}",
                            "// Index\nawait db.users.createIndex({ email: 1 });\n// Query\nawait db.users.find({ email: \"alice@example.com\" });"
                          ],
                          "realWorldApplication": "Used in e-commerce for product catalogs or social apps for user profiles with embedded posts.",
                          "expertInsights": "Denormalize for read-heavy apps; use indexes sparingly; leverage aggregation for complex queries.",
                          "commonMistakes": [
                            "Over-denormalizing, causing write bottlenecks",
                            "Not indexing frequently queried fields",
                            "Ignoring aggregation for analytics"
                          ],
                          "exercises": [
                            {
                              "title": "Design MongoDB Schema",
                              "prompt": "Design a MongoDB schema for an e-commerce cart with users and embedded cart items, including an index and query.",
                              "difficulty": "medium",
                              "hints": [
                                "Embed cart items in users",
                                "Index user email",
                                "Query by user email"
                              ],
                              "solution": "const userSchema = {\n  name: String,\n  email: String,\n  cart: [{ productId: Number, name: String, price: Number, quantity: Number }]\n};\n// Index\nawait db.users.createIndex({ email: 1 });\n// Insert and query\nconst user = { name: 'Alice', email: 'alice@example.com', cart: [{ productId: 1, name: 'Laptop', price: 999, quantity: 2 }] };\nawait db.users.insertOne(user);\nconst result = await db.users.findOne({ email: 'alice@example.com' });"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does denormalization optimize?",
                              "options": [
                                "Write speed",
                                "Read speed",
                                "Storage",
                                "Indexing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What stores data in MongoDB?",
                              "options": [
                                "Tables",
                                "Documents",
                                "Rows",
                                "Columns"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What improves MongoDB query speed?",
                              "options": [
                                "Denormalization",
                                "Indexes",
                                "Embedding",
                                "Aggregation"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What handles complex MongoDB queries?",
                              "options": [
                                "Indexes",
                                "Aggregation",
                                "Denormalization",
                                "Joins"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "MongoDB Documentation",
                              "url": "https://www.mongodb.com/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439226",
                        "title": "ORMs and Query Builders",
                        "slug": "orms-query-builders",
                        "description": "Learn to use ORMs and query builders like Prisma, TypeORM, and Knex.",
                        "order": 3,
                        "content": {
                          "explanation": "ORMs (Object-Relational Mappers) like Prisma and TypeORM map database tables to JavaScript objects, simplifying queries with a programmatic API. Query builders like Knex offer flexible SQL construction (e.g., `knex('users').where('id', 1)`). For example, Prisma’s `prisma.user.findMany()` fetches users, while TypeORM uses `repository.find()`. These tools abstract raw SQL, improve type safety (with TypeScript), and streamline development. Intermediate learners should use Prisma for type-safe queries, TypeORM for complex relationships, or Knex for raw SQL flexibility. Be cautious of ORM overhead for simple queries or query builder misuse causing inefficient SQL. These tools enhance productivity in web applications, integrating seamlessly with REST or GraphQL APIs.",
                          "examples": [
                            "// Prisma\nconst users = await prisma.user.findMany({ where: { name: 'Alice' } });",
                            "// Knex\nconst users = await knex('users').where('name', 'Alice').select('id', 'name');"
                          ],
                          "realWorldApplication": "Used in web apps for user management, order processing, or content delivery with simplified database access.",
                          "expertInsights": "Use Prisma for type safety; Knex for raw SQL control; optimize ORM queries to avoid N+1 issues.",
                          "commonMistakes": [
                            "Not optimizing ORM queries, causing N+1 problems",
                            "Using ORMs for simple queries, adding overhead",
                            "Ignoring TypeScript integration for type safety"
                          ],
                          "exercises": [
                            {
                              "title": "Query E-commerce Cart with Prisma",
                              "prompt": "Use Prisma to query an e-commerce cart, fetching users with their cart items.",
                              "difficulty": "medium",
                              "hints": [
                                "Define Prisma schema",
                                "Use findMany with include"
                              ],
                              "solution": "// schema.prisma\nmodel User {\n  id Int @id @default(autoincrement())\n  name String\n  carts Cart[]\n}\nmodel Cart {\n  id Int @id @default(autoincrement())\n  userId Int\n  user User @relation(fields: [userId], references: [id])\n  productId Int\n  quantity Int\n}\n\n// query.js\nconst { PrismaClient } = require('@prisma/client');\nconst prisma = new PrismaClient();\nconst usersWithCarts = await prisma.user.findMany({ include: { carts: true } });"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does an ORM do?",
                              "options": [
                                "Styles data",
                                "Maps tables to objects",
                                "Builds APIs",
                                "Indexes queries"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is Knex used for?",
                              "options": [
                                "ORM",
                                "Query building",
                                "Indexing",
                                "Migration"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What improves Prisma queries?",
                              "options": [
                                "TypeScript",
                                "CSS",
                                "Indexes",
                                "Joins"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Prisma Documentation",
                              "url": "https://www.prisma.io/docs/",
                              "type": "doc"
                            },
                            {
                              "title": "Knex Documentation",
                              "url": "https://knexjs.org/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439227",
                        "title": "Migrations, Backups, and Schema Evolution",
                        "slug": "migrations-backups-schema-evolution",
                        "description": "Learn strategies for database migrations, backups, and schema evolution.",
                        "order": 4,
                        "content": {
                          "explanation": "Database migrations manage schema changes (e.g., adding columns) using tools like Prisma Migrate or Knex migrations. For example, a migration might add a `status` column to a `carts` table. Backups save database snapshots (e.g., `pg_dump` for Postgres) to prevent data loss. Schema evolution strategies include versioning tables or using nullable columns for backward compatibility. Intermediate learners should write migrations for schema changes, automate backups, and plan for non-breaking changes. Be cautious of destructive migrations (e.g., dropping columns) without backups or untested migrations causing downtime. These practices ensure reliable database evolution in web applications, supporting continuous deployment.",
                          "examples": [
                            "// Knex migration\nexports.up = knex => knex.schema.table('carts', table => {\n  table.string('status').defaultTo('pending');\n});\nexports.down = knex => knex.schema.table('carts', table => {\n  table.dropColumn('status');\n});",
                            "// Postgres backup\npg_dump -U user dbname > backup.sql"
                          ],
                          "realWorldApplication": "Used in e-commerce for evolving schemas (e.g., adding order status) and ensuring data recovery.",
                          "expertInsights": "Test migrations in staging; automate backups with cron; use nullable columns for safe schema changes.",
                          "commonMistakes": [
                            "Not testing migrations before deployment",
                            "Skipping backups before destructive changes",
                            "Ignoring rollback strategies"
                          ],
                          "exercises": [
                            {
                              "title": "Implement E-commerce Migration",
                              "prompt": "Create a Knex migration to add a status column to a carts table and query carts by status.",
                              "difficulty": "hard",
                              "hints": [
                                "Use table.string for status",
                                "Add default value",
                                "Write query with where clause"
                              ],
                              "solution": "// migrations/20250101_add_status.js\nexports.up = async knex => {\n  await knex.schema.table('carts', table => {\n    table.string('status').defaultTo('pending');\n  });\n};\nexports.down = async knex => {\n  await knex.schema.table('carts', table => {\n    table.dropColumn('status');\n  });\n};\n\n// query.js\nconst carts = await knex('carts').where('status', 'pending').select('id', 'product_id');"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do migrations manage?",
                              "options": [
                                "Backups",
                                "Schema changes",
                                "Indexes",
                                "Queries"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What tool creates Postgres backups?",
                              "options": ["pg_dump", "knex", "prisma", "mongo"],
                              "correctOption": [0]
                            },
                            {
                              "question": "What ensures safe schema changes?",
                              "options": [
                                "Nullable columns",
                                "Indexes",
                                "Joins",
                                "Denormalization"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "Why test migrations?",
                              "options": [
                                "Improve speed",
                                "Prevent downtime",
                                "Reduce size",
                                "Simplify queries"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Prisma Migrate",
                              "url": "https://www.prisma.io/docs/concepts/components/prisma-migrate",
                              "type": "doc"
                            },
                            {
                              "title": "Postgres Backup",
                              "url": "https://www.postgresql.org/docs/current/backup.html",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T20:43:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439230",
    "title": "Authentication & Authorization",
    "slug": "authentication-authorization",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439231",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master authentication and authorization techniques to secure user identity and access control in web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439232",
            "title": "Authentication & Authorization",
            "slug": "auth-authz",
            "shortDescription": "An intermediate course on securing web applications with authentication and authorization techniques.",
            "longDescription": "This course explores authentication and authorization, covering session-based auth, JWTs, OIDC, implementing auth with providers like OAuth and NextAuth, role-based and attribute-based access control (RBAC/ABAC), and secure password flows with MFA and refresh token rotation for robust web security.",
            "tags": [
              "Authentication",
              "Authorization",
              "Security",
              "Web Development",
              "Intermediate"
            ],
            "thumbnail": "https://example.com/thumbnails/auth.jpg",
            "levels": [
              {
                "level": "Intermediate",
                "overview": "This intermediate level focuses on implementing secure authentication and authorization in web applications, ensuring user identity protection and controlled access.",
                "goals": [
                  "Understand authentication methods like sessions, JWTs, and OIDC",
                  "Implement authentication with providers like OAuth and NextAuth",
                  "Apply RBAC and ABAC for access control",
                  "Secure password flows with MFA and refresh token rotation"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439233",
                    "title": "Authentication & Authorization",
                    "slug": "auth-authz",
                    "description": "Learn to secure web applications with robust authentication and authorization techniques.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439234",
                        "title": "Auth Fundamentals (Sessions vs JWTs vs OIDC)",
                        "slug": "auth-fundamentals",
                        "description": "Understand core authentication methods: sessions, JWTs, and OIDC.",
                        "order": 1,
                        "content": {
                          "explanation": "Authentication verifies user identity, using methods like sessions, JSON Web Tokens (JWTs), or OpenID Connect (OIDC). Sessions store user data server-side, tracked via cookies, ideal for traditional web apps. JWTs are self-contained tokens encoding user data, suitable for stateless APIs but requiring secure storage. OIDC, built on OAuth 2.0, delegates auth to providers like Google, offering standardized flows. For example, a session-based login sets a cookie, while a JWT is sent in headers (`Authorization: Bearer <token>`). Intermediate learners should compare tradeoffs: sessions for simplicity, JWTs for APIs, OIDC for third-party auth. Be cautious of session hijacking or JWT leakage. These methods ensure secure user identity in web applications.",
                          "examples": [
                            "// Session-based auth\nconst session = require('express-session');\napp.use(session({ secret: 'key', cookie: { maxAge: 86400000 } }));\napp.post('/login', (req, res) => { req.session.userId = 1; res.json({ success: true }); });",
                            "// JWT auth\nconst jwt = require('jsonwebtoken');\nconst token = jwt.sign({ userId: 1 }, 'secret', { expiresIn: '1h' });"
                          ],
                          "realWorldApplication": "Used in web apps for user logins, API authentication, or single sign-on (SSO) with providers like Google.",
                          "expertInsights": "Use sessions for server-side apps; JWTs for microservices; OIDC for scalable SSO; always secure tokens.",
                          "commonMistakes": [
                            "Storing JWTs in localStorage, risking XSS",
                            "Not setting secure cookies for sessions",
                            "Ignoring OIDC’s refresh token flow"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Session-Based Login",
                              "prompt": "Create an Express route for login that sets a session cookie.",
                              "difficulty": "medium",
                              "hints": [
                                "Use express-session",
                                "Set userId in session"
                              ],
                              "solution": "const express = require('express');\nconst session = require('express-session');\nconst app = express();\napp.use(session({ secret: 'secret-key', cookie: { secure: true } }));\napp.post('/login', (req, res) => {\n  const { userId } = req.body;\n  req.session.userId = userId;\n  res.json({ success: true });\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What stores session data?",
                              "options": [
                                "Client",
                                "Server",
                                "Token",
                                "Browser"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is a JWT?",
                              "options": [
                                "Session cookie",
                                "Self-contained token",
                                "Database",
                                "Encryption key"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does OIDC use?",
                              "options": [
                                "Cookies",
                                "OAuth 2.0",
                                "JWT only",
                                "Sessions"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "JWT Introduction",
                              "url": "https://jwt.io/introduction/",
                              "type": "article"
                            },
                            {
                              "title": "OpenID Connect",
                              "url": "https://openid.net/connect/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439235",
                        "title": "Implementing Auth with Providers",
                        "slug": "auth-providers",
                        "description": "Learn to implement authentication using OAuth, Clerk, Auth0, or NextAuth.",
                        "order": 2,
                        "content": {
                          "explanation": "Auth providers like OAuth, Clerk, Auth0, and NextAuth simplify authentication by handling login flows, token management, and user data. OAuth 2.0 enables third-party logins (e.g., Google) via access tokens. Clerk and Auth0 offer managed auth with UI components and APIs, while NextAuth integrates seamlessly with Next.js for session or JWT-based auth. For example, NextAuth’s `signIn` function handles Google login. Intermediate learners should configure providers for social logins, secure API routes with tokens, and handle user sessions. Be cautious of misconfigured OAuth scopes or unprotected routes, which can expose vulnerabilities. These tools streamline secure auth in web applications, reducing custom code overhead.",
                          "examples": [
                            "// NextAuth setup\nimport NextAuth from 'next-auth';\nimport GoogleProvider from 'next-auth/providers/google';\nexport default NextAuth({\n  providers: [\n    GoogleProvider({ clientId: process.env.GOOGLE_ID, clientSecret: process.env.GOOGLE_SECRET })\n  ]\n});",
                            "// Protected route with NextAuth\nimport { getSession } from 'next-auth/react';\nconst handler = async (req, res) => {\n  const session = await getSession({ req });\n  if (!session) return res.status(401).json({ error: 'Unauthorized' });\n  res.json({ user: session.user });\n};"
                          ],
                          "realWorldApplication": "Used in apps for Google/Facebook logins, secure dashboards, or SSO across services.",
                          "expertInsights": "Use NextAuth for Next.js apps; Clerk for fast setup; scope OAuth requests minimally; validate tokens server-side.",
                          "commonMistakes": [
                            "Exposing client secrets in frontend code",
                            "Not validating provider tokens",
                            "Ignoring session expiration"
                          ],
                          "exercises": [
                            {
                              "title": "Implement NextAuth Login",
                              "prompt": "Set up NextAuth for Google login and protect a route with session checking.",
                              "difficulty": "medium",
                              "hints": [
                                "Configure GoogleProvider",
                                "Use getSession for route protection"
                              ],
                              "solution": "import NextAuth from 'next-auth';\nimport GoogleProvider from 'next-auth/providers/google';\nexport default NextAuth({\n  providers: [\n    GoogleProvider({ clientId: process.env.GOOGLE_ID, clientSecret: process.env.GOOGLE_SECRET })\n  ]\n});\n\n// pages/api/protected.js\nimport { getSession } from 'next-auth/react';\nexport default async (req, res) => {\n  const session = await getSession({ req });\n  if (!session) return res.status(401).json({ error: 'Unauthorized' });\n  res.json({ user: session.user.name });\n};"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does OAuth provide?",
                              "options": [
                                "Encryption",
                                "Third-party login",
                                "Database",
                                "Styling"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is NextAuth used for?",
                              "options": [
                                "Styling",
                                "Authentication",
                                "Routing",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What protects routes in NextAuth?",
                              "options": [
                                "getSession",
                                "signIn",
                                "useSession",
                                "getToken"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What risks exposing secrets?",
                              "options": [
                                "Server code",
                                "Frontend code",
                                "Database",
                                "Tokens"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 100,
                          "resources": [
                            {
                              "title": "NextAuth Documentation",
                              "url": "https://next-auth.js.org/",
                              "type": "doc"
                            },
                            {
                              "title": "OAuth 2.0",
                              "url": "https://oauth.net/2/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439236",
                        "title": "RBAC and ABAC Patterns",
                        "slug": "rbac-abac-patterns",
                        "description": "Implement role-based and attribute-based access control.",
                        "order": 3,
                        "content": {
                          "explanation": "Role-Based Access Control (RBAC) restricts access based on user roles (e.g., admin, user), while Attribute-Based Access Control (ABAC) uses attributes (e.g., user location, department) for fine-grained control. For example, RBAC might allow only admins to delete users, while ABAC could restrict access to users in a specific region. Implement RBAC with middleware checking `user.role` and ABAC with attribute checks (e.g., `user.department === 'HR'`). Intermediate learners should design role-based middleware and combine with attribute checks for complex policies. Be cautious of overly permissive roles or complex ABAC rules, which can lead to security gaps or maintenance issues. These patterns ensure secure access control in web applications.",
                          "examples": [
                            "// RBAC middleware\nconst restrictTo = (roles) => (req, res, next) => {\n  if (!roles.includes(req.user.role)) return res.status(403).json({ error: 'Forbidden' });\n  next();\n};\napp.get('/admin', restrictTo(['admin']), (req, res) => res.json({ data: 'Admin content' }));",
                            "// ABAC check\nif (user.department === 'HR' && user.clearance > 5) { /* Allow access */ }"
                          ],
                          "realWorldApplication": "Used in enterprise apps for admin dashboards or apps restricting data by user attributes like location.",
                          "expertInsights": "Use RBAC for simple apps; combine with ABAC for granular control; store roles/attributes securely.",
                          "commonMistakes": [
                            "Granting excessive permissions in roles",
                            "Not validating attributes server-side",
                            "Hardcoding access rules in code"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Role-Restricted Endpoint",
                              "prompt": "Create an Express middleware to restrict an endpoint to admin users only.",
                              "difficulty": "medium",
                              "hints": [
                                "Check user.role in middleware",
                                "Return 403 for unauthorized"
                              ],
                              "solution": "const express = require('express');\nconst app = express();\nconst restrictTo = (roles) => (req, res, next) => {\n  const user = req.user || { role: 'user' };\n  if (!roles.includes(user.role)) return res.status(403).json({ error: 'Forbidden' });\n  next();\n};\napp.get('/admin', restrictTo(['admin']), (req, res) => {\n  res.json({ message: 'Admin access granted' });\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does RBAC use for access control?",
                              "options": [
                                "Attributes",
                                "Roles",
                                "Tokens",
                                "Sessions"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does ABAC check?",
                              "options": [
                                "Roles",
                                "Attributes",
                                "Cookies",
                                "Endpoints"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What HTTP code for forbidden access?",
                              "options": ["401", "403", "404", "500"],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "RBAC vs ABAC",
                              "url": "https://www.okta.com/identity-101/rbac-vs-abac/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439237",
                        "title": "Secure Password Flows, MFA, Refresh Token Rotation",
                        "slug": "secure-password-mfa",
                        "description": "Learn secure password handling, MFA, and refresh token rotation.",
                        "order": 4,
                        "content": {
                          "explanation": "Secure password flows use hashing (e.g., bcrypt) to store passwords, never plaintext. Multi-Factor Authentication (MFA) adds layers like SMS or TOTP (e.g., Google Authenticator). Refresh token rotation issues short-lived access tokens and long-lived refresh tokens, rotating the latter on use to prevent replay attacks. For example, bcrypt hashes passwords (`bcrypt.hash(password, 10)`), and refresh tokens are stored securely server-side. Intermediate learners should implement password hashing, add MFA with TOTP, and rotate refresh tokens in auth flows. Be cautious of weak hashing algorithms or insecure token storage, risking breaches. These practices ensure robust user security in web applications.",
                          "examples": [
                            "// Password hashing\nconst bcrypt = require('bcrypt');\nconst hash = await bcrypt.hash('password', 10);\nconst isValid = await bcrypt.compare('password', hash);",
                            "// Refresh token rotation\nconst refreshToken = jwt.sign({ userId: 1 }, 'refresh-secret', { expiresIn: '7d' });"
                          ],
                          "realWorldApplication": "Used in banking apps for secure logins, MFA for user accounts, or APIs with token-based auth.",
                          "expertInsights": "Use bcrypt or Argon2 for hashing; implement TOTP for MFA; rotate refresh tokens to mitigate theft.",
                          "commonMistakes": [
                            "Storing plaintext passwords",
                            "Not rotating refresh tokens",
                            "Ignoring MFA for sensitive apps"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Secure Login and Protected Route",
                              "prompt": "Create an Express login route with bcrypt hashing and a protected route using JWT with role-based access.",
                              "difficulty": "hard",
                              "hints": [
                                "Use bcrypt for password hashing",
                                "Issue JWT with role",
                                "Check role in middleware"
                              ],
                              "solution": "const express = require('express');\nconst bcrypt = require('bcrypt');\nconst jwt = require('jsonwebtoken');\nconst app = express();\napp.use(express.json());\nconst users = [{ id: 1, role: 'admin', password: await bcrypt.hash('pass', 10) }];\napp.post('/login', async (req, res) => {\n  const { password } = req.body;\n  const user = users[0];\n  if (await bcrypt.compare(password, user.password)) {\n    const token = jwt.sign({ id: user.id, role: user.role }, 'secret', { expiresIn: '1h' });\n    res.json({ token });\n  } else {\n    res.status(401).json({ error: 'Invalid credentials' });\n  }\n});\nconst auth = (req, res, next) => {\n  const token = req.headers.authorization?.split(' ')[1];\n  try {\n    req.user = jwt.verify(token, 'secret');\n    next();\n  } catch {\n    res.status(401).json({ error: 'Unauthorized' });\n  }\n};\napp.get('/admin', auth, (req, res) => {\n  if (req.user.role !== 'admin') return res.status(403).json({ error: 'Forbidden' });\n  res.json({ message: 'Admin access' });\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What hashes passwords securely?",
                              "options": [
                                "MD5",
                                "bcrypt",
                                "SHA-1",
                                "Plaintext"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does MFA add?",
                              "options": [
                                "Single login",
                                "Extra auth layer",
                                "Caching",
                                "Styling"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What prevents token replay?",
                              "options": [
                                "Hashing",
                                "Refresh token rotation",
                                "MFA",
                                "Sessions"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Where are refresh tokens stored?",
                              "options": [
                                "Client",
                                "Server",
                                "Browser",
                                "LocalStorage"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 110,
                          "resources": [
                            {
                              "title": "bcrypt Documentation",
                              "url": "https://www.npmjs.com/package/bcrypt",
                              "type": "doc"
                            },
                            {
                              "title": "Refresh Token Rotation",
                              "url": "https://auth0.com/docs/secure/tokens/refresh-token-rotation",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T20:47:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439240",
    "title": "Backend Patterns & Microservices",
    "slug": "backend-patterns-microservices",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439241",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master scalable backend design and microservices architecture for robust web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439242",
            "title": "Backend Patterns & Microservices Intro",
            "slug": "backend-patterns-microservices-intro",
            "shortDescription": "An intermediate course on designing scalable backend systems and introducing microservices architecture.",
            "longDescription": "This course explores backend design patterns and microservices, covering monolith vs microservices tradeoffs, defining service boundaries and API contracts, event-driven design with pub/sub, and implementing background jobs with worker queues like BullMQ and Redis for scalable web applications.",
            "tags": [
              "Backend",
              "Microservices",
              "Event-Driven",
              "Web Development",
              "Intermediate"
            ],
            "thumbnail": "https://example.com/thumbnails/backend-patterns.jpg",
            "levels": [
              {
                "level": "Intermediate",
                "overview": "This intermediate level focuses on designing scalable backend systems and introducing microservices, with patterns for service boundaries, event-driven architecture, and background job processing.",
                "goals": [
                  "Understand tradeoffs between monolith and microservices architectures",
                  "Define service boundaries and API contracts for modular systems",
                  "Implement event-driven design using pub/sub patterns",
                  "Use background jobs and worker queues for asynchronous tasks"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439243",
                    "title": "Backend Patterns & Microservices Intro",
                    "slug": "backend-patterns-microservices",
                    "description": "Learn scalable backend design patterns and microservices fundamentals for web applications.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439244",
                        "title": "Monolith vs Microservices Tradeoffs",
                        "slug": "monolith-vs-microservices",
                        "description": "Understand the tradeoffs between monolith and microservices architectures.",
                        "order": 1,
                        "content": {
                          "explanation": "A monolith architecture combines all application logic into a single codebase, simplifying development and deployment but risking complexity as the app scales. Microservices split functionality into independent services, each with its own codebase and database, improving scalability and team autonomy but increasing operational complexity (e.g., networking, orchestration). For example, an e-commerce app might start as a monolith but split into user, order, and payment services for scale. Tradeoffs include development speed (monolith) vs flexibility (microservices) and deployment simplicity (monolith) vs fault isolation (microservices). Intermediate learners should evaluate use cases, starting with monoliths for small apps and adopting microservices for large-scale needs. Be cautious of premature microservices adoption, which can overcomplicate small projects. These concepts guide scalable backend design in web applications.",
                          "examples": [
                            "// Monolith (Express)\napp.get('/users', (req, res) => db.users.find());\napp.get('/orders', (req, res) => db.orders.find());",
                            "// Microservices\n// User service\napp.get('/users', (req, res) => userDb.find());\n// Order service\napp.get('/orders', (req, res) => orderDb.find());"
                          ],
                          "realWorldApplication": "Monoliths for small startups; microservices for large-scale apps like e-commerce or streaming platforms.",
                          "expertInsights": "Start with a monolith; modularize for future microservices; use Kubernetes for microservices orchestration.",
                          "commonMistakes": [
                            "Adopting microservices too early",
                            "Not modularizing monoliths for future splitting",
                            "Ignoring inter-service communication overhead"
                          ],
                          "exercises": [
                            {
                              "title": "Design Service Boundaries",
                              "prompt": "Define service boundaries for an e-commerce app splitting users, orders, and products into services.",
                              "difficulty": "medium",
                              "hints": [
                                "Identify distinct domains",
                                "Assign APIs to each service"
                              ],
                              "solution": "// User Service\nGET /users - List users\nPOST /users - Create user\n\n// Order Service\nGET /orders - List orders\nPOST /orders - Create order\n\n// Product Service\nGET /products - List products\nPOST /products - Add product"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is a monolith?",
                              "options": [
                                "Single codebase",
                                "Multiple services",
                                "Database",
                                "API"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What do microservices improve?",
                              "options": [
                                "Development speed",
                                "Scalability",
                                "Simplicity",
                                "Size"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is a microservices challenge?",
                              "options": [
                                "Slow queries",
                                "Operational complexity",
                                "Small codebase",
                                "Single deployment"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "Microservices Guide",
                              "url": "https://microservices.io/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439245",
                        "title": "Service Boundaries & API Contracts",
                        "slug": "service-boundaries-api-contracts",
                        "description": "Learn to define service boundaries and API contracts for modular systems.",
                        "order": 2,
                        "content": {
                          "explanation": "Service boundaries define the scope of each microservice, ensuring single responsibility (e.g., a user service handles only user-related logic). API contracts, often defined with OpenAPI or GraphQL schemas, specify endpoints, inputs, and outputs (e.g., `GET /users` returns `{ id, name }`). Clear boundaries prevent overlap, while contracts ensure predictable communication. For example, an order service’s contract might define `POST /orders` with a specific payload schema. Intermediate learners should design services around business domains (e.g., users, orders) and document contracts with OpenAPI. Be cautious of tight coupling between services or vague contracts, which lead to integration issues. These practices ensure modular, maintainable backends in web applications.",
                          "examples": [
                            "# OpenAPI Contract\npaths:\n  /orders:\n    post:\n      requestBody:\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                userId: { type: integer }\n                productId: { type: integer }\n      responses:\n        '201':\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  id: { type: integer }",
                            "// Service boundary\n// Order Service\nconst createOrder = async (userId, productId) => orderDb.insert({ userId, productId });"
                          ],
                          "realWorldApplication": "Used in e-commerce for separate user, order, and payment services with clear API contracts.",
                          "expertInsights": "Align boundaries with business domains; use OpenAPI for REST contracts; validate inputs against schemas.",
                          "commonMistakes": [
                            "Overlapping service responsibilities",
                            "Not documenting API contracts",
                            "Ignoring input validation"
                          ],
                          "exercises": [
                            {
                              "title": "Define Service Boundaries",
                              "prompt": "Design service boundaries and an OpenAPI contract for an e-commerce app’s user and order services.",
                              "difficulty": "medium",
                              "hints": [
                                "Separate user and order logic",
                                "Define POST /orders contract"
                              ],
                              "solution": "# User Service\n- GET /users\n- POST /users\n# Order Service\n- GET /orders\n- POST /orders\n\n# OpenAPI for Order Service\npaths:\n  /orders:\n    post:\n      summary: Create order\n      requestBody:\n        content:\n          application/json:\n            schema:\n              type: object\n              properties:\n                userId: { type: integer }\n                productId: { type: integer }\n      responses:\n        '201':\n          content:\n            application/json:\n              schema:\n                type: object\n                properties:\n                  id: { type: integer }\n                  userId: { type: integer }\n                  productId: { type: integer }"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do service boundaries define?",
                              "options": [
                                "Database",
                                "Service scope",
                                "Frontend",
                                "API routes"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What specifies API inputs/outputs?",
                              "options": [
                                "Contracts",
                                "Indexes",
                                "Queries",
                                "Styles"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What aligns with business domains?",
                              "options": [
                                "API routes",
                                "Service boundaries",
                                "Databases",
                                "Frontend"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does OpenAPI document?",
                              "options": [
                                "Frontend",
                                "API contracts",
                                "Databases",
                                "Styles"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 100,
                          "resources": [
                            {
                              "title": "OpenAPI Specification",
                              "url": "https://swagger.io/specification/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439246",
                        "title": "Event-Driven Design Fundamentals",
                        "slug": "event-driven-design",
                        "description": "Learn pub/sub patterns for event-driven architecture.",
                        "order": 3,
                        "content": {
                          "explanation": "Event-driven design decouples services using events, where producers publish events (e.g., ‘order.created’) and subscribers consume them. Pub/sub systems like Redis Pub/Sub or Kafka enable this pattern. For example, an order service publishes an ‘order.created’ event, and a notification service subscribes to send emails. This approach improves scalability and flexibility in microservices. Intermediate learners should implement pub/sub with Redis, ensuring events carry necessary data (e.g., order ID). Be cautious of event loss in unreliable systems or complex event dependencies. Event-driven design is key for asynchronous, scalable backends in web applications like e-commerce or real-time systems.",
                          "examples": [
                            "// Redis Pub/Sub (Publisher)\nconst redis = require('redis');\nconst publisher = redis.createClient();\npublisher.publish('order.created', JSON.stringify({ orderId: 1 }));",
                            "// Subscriber\nconst subscriber = redis.createClient();\nsubscriber.subscribe('order.created', (message) => {\n  console.log('New order:', JSON.parse(message));\n});"
                          ],
                          "realWorldApplication": "Used in e-commerce for order processing, notifications, or inventory updates triggered by events.",
                          "expertInsights": "Use Redis for simple pub/sub; Kafka for high-throughput; include event schemas for consistency.",
                          "commonMistakes": [
                            "Not handling event loss",
                            "Publishing incomplete event data",
                            "Creating cyclic event dependencies"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Pub/Sub for Notifications",
                              "prompt": "Create a Redis pub/sub system where an order service publishes an event and a notification service subscribes to log it.",
                              "difficulty": "medium",
                              "hints": [
                                "Use redis.createClient",
                                "Publish JSON data"
                              ],
                              "solution": "const redis = require('redis');\n// Publisher (Order Service)\nconst publisher = redis.createClient();\nconst createOrder = async (orderId) => {\n  await publisher.publish('order.created', JSON.stringify({ orderId }));\n};\n\n// Subscriber (Notification Service)\nconst subscriber = redis.createClient();\nsubscriber.subscribe('order.created', (message) => {\n  const { orderId } = JSON.parse(message);\n  console.log(`Notify: Order ${orderId} created`);\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does pub/sub enable?",
                              "options": [
                                "Synchronous calls",
                                "Event-driven design",
                                "Database queries",
                                "Styling"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What publishes events?",
                              "options": [
                                "Subscriber",
                                "Publisher",
                                "Database",
                                "API"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is a pub/sub system?",
                              "options": [
                                "Redis",
                                "Express",
                                "MongoDB",
                                "React"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 100,
                          "resources": [
                            {
                              "title": "Redis Pub/Sub",
                              "url": "https://redis.io/docs/manual/pubsub/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439247",
                        "title": "Background Jobs & Worker Queues",
                        "slug": "background-jobs-queues",
                        "description": "Learn to implement background jobs with BullMQ and Redis queues.",
                        "order": 4,
                        "content": {
                          "explanation": "Background jobs handle time-consuming tasks (e.g., image processing, email sending) asynchronously using worker queues like BullMQ with Redis. For example, a job to send an email is added to a queue (`queue.add('sendEmail', { to: 'user@example.com' })`) and processed by a worker. BullMQ supports retries, priorities, and job status tracking. Intermediate learners should set up BullMQ for tasks like email sending, ensuring reliable processing with Redis. Be cautious of queue bottlenecks or unhandled job failures, which can delay tasks. Background jobs improve performance and user experience in web applications by offloading heavy tasks.",
                          "examples": [
                            "// BullMQ Queue\nconst Queue = require('bull');\nconst emailQueue = new Queue('email', 'redis://localhost:6379');\nemailQueue.add('sendEmail', { to: 'user@example.com', subject: 'Welcome' });",
                            "// Worker\nconst emailQueue = new Queue('email', 'redis://localhost:6379');\nemailQueue.process('sendEmail', async (job) => {\n  await sendEmail(job.data.to, job.data.subject);\n});"
                          ],
                          "realWorldApplication": "Used in e-commerce for sending order confirmation emails or processing uploaded product images.",
                          "expertInsights": "Use BullMQ for robust queues; monitor job failures; scale workers with demand.",
                          "commonMistakes": [
                            "Not handling job failures",
                            "Overloading queues with large tasks",
                            "Not scaling workers for high load"
                          ],
                          "exercises": [
                            {
                              "title": "Add Background Job for Email",
                              "prompt": "Implement a BullMQ queue to send an email as a background job.",
                              "difficulty": "hard",
                              "hints": [
                                "Create a BullMQ queue",
                                "Add a job with email data",
                                "Process with a worker"
                              ],
                              "solution": "const Queue = require('bull');\nconst emailQueue = new Queue('email', 'redis://localhost:6379');\n\n// Add job\nconst sendEmailJob = async (to, subject) => {\n  await emailQueue.add('sendEmail', { to, subject });\n};\n\n// Worker\nemailQueue.process('sendEmail', async (job) => {\n  console.log(`Sending email to ${job.data.to}: ${job.data.subject}`);\n  // Simulate email sending\n  return { success: true };\n});\n\n// Usage\nsendEmailJob('user@example.com', 'Welcome');"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do background jobs handle?",
                              "options": [
                                "Synchronous tasks",
                                "Asynchronous tasks",
                                "Frontend",
                                "Styles"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is BullMQ used for?",
                              "options": [
                                "Database",
                                "Worker queues",
                                "API routes",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What stores BullMQ jobs?",
                              "options": [
                                "MongoDB",
                                "Redis",
                                "Postgres",
                                "File"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Why use background jobs?",
                              "options": [
                                "Improve UX",
                                "Reduce size",
                                "Simplify code",
                                "Add styles"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 110,
                          "resources": [
                            {
                              "title": "BullMQ Documentation",
                              "url": "https://docs.bullmq.io/",
                              "type": "doc"
                            },
                            {
                              "title": "Redis Documentation",
                              "url": "https://redis.io/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T20:50:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439250",
    "title": "Realtime & WebSockets",
    "slug": "realtime-websockets",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439251",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master realtime communication and WebSockets for scalable, interactive web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439252",
            "title": "Realtime & WebSockets",
            "slug": "realtime-websockets",
            "shortDescription": "An intermediate course on building realtime web applications using WebSockets and pub/sub systems.",
            "longDescription": "This course explores WebSocket fundamentals, pub/sub architecture with Redis or managed services like Pusher and Supabase Realtime, and scaling strategies with rooms, topics, and presence for interactive web applications.",
            "tags": [
              "WebSockets",
              "Realtime",
              "Pub/Sub",
              "Web Development",
              "Intermediate"
            ],
            "thumbnail": "https://example.com/thumbnails/realtime-websockets.jpg",
            "levels": [
              {
                "level": "Intermediate",
                "overview": "This intermediate level focuses on implementing realtime features using WebSockets, pub/sub systems, and scaling techniques for web applications.",
                "goals": [
                  "Understand WebSocket basics and fallback strategies like SSE",
                  "Implement pub/sub architecture with Redis or managed services",
                  "Handle scale with rooms, topics, and presence features"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439253",
                    "title": "Realtime & WebSockets",
                    "slug": "realtime-websockets",
                    "description": "Learn to build scalable realtime features using WebSockets and pub/sub systems.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439254",
                        "title": "WebSocket Basics and Fallback Strategies",
                        "slug": "websocket-basics",
                        "description": "Learn WebSocket fundamentals and fallback strategies like Server-Sent Events (SSE).",
                        "order": 1,
                        "content": {
                          "explanation": "WebSockets enable bidirectional communication between client and server over a single connection, ideal for realtime features like chat or live updates. The `WebSocket` API (`new WebSocket('ws://example.com')`) handles messages via `onmessage` and `onclose` events. Server-Sent Events (SSE) provide a fallback for unidirectional updates, using `EventSource` to stream data over HTTP. For example, a WebSocket server with Socket.IO can broadcast messages, while SSE streams updates like stock prices. Intermediate learners should implement a WebSocket connection and fallback to SSE for older browsers. Be cautious of connection limits or lack of error handling, which can disrupt realtime apps. These techniques enable responsive, interactive web experiences.",
                          "examples": [
                            "// Client WebSocket\nconst ws = new WebSocket('ws://example.com');\nws.onmessage = (event) => console.log(event.data);\nws.onclose = () => console.log('Disconnected');",
                            "// SSE client\nconst source = new EventSource('/events');\nsource.onmessage = (event) => console.log(event.data);"
                          ],
                          "realWorldApplication": "Used in chat apps, live sports updates, or collaborative tools for instant data exchange.",
                          "expertInsights": "Use Socket.IO for cross-browser WebSocket support; implement SSE for simple push updates; handle connection errors gracefully.",
                          "commonMistakes": [
                            "Not handling WebSocket disconnections",
                            "Ignoring SSE for fallback support",
                            "Not securing WebSocket connections"
                          ],
                          "exercises": [
                            {
                              "title": "Build a WebSocket Chat",
                              "prompt": "Create a simple WebSocket-based chat server and client using Socket.IO.",
                              "difficulty": "medium",
                              "hints": [
                                "Use Socket.IO for WebSocket",
                                "Broadcast messages to all clients"
                              ],
                              "solution": "// Server\nconst io = require('socket.io')(3000);\nio.on('connection', (socket) => {\n  socket.on('message', (msg) => io.emit('message', msg));\n});\n\n// Client\nconst socket = io('http://localhost:3000');\nsocket.on('message', (msg) => console.log('Received:', msg));\nsocket.emit('message', 'Hello, world!');"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does WebSocket enable?",
                              "options": [
                                "Unidirectional",
                                "Bidirectional",
                                "HTTP",
                                "Static"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is SSE used for?",
                              "options": [
                                "Bidirectional",
                                "Server push",
                                "File transfer",
                                "Styling"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What handles WebSocket messages?",
                              "options": [
                                "onmessage",
                                "onclose",
                                "onopen",
                                "All of these"
                              ],
                              "correctOption": [3]
                            }
                          ],
                          "estimatedTime": 80,
                          "resources": [
                            {
                              "title": "MDN WebSocket",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/API/WebSocket",
                              "type": "article"
                            },
                            {
                              "title": "MDN SSE",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439255",
                        "title": "Pub/Sub Architecture with Redis or Managed Services",
                        "slug": "pubsub-architecture",
                        "description": "Learn pub/sub architecture using Redis or managed services like Pusher or Supabase Realtime.",
                        "order": 2,
                        "content": {
                          "explanation": "Pub/sub (publish/subscribe) architecture decouples services by allowing publishers to send messages to channels and subscribers to receive them. Redis Pub/Sub enables this with `PUBLISH` and `SUBSCRIBE` commands, while managed services like Pusher or Supabase Realtime simplify setup with APIs and WebSocket integration. For example, a chat app publishes messages to a Redis channel (`chat:room1`), and subscribers receive updates in real time. Intermediate learners should implement pub/sub with Redis for custom setups or Pusher for managed solutions, ensuring messages include relevant data (e.g., user ID, message). Be cautious of message loss in Redis Pub/Sub or rate limits in managed services. Pub/sub powers scalable, realtime features in web applications.",
                          "examples": [
                            "// Redis Pub/Sub (Server)\nconst redis = require('redis');\nconst publisher = redis.createClient();\npublisher.publish('chat:room1', JSON.stringify({ user: 'Alice', msg: 'Hi' }));\n\n// Subscriber\nconst subscriber = redis.createClient();\nsubscriber.subscribe('chat:room1', (msg) => console.log(JSON.parse(msg)));",
                            "// Pusher (Server)\nconst Pusher = require('pusher');\nconst pusher = new Pusher({ appId: 'id', key: 'key', secret: 'secret' });\npusher.trigger('room1', 'message', { user: 'Alice', msg: 'Hi' });"
                          ],
                          "realWorldApplication": "Used in chat apps, live notifications, or collaborative tools for broadcasting updates.",
                          "expertInsights": "Use Redis for custom pub/sub; Pusher for ease of use; Supabase for database-integrated realtime; validate message schemas.",
                          "commonMistakes": [
                            "Not handling message loss in Redis",
                            "Ignoring rate limits in managed services",
                            "Sending incomplete message data"
                          ],
                          "exercises": [
                            {
                              "title": "Build a Pub/Sub Chat",
                              "prompt": "Create a chat system using Redis pub/sub to broadcast messages to a room.",
                              "difficulty": "medium",
                              "hints": [
                                "Use Redis publish/subscribe",
                                "Include user and message in payload"
                              ],
                              "solution": "const redis = require('redis');\nconst publisher = redis.createClient();\nconst subscriber = redis.createClient();\n\n// Server\nsubscriber.subscribe('chat:room1', (msg) => {\n  console.log('Received:', JSON.parse(msg));\n});\nconst sendMessage = async (room, user, msg) => {\n  await publisher.publish(`chat:${room}`, JSON.stringify({ user, msg }));\n};\n\n// Usage\nsendMessage('room1', 'Alice', 'Hello, room!');"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does pub/sub decouple?",
                              "options": [
                                "Frontend",
                                "Services",
                                "Database",
                                "Styles"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does Redis Pub/Sub use?",
                              "options": [
                                "Channels",
                                "Tables",
                                "Endpoints",
                                "Components"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What is a managed pub/sub service?",
                              "options": [
                                "Express",
                                "Pusher",
                                "MongoDB",
                                "React"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What can Redis Pub/Sub lose?",
                              "options": [
                                "Styles",
                                "Messages",
                                "Indexes",
                                "Routes"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "Redis Pub/Sub",
                              "url": "https://redis.io/docs/manual/pubsub/",
                              "type": "doc"
                            },
                            {
                              "title": "Pusher Documentation",
                              "url": "https://pusher.com/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439256",
                        "title": "Handling Scale, Rooms/Topics, and Presence",
                        "slug": "scale-rooms-presence",
                        "description": "Learn to scale WebSockets with rooms, topics, and presence features.",
                        "order": 3,
                        "content": {
                          "explanation": "Scaling WebSockets involves managing connections, rooms/topics, and presence for large user bases. Rooms or topics (e.g., `room:chat1`) group users for targeted messaging, reducing broadcast overhead. Presence tracks online users (e.g., `{ userId: 1, status: 'online' }`) via WebSocket heartbeats or Redis sets. For example, Socket.IO’s `io.to('room1')` sends messages to a specific room. Managed services like Supabase Realtime handle scaling automatically. Intermediate learners should implement rooms for chat apps and presence with Redis, ensuring efficient connection management. Be cautious of connection limits or untracked presence, which can degrade performance. These techniques enable scalable, interactive web applications like chats or live dashboards.",
                          "examples": [
                            "// Socket.IO Rooms\nconst io = require('socket.io')(3000);\nio.on('connection', (socket) => {\n  socket.join('room1');\n  socket.on('message', (msg) => io.to('room1').emit('message', msg));\n});",
                            "// Presence with Redis\nconst redis = require('redis');\nconst client = redis.createClient();\nclient.sadd('presence:room1', 'user1');\nclient.smembers('presence:room1', (err, users) => console.log('Online:', users));"
                          ],
                          "realWorldApplication": "Used in chat apps for room-based messaging or live dashboards for user presence tracking.",
                          "expertInsights": "Use rooms for targeted messaging; track presence with Redis sets; scale with load balancers or managed services.",
                          "commonMistakes": [
                            "Broadcasting to all users instead of rooms",
                            "Not cleaning up presence data",
                            "Ignoring WebSocket connection limits"
                          ],
                          "exercises": [
                            {
                              "title": "Build a Presence Indicator",
                              "prompt": "Create a Socket.IO system with a room and presence tracking using Redis to show online users.",
                              "difficulty": "hard",
                              "hints": [
                                "Use Socket.IO for rooms",
                                "Track presence with Redis sets"
                              ],
                              "solution": "const io = require('socket.io')(3000);\nconst redis = require('redis');\nconst client = redis.createClient();\n\nio.on('connection', async (socket) => {\n  const userId = socket.id;\n  socket.join('room1');\n  await client.sadd('presence:room1', userId);\n  const users = await client.smembers('presence:room1');\n  io.to('room1').emit('presence', users);\n  socket.on('disconnect', async () => {\n    await client.srem('presence:room1', userId);\n    const updatedUsers = await client.smembers('presence:room1');\n    io.to('room1').emit('presence', updatedUsers);\n  });\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do rooms reduce?",
                              "options": [
                                "Connections",
                                "Broadcast overhead",
                                "Styles",
                                "Queries"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What tracks online users?",
                              "options": [
                                "Rooms",
                                "Presence",
                                "Topics",
                                "Endpoints"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What stores presence data?",
                              "options": [
                                "MongoDB",
                                "Redis sets",
                                "Postgres",
                                "Files"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "Socket.IO Rooms",
                              "url": "https://socket.io/docs/v4/rooms/",
                              "type": "doc"
                            },
                            {
                              "title": "Supabase Realtime",
                              "url": "https://supabase.com/docs/guides/realtime",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T20:52:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439260",
    "title": "Testing & QA (Client + Server)",
    "slug": "testing-qa",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439261",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master testing and quality assurance techniques for client and server to prevent regressions and improve confidence in web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439262",
            "title": "Testing & QA (Client + Server)",
            "slug": "testing-qa-client-server",
            "shortDescription": "An intermediate course on testing web applications for both client and server to ensure reliability and prevent regressions.",
            "longDescription": "This course covers unit testing with Jest/Vitest for frontend and backend, integration and end-to-end testing with Supertest and Playwright, testing strategies using mocks, fixtures, and CI integration, and contract testing with Pact to ensure API stability in web applications.",
            "tags": ["Testing", "QA", "Jest", "Playwright", "Intermediate"],
            "thumbnail": "https://example.com/thumbnails/testing-qa.jpg",
            "levels": [
              {
                "level": "Intermediate",
                "overview": "This intermediate level focuses on implementing comprehensive testing strategies for client and server, ensuring robust and reliable web applications.",
                "goals": [
                  "Write unit tests for frontend and backend using Jest or Vitest",
                  "Implement integration and end-to-end tests with Supertest and Playwright",
                  "Apply testing strategies like mocks, fixtures, and CI integration",
                  "Use contract testing with Pact for API stability"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439263",
                    "title": "Testing & QA (Client + Server)",
                    "slug": "testing-qa",
                    "description": "Learn to implement testing and QA practices for client and server to prevent regressions and improve code confidence.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439264",
                        "title": "Unit Tests (Jest / Vitest)",
                        "slug": "unit-tests-jest-vitest",
                        "description": "Learn to write unit tests for frontend and backend using Jest or Vitest.",
                        "order": 1,
                        "content": {
                          "explanation": "Unit tests verify individual functions or components in isolation, ensuring they work as expected. Jest and Vitest are popular testing frameworks for JavaScript, supporting assertions (e.g., `expect(value).toBe(expected)`), mocks, and test suites. For example, a unit test for a function `add(a, b)` checks if `add(2, 3)` returns `5`. In frontend, test React components with Jest and `@testing-library/react`; in backend, test Express routes or utilities. Intermediate learners should write tests for key modules, covering edge cases and using mocks for dependencies. Be cautious of over-mocking or incomplete test coverage, which can miss bugs. Unit tests build confidence in code changes for web applications.",
                          "examples": [
                            "// Backend unit test (Jest)\nconst { add } = require('./math');\ntest('adds two numbers', () => {\n  expect(add(2, 3)).toBe(5);\n});",
                            "// Frontend unit test (React)\nimport { render, screen } from '@testing-library/react';\ntest('renders button', () => {\n  render(<Button>Click me</Button>);\n  expect(screen.getByText('Click me')).toBeInTheDocument();\n});"
                          ],
                          "realWorldApplication": "Used in web apps to test utility functions, React components, or API logic for reliability.",
                          "expertInsights": "Use Jest for feature-rich testing; Vitest for faster Vite integration; aim for 80%+ code coverage; test edge cases.",
                          "commonMistakes": [
                            "Over-mocking dependencies, hiding real behavior",
                            "Writing tests without edge cases",
                            "Ignoring test coverage reports"
                          ],
                          "exercises": [
                            {
                              "title": "Add Unit Tests for Module",
                              "prompt": "Write Jest unit tests for a function that calculates cart total in an e-commerce app.",
                              "difficulty": "medium",
                              "hints": [
                                "Test edge cases like empty cart",
                                "Use expect().toBe()"
                              ],
                              "solution": "const { calculateCartTotal } = require('./cart');\ntest('calculates cart total', () => {\n  const items = [{ price: 10, quantity: 2 }, { price: 5, quantity: 1 }];\n  expect(calculateCartTotal(items)).toBe(25);\n});\ntest('handles empty cart', () => {\n  expect(calculateCartTotal([])).toBe(0);\n});\n\n// cart.js\nmodule.exports = {\n  calculateCartTotal: (items) => items.reduce((sum, item) => sum + item.price * item.quantity, 0)\n};"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do unit tests verify?",
                              "options": [
                                "API endpoints",
                                "Individual units",
                                "UI rendering",
                                "Database"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is Jest used for?",
                              "options": [
                                "Styling",
                                "Testing",
                                "Routing",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does expect().toBe() check?",
                              "options": ["Equality", "Type", "Style", "Async"],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Jest Documentation",
                              "url": "https://jestjs.io/docs/getting-started",
                              "type": "doc"
                            },
                            {
                              "title": "Vitest Documentation",
                              "url": "https://vitest.dev/guide/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439265",
                        "title": "Integration Tests (Supertest / Playwright)",
                        "slug": "integration-tests-supertest-playwright",
                        "description": "Learn integration and end-to-end testing with Supertest and Playwright.",
                        "order": 2,
                        "content": {
                          "explanation": "Integration tests verify interactions between components, like API routes and databases, while end-to-end (E2E) tests simulate user flows (e.g., sign-in, create resource). Supertest tests Express APIs by sending HTTP requests (e.g., `request(app).get('/users')`), checking responses. Playwright automates browser interactions for E2E tests, like filling forms or clicking buttons. For example, an E2E test might navigate to a login page, submit credentials, and verify redirection. Intermediate learners should write integration tests for API endpoints and E2E tests for user flows, ensuring realistic scenarios. Be cautious of flaky tests or slow E2E tests, which reduce reliability. These tests prevent regressions in web applications.",
                          "examples": [
                            "// Supertest (Integration)\nconst request = require('supertest');\nconst app = require('./app');\ntest('GET /users returns users', async () => {\n  const res = await request(app).get('/users');\n  expect(res.status).toBe(200);\n  expect(res.body).toHaveProperty('users');\n});",
                            "// Playwright (E2E)\nconst { test } = require('@playwright/test');\ntest('user can login', async ({ page }) => {\n  await page.goto('/login');\n  await page.fill('#username', 'user');\n  await page.click('button[type=submit]');\n  await expect(page).toHaveURL('/dashboard');\n});"
                          ],
                          "realWorldApplication": "Used in e-commerce for testing API endpoints or user flows like checkout or login.",
                          "expertInsights": "Use Supertest for API tests; Playwright for browser E2E; keep tests fast and reliable; isolate test environments.",
                          "commonMistakes": [
                            "Writing flaky E2E tests",
                            "Not isolating integration test data",
                            "Testing UI styles instead of behavior"
                          ],
                          "exercises": [
                            {
                              "title": "Write E2E Test for Sign-In Flow",
                              "prompt": "Create a Playwright test for a sign-in and create todo flow, verifying navigation and creation.",
                              "difficulty": "hard",
                              "hints": [
                                "Use page.goto for navigation",
                                "Check URL after actions"
                              ],
                              "solution": "const { test, expect } = require('@playwright/test');\ntest('user can sign in and create todo', async ({ page }) => {\n  await page.goto('/login');\n  await page.fill('#username', 'user');\n  await page.fill('#password', 'pass');\n  await page.click('button[type=submit]');\n  await expect(page).toHaveURL('/dashboard');\n  await page.fill('#todo', 'Test todo');\n  await page.click('#create-todo');\n  await expect(page.locator('#todo-list')).toContainText('Test todo');\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does Supertest test?",
                              "options": [
                                "UI",
                                "API endpoints",
                                "Database",
                                "Styles"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does Playwright automate?",
                              "options": [
                                "Server",
                                "Browser",
                                "Database",
                                "API"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What do E2E tests simulate?",
                              "options": [
                                "Unit logic",
                                "User flows",
                                "API calls",
                                "Styles"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What causes flaky tests?",
                              "options": [
                                "Consistent data",
                                "Unstable environment",
                                "Fast tests",
                                "Mocks"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Supertest Documentation",
                              "url": "https://www.npmjs.com/package/supertest",
                              "type": "doc"
                            },
                            {
                              "title": "Playwright Documentation",
                              "url": "https://playwright.dev/docs/intro",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439266",
                        "title": "Testing Strategies: Mocks, Fixtures, Test Data, CI",
                        "slug": "testing-strategies",
                        "description": "Learn testing strategies using mocks, fixtures, test data, and CI integration.",
                        "order": 3,
                        "content": {
                          "explanation": "Effective testing strategies use mocks to simulate dependencies (e.g., database or API calls), fixtures to provide consistent test data, and test databases for isolation. Continuous Integration (CI) runs tests automatically on code changes (e.g., GitHub Actions). For example, Jest’s `jest.mock` fakes a module, while fixtures load predefined JSON data. Intermediate learners should mock external services, use fixtures for repeatable tests, and integrate tests in CI pipelines. Be cautious of over-mocking, which hides real behavior, or inconsistent test data, which causes flakiness. These strategies ensure reliable, automated testing for web applications, preventing regressions.",
                          "examples": [
                            "// Jest mock\nconst db = jest.mock('./db');\ndb.getUsers.mockReturnValue([{ id: 1, name: 'Alice' }]);\ntest('getUsers returns users', async () => {\n  const users = await getUsers();\n  expect(users).toEqual([{ id: 1, name: 'Alice' }]);\n});",
                            "// Fixture (users.json)\n[{ \"id\": 1, \"name\": \"Alice\" }]"
                          ],
                          "realWorldApplication": "Used in web apps for automated testing of APIs, UI, or database interactions in CI pipelines.",
                          "expertInsights": "Mock only external dependencies; use fixtures for complex data; run tests in CI for every commit.",
                          "commonMistakes": [
                            "Over-mocking, hiding real issues",
                            "Using inconsistent test data",
                            "Not running tests in CI"
                          ],
                          "exercises": [
                            {
                              "title": "Add Unit Tests with Mocks",
                              "prompt": "Write Jest unit tests for a module that fetches todos, using a mock for the API call.",
                              "difficulty": "medium",
                              "hints": [
                                "Use jest.mock for API",
                                "Test with mock data"
                              ],
                              "solution": "const fetchTodos = require('./todos');\njest.mock('./api', () => ({\n  get: jest.fn().mockResolvedValue([{ id: 1, task: 'Test' }])\n}));\ntest('fetchTodos returns todos', async () => {\n  const todos = await fetchTodos();\n  expect(todos).toEqual([{ id: 1, task: 'Test' }]);\n});\n\n// todos.js\nconst api = require('./api');\nmodule.exports = async () => await api.get('/todos');"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do mocks simulate?",
                              "options": [
                                "UI",
                                "Dependencies",
                                "Styles",
                                "Database"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What provides consistent test data?",
                              "options": ["Mocks", "Fixtures", "CI", "APIs"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What runs tests automatically?",
                              "options": [
                                "Fixtures",
                                "CI",
                                "Mocks",
                                "Playwright"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Jest Mocking",
                              "url": "https://jestjs.io/docs/mock-functions",
                              "type": "doc"
                            },
                            {
                              "title": "GitHub Actions",
                              "url": "https://docs.github.com/en/actions",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439267",
                        "title": "Contract Testing (Pact)",
                        "slug": "contract-testing-pact",
                        "description": "Learn contract testing with Pact for API stability.",
                        "order": 4,
                        "content": {
                          "explanation": "Contract testing ensures API providers and consumers agree on request/response formats, preventing regressions in microservices. Pact defines contracts (e.g., expected request and response for `GET /todos`) and tests both sides independently. For example, a consumer test verifies the client handles a specific response, while a provider test checks the API meets the contract. Intermediate learners should write Pact tests for API endpoints, generating contracts and verifying them in CI. Be cautious of outdated contracts or incomplete endpoint coverage, which can miss issues. Contract testing ensures API stability in web applications, especially in microservices architectures.",
                          "examples": [
                            "// Consumer Pact test\nconst { Pact } = require('@pact-foundation/pact');\nconst provider = new Pact({ consumer: 'Client', provider: 'API' });\ntest('GET /todos', async () => {\n  await provider.addInteraction({\n    state: 'todos exist',\n    uponReceiving: 'get todos',\n    withRequest: { method: 'GET', path: '/todos' },\n    willRespondWith: { status: 200, body: [{ id: 1, task: 'Test' }] }\n  });\n  const response = await api.get('/todos');\n  expect(response).toEqual([{ id: 1, task: 'Test' }]);\n});",
                            "// Provider verification\npact-verifier --provider-base-url=http://localhost:3000 --pact-urls=client-api.pact.json"
                          ],
                          "realWorldApplication": "Used in microservices to ensure API compatibility between services like user and order management.",
                          "expertInsights": "Use Pact for consumer-driven contracts; integrate with CI; update contracts on API changes.",
                          "commonMistakes": [
                            "Not updating contracts after API changes",
                            "Testing only one side of the contract",
                            "Ignoring contract verification in CI"
                          ],
                          "exercises": [
                            {
                              "title": "Write Pact Contract Test",
                              "prompt": "Create a Pact test for a consumer expecting a GET /todos endpoint to return a list of todos.",
                              "difficulty": "hard",
                              "hints": [
                                "Define interaction with request/response",
                                "Use Pact’s addInteraction"
                              ],
                              "solution": "const { Pact } = require('@pact-foundation/pact');\nconst provider = new Pact({ consumer: 'Client', provider: 'TodoAPI', port: 1234 });\ntest('GET /todos returns todos', async () => {\n  await provider.setup();\n  await provider.addInteraction({\n    state: 'todos exist',\n    uponReceiving: 'get todos request',\n    withRequest: { method: 'GET', path: '/todos' },\n    willRespondWith: { status: 200, body: [{ id: 1, task: 'Test' }] }\n  });\n  const response = await fetch('http://localhost:1234/todos').then(res => res.json());\n  expect(response).toEqual([{ id: 1, task: 'Test' }]);\n  await provider.finalize();\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does Pact test?",
                              "options": [
                                "UI",
                                "API contracts",
                                "Database",
                                "Styles"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does contract testing ensure?",
                              "options": [
                                "Speed",
                                "API stability",
                                "UI rendering",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What defines a Pact interaction?",
                              "options": [
                                "Styles",
                                "Request/response",
                                "Database",
                                "Components"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Where are Pact tests run?",
                              "options": [
                                "Frontend",
                                "CI",
                                "Database",
                                "Browser"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Pact Documentation",
                              "url": "https://docs.pact.io/",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T20:55:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439270",
    "title": "Security Best Practices",
    "slug": "security-best-practices",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439271",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master security best practices to protect web applications against common vulnerabilities and ensure robust defenses.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439272",
            "title": "Security Best Practices",
            "slug": "security-best-practices",
            "shortDescription": "An intermediate course on securing web applications against common vulnerabilities and implementing robust protections.",
            "longDescription": "This course covers the OWASP Top 10 vulnerabilities like XSS, CSRF, and SQL Injection, implementing secure headers such as CSP and HSTS, rate limiting and brute-force protection with secrets management, and dependency scanning using SCA tools to ensure secure web applications.",
            "tags": ["Security", "OWASP", "Web Development", "Intermediate"],
            "thumbnail": "https://example.com/thumbnails/security.jpg",
            "levels": [
              {
                "level": "Intermediate",
                "overview": "This intermediate level focuses on securing web applications by addressing common vulnerabilities, implementing protective headers, and managing dependencies securely.",
                "goals": [
                  "Understand and mitigate OWASP Top 10 vulnerabilities",
                  "Implement secure headers like CSP and HSTS with input validation",
                  "Apply rate limiting, brute-force protection, and secrets management",
                  "Use dependency scanning and SCA tools for secure dependencies"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439273",
                    "title": "Security Best Practices",
                    "slug": "security-best-practices",
                    "description": "Learn to secure web applications against common vulnerabilities and implement best practices for robust defenses.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439274",
                        "title": "OWASP Top 10 Overview (XSS, CSRF, Injection)",
                        "slug": "owasp-top-10",
                        "description": "Understand the OWASP Top 10 vulnerabilities like XSS, CSRF, and SQL Injection.",
                        "order": 1,
                        "content": {
                          "explanation": "The OWASP Top 10 lists critical web vulnerabilities. Cross-Site Scripting (XSS) allows attackers to inject malicious scripts (e.g., `<script>alert('hacked')</script>`) into web pages, mitigated by escaping outputs. Cross-Site Request Forgery (CSRF) tricks users into performing unintended actions, prevented by CSRF tokens. SQL Injection exploits unescaped database queries (e.g., `SELECT * FROM users WHERE id = '1' OR '1'='1'`), countered by parameterized queries. Intermediate learners should identify and fix these vulnerabilities in code, using libraries like `express-validator` for input sanitization. Be cautious of unescaped user inputs or missing CSRF tokens, which expose apps to attacks. Understanding these vulnerabilities ensures secure web applications.",
                          "examples": [
                            "// Vulnerable XSS\nconst express = require('express');\napp.get('/greet', (req, res) => res.send(`Hello ${req.query.name}`)); // Vulnerable\n// Fixed\nconst sanitizeHtml = require('sanitize-html');\napp.get('/greet', (req, res) => res.send(`Hello ${sanitizeHtml(req.query.name)}`));",
                            "// CSRF Protection\nconst csrf = require('csurf');\napp.use(csrf());\napp.post('/update', (req, res) => {\n  if (!req.csrfToken()) return res.status(403).send('Invalid CSRF');\n});"
                          ],
                          "realWorldApplication": "Used in e-commerce or banking apps to prevent data theft or unauthorized actions.",
                          "expertInsights": "Escape all outputs for XSS; use CSRF tokens for POST requests; always use parameterized queries for SQL.",
                          "commonMistakes": [
                            "Not escaping user inputs",
                            "Missing CSRF tokens on forms",
                            "Using string concatenation in SQL queries"
                          ],
                          "exercises": [
                            {
                              "title": "Fix Vulnerable Endpoint",
                              "prompt": "Fix an Express endpoint vulnerable to XSS by sanitizing user input.",
                              "difficulty": "medium",
                              "hints": [
                                "Use sanitize-html library",
                                "Sanitize query parameters"
                              ],
                              "solution": "const express = require('express');\nconst sanitizeHtml = require('sanitize-html');\nconst app = express();\napp.get('/greet', (req, res) => {\n  const name = sanitizeHtml(req.query.name || 'Guest');\n  res.send(`Hello ${name}`);\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does XSS inject?",
                              "options": [
                                "SQL",
                                "Scripts",
                                "Styles",
                                "Cookies"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What prevents CSRF?",
                              "options": [
                                "Tokens",
                                "Indexes",
                                "Headers",
                                "Queries"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What stops SQL Injection?",
                              "options": [
                                "Escaping",
                                "Parameterized queries",
                                "Sanitization",
                                "Hashing"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "OWASP Top 10",
                              "url": "https://owasp.org/www-project-top-ten/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439275",
                        "title": "Secure Headers (CSP, HSTS), Input Validation & Sanitization",
                        "slug": "secure-headers-validation",
                        "description": "Learn to implement secure headers and input validation for web apps.",
                        "order": 2,
                        "content": {
                          "explanation": "Secure headers like Content Security Policy (CSP) and HTTP Strict Transport Security (HSTS) protect web apps. CSP restricts resources (e.g., `Content-Security-Policy: script-src 'self'`) to prevent XSS, but may block legitimate scripts, requiring careful tuning. HSTS enforces HTTPS (`Strict-Transport-Security: max-age=31536000`). Input validation ensures data meets expected formats (e.g., email regex), while sanitization removes dangerous content (e.g., stripping `<script>`). Intermediate learners should add CSP and HSTS headers using libraries like `helmet` and validate inputs with `express-validator`. Be cautious of overly restrictive CSP or weak validation, which can break functionality or allow attacks. These practices enhance web app security.",
                          "examples": [
                            "// Helmet for headers\nconst helmet = require('helmet');\napp.use(helmet({\n  contentSecurityPolicy: { directives: { scriptSrc: [\"'self'\", \"example.com\"] } },\n  hsts: { maxAge: 31536000 }\n}));",
                            "// Input validation\nconst { body, validationResult } = require('express-validator');\napp.post('/user', [\n  body('email').isEmail(),\n  body('name').trim().escape()\n], (req, res) => {\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) return res.status(400).json({ errors: errors.array() });\n  res.json({ success: true });\n});"
                          ],
                          "realWorldApplication": "Used in web apps to secure client-side scripts and enforce HTTPS for user data protection.",
                          "expertInsights": "Use helmet for easy header setup; balance CSP strictness; validate and sanitize all inputs.",
                          "commonMistakes": [
                            "Overly restrictive CSP breaking functionality",
                            "Not enabling HSTS for HTTPS",
                            "Skipping input sanitization"
                          ],
                          "exercises": [
                            {
                              "title": "Add CSP Headers",
                              "prompt": "Add CSP headers to an Express app and discuss tradeoffs.",
                              "difficulty": "medium",
                              "hints": [
                                "Use helmet for CSP",
                                "Allow 'self' scripts"
                              ],
                              "solution": "const express = require('express');\nconst helmet = require('helmet');\nconst app = express();\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      scriptSrc: [\"'self'\", \"https://example.com\"],\n      styleSrc: [\"'self'\"]\n    }\n  }\n}));\n\n// Tradeoffs\n// Pros: Prevents XSS by restricting scripts\n// Cons: May block legitimate scripts; requires tuning for external resources"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does CSP restrict?",
                              "options": [
                                "Queries",
                                "Resources",
                                "Routes",
                                "Cookies"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does HSTS enforce?",
                              "options": [
                                "HTTP",
                                "HTTPS",
                                "Scripts",
                                "Validation"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What removes dangerous input?",
                              "options": [
                                "Validation",
                                "Sanitization",
                                "Hashing",
                                "Encryption"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What library sets secure headers?",
                              "options": [
                                "express",
                                "helmet",
                                "bcrypt",
                                "jsonwebtoken"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "Helmet Documentation",
                              "url": "https://helmetjs.github.io/",
                              "type": "doc"
                            },
                            {
                              "title": "OWASP CSP",
                              "url": "https://owasp.org/www-community/controls/Content_Security_Policy",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439276",
                        "title": "Rate Limiting, Brute-Force Protection, Secrets Management",
                        "slug": "rate-limiting-secrets",
                        "description": "Learn rate limiting, brute-force protection, and secrets management.",
                        "order": 3,
                        "content": {
                          "explanation": "Rate limiting restricts request frequency (e.g., 100 requests/hour per IP) to prevent abuse, using libraries like `express-rate-limit`. Brute-force protection locks accounts after failed login attempts (e.g., 5 attempts in 10 minutes). Secrets management stores sensitive data like API keys securely, using environment variables or tools like AWS Secrets Manager. For example, `process.env.API_KEY` hides keys from code. Intermediate learners should implement rate limiting on login routes, add brute-force protection, and use `.env` files for secrets. Be cautious of loose rate limits or exposed secrets in code, which risk attacks. These practices protect web apps from abuse and data leaks.",
                          "examples": [
                            "// Rate limiting\nconst rateLimit = require('express-rate-limit');\napp.use('/login', rateLimit({\n  windowMs: 15 * 60 * 1000,\n  max: 5\n}));",
                            "// Secrets management\nrequire('dotenv').config();\nconst apiKey = process.env.API_KEY;"
                          ],
                          "realWorldApplication": "Used in APIs to prevent DDoS attacks, secure logins, or protect sensitive keys.",
                          "expertInsights": "Use rate-limit for public endpoints; lock accounts after 5 failed logins; use vault tools for secrets.",
                          "commonMistakes": [
                            "Not rate-limiting sensitive endpoints",
                            "Hardcoding secrets in source code",
                            "Ignoring brute-force protections"
                          ],
                          "exercises": [
                            {
                              "title": "Add Rate Limiting to Endpoint",
                              "prompt": "Add rate limiting to an Express login endpoint to allow 5 requests per 15 minutes.",
                              "difficulty": "medium",
                              "hints": [
                                "Use express-rate-limit",
                                "Set windowMs and max"
                              ],
                              "solution": "const express = require('express');\nconst rateLimit = require('express-rate-limit');\nconst app = express();\napp.use('/login', rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // 5 requests\n  message: 'Too many login attempts'\n}));\napp.post('/login', (req, res) => res.json({ success: true }));"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does rate limiting prevent?",
                              "options": ["XSS", "Abuse", "Injection", "CSRF"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What stops brute-force attacks?",
                              "options": [
                                "Account locking",
                                "Headers",
                                "Sanitization",
                                "Encryption"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "Where are secrets stored?",
                              "options": [
                                "Code",
                                "Environment variables",
                                "Database",
                                "Cookies"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "express-rate-limit",
                              "url": "https://www.npmjs.com/package/express-rate-limit",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439277",
                        "title": "Dependency Scanning & SCA Tools",
                        "slug": "dependency-scanning-sca",
                        "description": "Learn to use dependency scanning and SCA tools for secure dependencies.",
                        "order": 4,
                        "content": {
                          "explanation": "Dependency scanning and Software Composition Analysis (SCA) tools like Dependabot or Snyk identify vulnerabilities in project dependencies. For example, a package like `lodash` with a known CVE is flagged for updating. Tools scan `package.json` or lockfiles, alerting developers to insecure versions. Intermediate learners should integrate SCA tools in CI pipelines (e.g., GitHub Actions) and update vulnerable dependencies promptly. Be cautious of ignoring alerts or using outdated packages, which risk exploits. Dependency scanning ensures web applications remain secure by maintaining safe libraries.",
                          "examples": [
                            "// GitHub Dependabot config\n# .github/dependabot.yml\nversion: 2\nupdates:\n  - package-ecosystem: 'npm'\n    directory: '/'\n    schedule:\n      interval: 'daily'",
                            "// Snyk CLI\nsnyk test # Scans for vulnerabilities"
                          ],
                          "realWorldApplication": "Used in web apps to ensure libraries like Express or React are free of known vulnerabilities.",
                          "expertInsights": "Run SCA in CI; automate dependency updates with Dependabot; prioritize high-severity CVEs.",
                          "commonMistakes": [
                            "Ignoring SCA vulnerability alerts",
                            "Not updating lockfiles after fixes",
                            "Skipping CI integration for scans"
                          ],
                          "exercises": [
                            {
                              "title": "Set Up Dependency Scanning",
                              "prompt": "Create a Dependabot configuration to scan npm dependencies daily.",
                              "difficulty": "medium",
                              "hints": [
                                "Use dependabot.yml",
                                "Set npm ecosystem"
                              ],
                              "solution": "# .github/dependabot.yml\nversion: 2\nupdates:\n  - package-ecosystem: 'npm'\n    directory: '/'\n    schedule:\n      interval: 'daily'\n    open-pull-requests-limit: 10"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do SCA tools detect?",
                              "options": [
                                "Code errors",
                                "Vulnerabilities",
                                "Styles",
                                "Tests"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is Dependabot used for?",
                              "options": [
                                "Testing",
                                "Dependency updates",
                                "Styling",
                                "Routing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "Where are SCA tools run?",
                              "options": [
                                "Browser",
                                "CI",
                                "Database",
                                "Frontend"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks outdated dependencies?",
                              "options": [
                                "Slow performance",
                                "Exploits",
                                "UI bugs",
                                "Caching"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "Dependabot Documentation",
                              "url": "https://docs.github.com/en/code-security/dependabot",
                              "type": "doc"
                            },
                            {
                              "title": "Snyk Documentation",
                              "url": "https://docs.snyk.io/",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T20:58:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439280",
    "title": "Performance & Observability",
    "slug": "performance-observability",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439281",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master performance optimization and observability techniques to measure, improve, and monitor web applications effectively.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439282",
            "title": "Performance & Observability",
            "slug": "performance-observability",
            "shortDescription": "An intermediate course on optimizing web application performance and maintaining visibility through observability.",
            "longDescription": "This course covers frontend performance metrics (LCP, CLS, TTFB) and optimizations, backend performance profiling with database query tuning and caching using Redis, observability with logs, metrics via Prometheus, and tracing with OpenTelemetry, and setting up alerts with SLO/SLI basics for robust web applications.",
            "tags": [
              "Performance",
              "Observability",
              "Web Development",
              "Intermediate"
            ],
            "thumbnail": "https://example.com/thumbnails/performance-observability.jpg",
            "levels": [
              {
                "level": "Intermediate",
                "overview": "This intermediate level focuses on measuring and optimizing web application performance and implementing observability for system visibility.",
                "goals": [
                  "Measure and optimize frontend performance metrics like LCP, CLS, and TTFB",
                  "Profile and tune backend performance with database queries and caching",
                  "Implement observability with logs, metrics, and tracing",
                  "Set up alerts and understand SLO/SLI for monitoring"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439283",
                    "title": "Performance & Observability",
                    "slug": "performance-observability",
                    "description": "Learn to optimize performance and maintain visibility in web applications through metrics, profiling, and observability tools.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439284",
                        "title": "Frontend Performance Metrics and Optimizations",
                        "slug": "frontend-performance-metrics",
                        "description": "Learn to measure and optimize frontend performance metrics like LCP, CLS, and TTFB.",
                        "order": 1,
                        "content": {
                          "explanation": "Frontend performance metrics include Largest Contentful Paint (LCP, time to main content rendering), Cumulative Layout Shift (CLS, visual stability), and Time to First Byte (TTFB, server response time). Optimizations include compressing images (e.g., WebP format), lazy-loading assets, and using modern font formats (e.g., WOFF2). For example, `<img loading='lazy' src='image.webp'>` reduces initial load time. Tools like Lighthouse measure these metrics. Intermediate learners should analyze performance with Lighthouse, optimize images, and minimize CLS. Be cautious of large images or unoptimized fonts, which degrade user experience. These techniques ensure fast, smooth web applications.",
                          "examples": [
                            "// Lazy-loaded image\n<img src='image.webp' loading='lazy' alt='Product' />",
                            "// Optimized font\n<link rel='stylesheet' href='https://fonts.googleapis.com/css2?family=Roboto:wght@400&display=swap'>"
                          ],
                          "realWorldApplication": "Used in e-commerce for fast product pages or media sites for quick content loading.",
                          "expertInsights": "Use Lighthouse for metrics; prioritize LCP under 2.5s; compress images with WebP; lazy-load offscreen assets.",
                          "commonMistakes": [
                            "Not compressing images",
                            "Ignoring CLS in dynamic layouts",
                            "Using large, unoptimized fonts"
                          ],
                          "exercises": [
                            {
                              "title": "Optimize Frontend Performance",
                              "prompt": "Optimize an HTML page by adding lazy-loading for images and using a modern font format.",
                              "difficulty": "medium",
                              "hints": [
                                "Use loading='lazy' for images",
                                "Link to WOFF2 font"
                              ],
                              "solution": "<!DOCTYPE html>\n<html>\n<head>\n  <link rel='stylesheet' href='https://fonts.googleapis.com/css2?family=Roboto:wght@400&display=swap'>\n</head>\n<body>\n  <img src='product.webp' loading='lazy' alt='Product' style='font-family: Roboto, sans-serif;'>\n</body>\n</html>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does LCP measure?",
                              "options": [
                                "Server response",
                                "Main content rendering",
                                "Layout shift",
                                "First byte"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does CLS affect?",
                              "options": [
                                "Speed",
                                "Visual stability",
                                "Data fetching",
                                "Security"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What optimizes image loading?",
                              "options": ["WebP", "JPEG", "PNG", "GIF"],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "Web Vitals",
                              "url": "https://web.dev/vitals/",
                              "type": "article"
                            },
                            {
                              "title": "Lighthouse Documentation",
                              "url": "https://developers.google.com/web/tools/lighthouse",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439285",
                        "title": "Backend Performance Profiling, DB Query Tuning, Caching",
                        "slug": "backend-performance-profiling",
                        "description": "Learn to profile backend performance, tune database queries, and implement caching.",
                        "order": 2,
                        "content": {
                          "explanation": "Backend performance profiling identifies bottlenecks using tools like Node.js’s `clinic.js` or `profiler`. Database query tuning optimizes slow queries, such as adding indexes (e.g., `CREATE INDEX ON orders(user_id)`) or avoiding `SELECT *`. Caching with Redis stores frequent results (e.g., `SET user:1 '{'id':1,'name':'Alice'}'`), reducing database load. For example, caching a user’s profile avoids repeated queries. Intermediate learners should profile endpoints, add indexes, and cache results with Redis. Be cautious of over-caching or unoptimized queries, which degrade performance. These techniques ensure fast, scalable backends for web applications.",
                          "examples": [
                            "// Redis caching\nconst redis = require('redis');\nconst client = redis.createClient();\napp.get('/user/:id', async (req, res) => {\n  const cached = await client.get(`user:${req.params.id}`);\n  if (cached) return res.json(JSON.parse(cached));\n  const user = await db.query('SELECT * FROM users WHERE id = $1', [req.params.id]);\n  await client.set(`user:${req.params.id}`, JSON.stringify(user));\n  res.json(user);\n});",
                            "// Query tuning\nCREATE INDEX idx_user_id ON orders(user_id);"
                          ],
                          "realWorldApplication": "Used in e-commerce for fast product searches or user profile loading with caching.",
                          "expertInsights": "Profile with clinic.js; index frequently queried columns; use Redis TTL for cache eviction; avoid SELECT *.",
                          "commonMistakes": [
                            "Not indexing database queries",
                            "Caching without TTL, causing stale data",
                            "Ignoring profiling for bottlenecks"
                          ],
                          "exercises": [
                            {
                              "title": "Profile and Cache Endpoint",
                              "prompt": "Profile a slow Express endpoint, add Redis caching, and measure improvement.",
                              "difficulty": "hard",
                              "hints": [
                                "Use Redis for caching",
                                "Measure response time"
                              ],
                              "solution": "const express = require('express');\nconst redis = require('redis');\nconst app = express();\nconst client = redis.createClient();\napp.get('/user/:id', async (req, res) => {\n  const start = Date.now();\n  const cached = await client.get(`user:${req.params.id}`);\n  if (cached) {\n    console.log(`Cache hit: ${Date.now() - start}ms`);\n    return res.json(JSON.parse(cached));\n  }\n  const user = { id: req.params.id, name: 'Alice' }; // Simulate DB\n  await client.setEx(`user:${req.params.id}`, 3600, JSON.stringify(user));\n  console.log(`Cache miss: ${Date.now() - start}ms`);\n  res.json(user);\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What identifies backend bottlenecks?",
                              "options": [
                                "Caching",
                                "Profiling",
                                "Indexing",
                                "Tracing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What improves query performance?",
                              "options": [
                                "SELECT *",
                                "Indexes",
                                "Caching",
                                "Joins"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does Redis store?",
                              "options": [
                                "Logs",
                                "Cached data",
                                "Queries",
                                "Styles"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What prevents stale cache?",
                              "options": ["TTL", "Indexes", "Logs", "Tracing"],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Redis Documentation",
                              "url": "https://redis.io/docs/",
                              "type": "doc"
                            },
                            {
                              "title": "Clinic.js",
                              "url": "https://clinicjs.org/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439286",
                        "title": "Observability: Logs, Metrics, Tracing",
                        "slug": "observability-logs-metrics-tracing",
                        "description": "Learn observability with logs, metrics using Prometheus, and tracing with OpenTelemetry.",
                        "order": 3,
                        "content": {
                          "explanation": "Observability provides visibility into application behavior using logs, metrics, and tracing. Logs (e.g., via Winston) record events (`logger.info('User logged in')`). Metrics, collected with Prometheus, track performance (e.g., request latency). Tracing, using OpenTelemetry, follows requests across services (e.g., API to database). For example, OpenTelemetry instruments an Express app to trace a request’s path. Intermediate learners should add structured logging, expose metrics with Prometheus, and instrument traces. Be cautious of excessive logging or unconfigured tracing, which reduce visibility. Observability ensures monitoring and debugging in web applications.",
                          "examples": [
                            "// Winston logging\nconst winston = require('winston');\nconst logger = winston.createLogger({\n  transports: [new winston.transports.File({ filename: 'app.log' })]\n});\nlogger.info('User logged in');",
                            "// OpenTelemetry tracing\nconst { trace } = require('@opentelemetry/api');\nconst tracer = trace.getTracer('app');\napp.get('/user', (req, res) => {\n  const span = tracer.startSpan('get-user');\n  res.json({ user: 'Alice' });\n  span.end();\n});"
                          ],
                          "realWorldApplication": "Used in microservices to monitor API performance or debug request flows across services.",
                          "expertInsights": "Use structured logs; expose key metrics with Prometheus; trace critical paths with OpenTelemetry.",
                          "commonMistakes": [
                            "Logging sensitive data",
                            "Not aggregating metrics",
                            "Ignoring tracing setup"
                          ],
                          "exercises": [
                            {
                              "title": "Instrument a Trace",
                              "prompt": "Add OpenTelemetry tracing to an Express endpoint to track request processing.",
                              "difficulty": "hard",
                              "hints": [
                                "Use OpenTelemetry tracer",
                                "Start and end spans"
                              ],
                              "solution": "const express = require('express');\nconst { trace } = require('@opentelemetry/api');\nconst tracer = trace.getTracer('app');\nconst app = express();\napp.get('/user', (req, res) => {\n  const span = tracer.startSpan('get-user');\n  // Simulate work\n  const user = { id: 1, name: 'Alice' };\n  span.setAttribute('user.id', user.id);\n  res.json(user);\n  span.end();\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do logs record?",
                              "options": [
                                "Styles",
                                "Events",
                                "Queries",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does Prometheus track?",
                              "options": [
                                "Logs",
                                "Metrics",
                                "Traces",
                                "Styles"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does OpenTelemetry provide?",
                              "options": [
                                "Caching",
                                "Tracing",
                                "Indexing",
                                "Validation"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 110,
                          "resources": [
                            {
                              "title": "Prometheus Documentation",
                              "url": "https://prometheus.io/docs/",
                              "type": "doc"
                            },
                            {
                              "title": "OpenTelemetry Documentation",
                              "url": "https://opentelemetry.io/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439287",
                        "title": "Alerts and SLO/SLI Basics",
                        "slug": "alerts-slo-sli",
                        "description": "Learn to set up alerts and define SLO/SLI for monitoring.",
                        "order": 4,
                        "content": {
                          "explanation": "Alerts notify teams of issues (e.g., high latency) using tools like Prometheus Alertmanager. Service Level Objectives (SLOs) define reliability targets (e.g., 99.9% uptime), while Service Level Indicators (SLIs) measure metrics (e.g., request success rate). For example, an alert triggers if error rate exceeds 1%. Intermediate learners should configure Prometheus alerts and define SLO/SLIs for key services. Be cautious of alert fatigue or vague SLOs, which reduce effectiveness. These practices ensure proactive monitoring in web applications, maintaining reliability and performance.",
                          "examples": [
                            "// Prometheus Alert rule\nALERT HighErrorRate\nIF rate(http_requests_total{status='500'}[5m]) > 0.01\nFOR 5m\nLABELS { severity='critical' }\nANNOTATIONS { summary='High error rate detected' }",
                            "// SLO example\nSLO: 99.9% API uptime\nSLI: Successful requests / Total requests"
                          ],
                          "realWorldApplication": "Used in APIs to monitor uptime or alert on high error rates in production.",
                          "expertInsights": "Set alerts for critical metrics; define clear SLOs; measure SLIs with Prometheus; avoid alert spam.",
                          "commonMistakes": [
                            "Setting too many alerts",
                            "Vague SLO definitions",
                            "Not measuring SLIs"
                          ],
                          "exercises": [
                            {
                              "title": "Set Up Alert Rule",
                              "prompt": "Create a Prometheus alert rule for high API error rates.",
                              "difficulty": "medium",
                              "hints": [
                                "Use rate() for metrics",
                                "Set severity label"
                              ],
                              "solution": "# prometheus/alerts.yml\nrules:\n- alert: HighErrorRate\n  expr: rate(http_requests_total{status='500'}[5m]) > 0.01\n  for: 5m\n  labels:\n    severity: critical\n  annotations:\n    summary: 'High API error rate'"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What triggers alerts?",
                              "options": [
                                "Styles",
                                "Metrics",
                                "Queries",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does SLO define?",
                              "options": [
                                "Reliability targets",
                                "Caching",
                                "Indexes",
                                "Styles"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What measures SLOs?",
                              "options": ["Logs", "SLIs", "Traces", "Headers"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What causes alert fatigue?",
                              "options": [
                                "Few alerts",
                                "Too many alerts",
                                "Clear SLOs",
                                "Fast queries"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 100,
                          "resources": [
                            {
                              "title": "Prometheus Alerting",
                              "url": "https://prometheus.io/docs/alerting/latest/overview/",
                              "type": "doc"
                            },
                            {
                              "title": "SLO Guide",
                              "url": "https://sre.google/sre-book/service-level-objectives/",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T21:00:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439290",
    "title": "CI/CD, Containerization & Deployment",
    "slug": "ci-cd-containerization-deployment",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439291",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master CI/CD pipelines, containerization with Docker, and deployment strategies for scalable and reliable web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439292",
            "title": "CI/CD, Containerization & Deployment",
            "slug": "ci-cd-containerization-deployment",
            "shortDescription": "An intermediate course on automating build, test, and deploy processes, containerizing applications, and managing deployments.",
            "longDescription": "This course covers Docker basics with multi-stage builds and image optimization, setting up CI pipelines with GitHub Actions for build, test, lint, and deploy steps, deploying to platforms like Vercel/Netlify or Cloud Run/ECS/Kubernetes, and managing database migrations with safe deployment strategies like blue/green and canary for robust web applications.",
            "tags": [
              "CI/CD",
              "Docker",
              "Deployment",
              "Web Development",
              "Intermediate"
            ],
            "thumbnail": "https://example.com/thumbnails/ci-cd-deployment.jpg",
            "levels": [
              {
                "level": "Intermediate",
                "overview": "This intermediate level focuses on automating CI/CD pipelines, containerizing applications with Docker, and deploying to various platforms with safe strategies.",
                "goals": [
                  "Understand Docker basics, multi-stage builds, and image size optimization",
                  "Set up CI pipelines with GitHub Actions for build, test, and deploy",
                  "Deploy applications to Vercel/Netlify, Cloud Run/ECS, or Kubernetes",
                  "Manage database migrations and implement safe deployment strategies"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439293",
                    "title": "CI/CD, Containerization & Deployment",
                    "slug": "ci-cd-containerization-deployment",
                    "description": "Learn to automate build, test, and deployment processes, containerize applications, and manage deployments for web applications.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439294",
                        "title": "Docker Basics, Multi-Stage Builds, Image Size Optimization",
                        "slug": "docker-basics",
                        "description": "Learn Docker fundamentals, multi-stage builds, and image size optimization techniques.",
                        "order": 1,
                        "content": {
                          "explanation": "Docker containers package applications with dependencies, ensuring consistent environments. A Dockerfile defines the container (e.g., `FROM node:18`). Multi-stage builds use multiple `FROM` statements to reduce image size by separating build and runtime environments. For example, a Node.js app builds dependencies in one stage and copies only necessary files to a slim runtime stage. Optimization techniques include using smaller base images (e.g., `node:18-alpine`) and cleaning up unused files. Intermediate learners should write Dockerfiles, use multi-stage builds, and optimize images. Be cautious of large images or missing `.dockerignore`, which bloat containers. These practices ensure efficient, portable web applications.",
                          "examples": [
                            "# Multi-stage Dockerfile\nFROM node:18 AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\nFROM node:18-alpine\nWORKDIR /app\nCOPY --from=builder /app/dist ./dist\nCOPY package*.json ./\nRUN npm install --production\nCMD ['node', 'dist/index.js']",
                            "# .dockerignore\nnode_modules\ndist"
                          ],
                          "realWorldApplication": "Used in web apps to package Node.js or Python services for consistent deployment across environments.",
                          "expertInsights": "Use multi-stage builds for smaller images; leverage alpine base images; always include .dockerignore.",
                          "commonMistakes": [
                            "Using large base images",
                            "Not using multi-stage builds",
                            "Including unnecessary files in images"
                          ],
                          "exercises": [
                            {
                              "title": "Containerize an App",
                              "prompt": "Create a Dockerfile for a Node.js app using a multi-stage build and optimize image size.",
                              "difficulty": "medium",
                              "hints": [
                                "Use node:18 and node:18-alpine",
                                "Copy only dist and production dependencies"
                              ],
                              "solution": "# Dockerfile\nFROM node:18 AS builder\nWORKDIR /app\nCOPY package*.json ./\nRUN npm install\nCOPY . .\nRUN npm run build\n\nFROM node:18-alpine\nWORKDIR /app\nCOPY --from=builder /app/dist ./dist\nCOPY package*.json ./\nRUN npm install --production\nCMD ['node', 'dist/index.js']\n\n# .dockerignore\nnode_modules\ndist"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does Docker package?",
                              "options": [
                                "Styles",
                                "Applications",
                                "Databases",
                                "Tests"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What reduces image size?",
                              "options": [
                                "Multi-stage builds",
                                "Large base images",
                                "More files",
                                "No .dockerignore"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What is node:18-alpine?",
                              "options": [
                                "Large image",
                                "Slim image",
                                "Database",
                                "Test tool"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Docker Documentation",
                              "url": "https://docs.docker.com/",
                              "type": "doc"
                            },
                            {
                              "title": "Docker Multi-Stage Builds",
                              "url": "https://docs.docker.com/build/building/multi-stage/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439295",
                        "title": "CI Pipelines (GitHub Actions)",
                        "slug": "ci-pipelines-github-actions",
                        "description": "Learn to set up CI pipelines with GitHub Actions for build, test, lint, and deploy steps.",
                        "order": 2,
                        "content": {
                          "explanation": "Continuous Integration (CI) pipelines automate build, test, and lint processes using tools like GitHub Actions. A pipeline defines jobs (e.g., `build`, `test`) with steps like running `npm test` or `npm run lint`. For example, a GitHub Actions workflow triggers on push, builds a Node.js app, and runs tests. Intermediate learners should create workflows to build, test, lint, and optionally deploy, ensuring automation. Be cautious of long-running jobs or missing dependency caching, which slow pipelines. CI pipelines ensure code quality and streamline development for web applications.",
                          "examples": [
                            "# .github/workflows/ci.yml\nname: CI\non: [push]\njobs:\n  build:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n      - run: npm install\n      - run: npm test"
                          ],
                          "realWorldApplication": "Used in web development to automate testing and linting for every code commit.",
                          "expertInsights": "Cache dependencies in CI; parallelize jobs; run lint and tests separately; use matrix for multi-version testing.",
                          "commonMistakes": [
                            "Not caching dependencies",
                            "Running long CI jobs",
                            "Skipping lint or test steps"
                          ],
                          "exercises": [
                            {
                              "title": "Create GitHub Action for CI",
                              "prompt": "Create a GitHub Action to run tests and build a Docker image for a Node.js app.",
                              "difficulty": "hard",
                              "hints": [
                                "Use actions/checkout and actions/setup-node",
                                "Run npm test and docker build"
                              ],
                              "solution": "# .github/workflows/ci.yml\nname: CI\non: [push]\njobs:\n  build-and-test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n          cache: 'npm'\n      - run: npm install\n      - run: npm test\n      - name: Build Docker image\n        run: docker build -t my-app:latest ."
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does CI automate?",
                              "options": [
                                "Styling",
                                "Build/test",
                                "Database",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What triggers GitHub Actions?",
                              "options": [
                                "Commits",
                                "Styles",
                                "Queries",
                                "Logs"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What speeds up CI pipelines?",
                              "options": [
                                "No tests",
                                "Caching",
                                "Large jobs",
                                "No linting"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does npm test run?",
                              "options": ["Styles", "Tests", "Build", "Deploy"],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "GitHub Actions Documentation",
                              "url": "https://docs.github.com/en/actions",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439296",
                        "title": "Deployment Targets: Vercel/Netlify, Cloud Run/ECS, Kubernetes",
                        "slug": "deployment-targets",
                        "description": "Learn to deploy applications to Vercel/Netlify, Cloud Run/ECS, and Kubernetes.",
                        "order": 3,
                        "content": {
                          "explanation": "Deployment targets host web applications. Vercel and Netlify simplify frontend deployment with auto-scaling and domain management. Cloud Run and ECS run Docker containers in the cloud, offering serverless (Cloud Run) or managed (ECS) options. Kubernetes orchestrates containers for complex apps, using pods and deployments. For example, Vercel deploys a Next.js app via `vercel deploy`, while Cloud Run uses `gcloud run deploy`. Intermediate learners should deploy frontends to Vercel/Netlify and backends to Cloud Run or ECS, exploring Kubernetes basics. Be cautious of misconfigured scaling or insecure deployments. These platforms ensure scalable, reliable web apps.",
                          "examples": [
                            "# Vercel deployment\nvercel --prod",
                            "# Cloud Run deployment\ngcloud run deploy my-app \\\n  --image gcr.io/my-project/my-app:latest \\\n  --region us-central1"
                          ],
                          "realWorldApplication": "Used in web apps for hosting React frontends on Vercel or Node.js APIs on Cloud Run.",
                          "expertInsights": "Use Vercel for frontend; Cloud Run for serverless APIs; ECS/Kubernetes for complex apps; secure environment variables.",
                          "commonMistakes": [
                            "Not setting environment variables",
                            "Ignoring auto-scaling configs",
                            "Deploying without testing"
                          ],
                          "exercises": [
                            {
                              "title": "Deploy to Vercel",
                              "prompt": "Deploy a Node.js app to Vercel with a simple API endpoint.",
                              "difficulty": "medium",
                              "hints": ["Use Vercel CLI", "Define API route"],
                              "solution": "// api/hello.js\nmodule.exports = (req, res) => res.json({ message: 'Hello from Vercel' });\n\n# vercel.json\n{\n  \"version\": 2,\n  \"builds\": [{ \"src\": \"api/hello.js\", \"use\": \"@vercel/node\" }],\n  \"routes\": [{ \"src\": \"/api/hello\", \"dest\": \"api/hello.js\" }]\n}\n\n# Command\nvercel --prod"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is Vercel best for?",
                              "options": [
                                "Backend",
                                "Frontend",
                                "Database",
                                "Testing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What runs Docker containers?",
                              "options": [
                                "Vercel",
                                "Cloud Run",
                                "Netlify",
                                "Jest"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What orchestrates containers?",
                              "options": [
                                "Kubernetes",
                                "Vercel",
                                "Redis",
                                "Supertest"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Vercel Documentation",
                              "url": "https://vercel.com/docs",
                              "type": "doc"
                            },
                            {
                              "title": "Google Cloud Run",
                              "url": "https://cloud.google.com/run/docs",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439297",
                        "title": "Database Migrations in CI/CD and Safe Deploy Strategies",
                        "slug": "db-migrations-safe-deploy",
                        "description": "Learn to manage database migrations in CI/CD and implement safe deployment strategies.",
                        "order": 4,
                        "content": {
                          "explanation": "Database migrations in CI/CD automate schema changes (e.g., adding columns) using tools like Knex or Prisma, integrated into pipelines. Safe deployment strategies like blue/green (switching between two environments) or canary (gradual rollout) minimize downtime and risks. For example, a Knex migration adds a column in a CI job, and blue/green deployment swaps environments post-migration. Intermediate learners should integrate migrations in CI and use safe strategies. Be cautious of untested migrations or rollbacks, which cause downtime. These practices ensure reliable deployments for web applications.",
                          "examples": [
                            "# Knex migration\nexports.up = async (knex) => {\n  await knex.schema.table('users', (table) => {\n    table.string('email');\n  });\n};\nexports.down = async (knex) => {\n  await knex.schema.table('users', (table) => {\n    table.dropColumn('email');\n  });\n};",
                            "# Blue/green deployment (pseudocode)\ndeploy_to_blue; test_blue; switch_traffic_to_blue;"
                          ],
                          "realWorldApplication": "Used in web apps to update schemas or deploy APIs with zero downtime.",
                          "expertInsights": "Test migrations in CI; use blue/green for high-traffic apps; plan rollback strategies; automate canary testing.",
                          "commonMistakes": [
                            "Not testing migrations",
                            "Skipping rollback plans",
                            "Ignoring canary metrics"
                          ],
                          "exercises": [
                            {
                              "title": "Add Migration to CI",
                              "prompt": "Create a GitHub Action to run a Knex migration and deploy with a blue/green strategy.",
                              "difficulty": "hard",
                              "hints": [
                                "Run knex migrate:latest",
                                "Simulate blue/green"
                              ],
                              "solution": "# .github/workflows/deploy.yml\nname: Deploy\non: [push]\njobs:\n  migrate-and-deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n        with:\n          node-version: '18'\n      - run: npm install\n      - run: npx knex migrate:latest --env production\n      - name: Deploy Blue\n        run: echo 'Deploying to blue environment'\n      - name: Test Blue\n        run: echo 'Testing blue environment'\n      - name: Switch to Blue\n        run: echo 'Switching traffic to blue'"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What automates schema changes?",
                              "options": [
                                "Caching",
                                "Migrations",
                                "Tracing",
                                "Linting"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is blue/green deployment?",
                              "options": [
                                "Single environment",
                                "Two environments",
                                "Testing",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does canary deployment do?",
                              "options": [
                                "Full rollout",
                                "Gradual rollout",
                                "No rollout",
                                "Testing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks untested migrations?",
                              "options": [
                                "Speed",
                                "Downtime",
                                "Caching",
                                "Styling"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Knex Migrations",
                              "url": "https://knexjs.org/guide/migrations.html",
                              "type": "doc"
                            },
                            {
                              "title": "Blue-Green Deployments",
                              "url": "https://martinfowler.com/bliki/BlueGreenDeployment.html",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T21:03:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439300",
    "title": "Infrastructure as Code & Cloud Fundamentals",
    "slug": "iac-cloud-fundamentals",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439301",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master Infrastructure as Code (IaC) and cloud fundamentals to provision and manage reproducible infrastructure for web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439302",
            "title": "Infrastructure as Code & Cloud Fundamentals",
            "slug": "iac-cloud-fundamentals",
            "shortDescription": "An intermediate course on provisioning infrastructure using IaC and leveraging cloud services for web applications.",
            "longDescription": "This course covers Infrastructure as Code with Terraform or Pulumi, including state management and modules, high-level networking concepts like VPCs, subnets, and load balancers, and managed cloud services such as RDS, Redis, and S3 for storage and database patterns in web applications.",
            "tags": [
              "IaC",
              "Cloud",
              "Terraform",
              "Web Development",
              "Intermediate"
            ],
            "thumbnail": "https://example.com/thumbnails/iac-cloud.jpg",
            "levels": [
              {
                "level": "Intermediate",
                "overview": "This intermediate level focuses on provisioning infrastructure with IaC tools and understanding cloud networking and managed services for scalable web applications.",
                "goals": [
                  "Understand IaC with Terraform or Pulumi, including state and modules",
                  "Learn high-level networking concepts like VPCs, subnets, and load balancers",
                  "Leverage managed services like RDS, Redis, and S3 for cloud patterns"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439303",
                    "title": "Infrastructure as Code & Cloud Fundamentals",
                    "slug": "iac-cloud-fundamentals",
                    "description": "Learn to provision reproducible infrastructure and leverage cloud services for web applications.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439304",
                        "title": "IaC with Terraform or Pulumi Basics",
                        "slug": "iac-terraform-pulumi",
                        "description": "Learn Infrastructure as Code with Terraform or Pulumi, focusing on state and modules.",
                        "order": 1,
                        "content": {
                          "explanation": "Infrastructure as Code (IaC) automates infrastructure provisioning using code. Terraform uses HCL (HashiCorp Configuration Language) to define resources (e.g., `resource 'aws_s3_bucket' 'my_bucket' {}`), with state files tracking infrastructure state. Pulumi uses programming languages like JavaScript for similar tasks. Modules in Terraform/Pulumi encapsulate reusable configurations. For example, a Terraform module defines an S3 bucket and IAM policy. Intermediate learners should write Terraform configurations, manage state, and create modules. Be cautious of state file leaks or unmodularized code, which complicate management. IaC ensures reproducible infrastructure for web applications.",
                          "examples": [
                            "# Terraform S3 bucket\nresource 'aws_s3_bucket' 'my_bucket' {\n  bucket = 'my-app-bucket'\n  acl    = 'private'\n}",
                            "# Pulumi (JavaScript)\nconst aws = require('@pulumi/aws');\nconst bucket = new aws.s3.Bucket('my-bucket', { acl: 'private' });"
                          ],
                          "realWorldApplication": "Used in web apps to provision cloud resources like storage or compute consistently across environments.",
                          "expertInsights": "Use Terraform for declarative IaC; Pulumi for programmatic control; store state securely; modularize configs.",
                          "commonMistakes": [
                            "Exposing state files",
                            "Not using modules for reusable code",
                            "Ignoring state locking for concurrency"
                          ],
                          "exercises": [
                            {
                              "title": "Write Terraform Module for S3",
                              "prompt": "Create a Terraform module to provision an S3 bucket with an IAM policy for read access.",
                              "difficulty": "medium",
                              "hints": [
                                "Define a module with aws_s3_bucket",
                                "Add aws_iam_policy resource"
                              ],
                              "solution": "# modules/s3-bucket/main.tf\nresource 'aws_s3_bucket' 'bucket' {\n  bucket = var.bucket_name\n  acl    = 'private'\n}\n\nresource 'aws_iam_policy' 'bucket_read' {\n  name   = '${var.bucket_name}-read-policy'\n  policy = jsonencode({\n    Version = '2012-10-17'\n    Statement = [{\n      Effect   = 'Allow'\n      Action   = ['s3:GetObject']\n      Resource = \"${aws_s3_bucket.bucket.arn}/*\"\n    }]\n  })\n}\n\n# variables.tf\nvariable 'bucket_name' { type = string }\n\n# main.tf\nmodule 's3' {\n  source      = './modules/s3-bucket'\n  bucket_name = 'my-app-bucket'\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does IaC automate?",
                              "options": [
                                "Testing",
                                "Infrastructure",
                                "Styling",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What tracks Terraform state?",
                              "options": [
                                "Modules",
                                "State files",
                                "Resources",
                                "Variables"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What encapsulates reusable IaC?",
                              "options": [
                                "State",
                                "Modules",
                                "Policies",
                                "Buckets"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Terraform Documentation",
                              "url": "https://www.terraform.io/docs",
                              "type": "doc"
                            },
                            {
                              "title": "Pulumi Documentation",
                              "url": "https://www.pulumi.com/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439305",
                        "title": "Networking Basics (VPC, Subnets, Load Balancers)",
                        "slug": "networking-basics",
                        "description": "Learn high-level networking concepts like VPCs, subnets, and load balancers.",
                        "order": 2,
                        "content": {
                          "explanation": "Networking in the cloud involves Virtual Private Clouds (VPCs), subnets, and load balancers. A VPC isolates resources in a virtual network (e.g., AWS VPC). Subnets divide the VPC into public (internet-accessible) and private (isolated) segments. Load balancers (e.g., AWS ALB) distribute traffic across instances for scalability. For example, a public subnet hosts a web server, while a private subnet hosts a database. Intermediate learners should understand VPC/subnet configurations and load balancer roles at a high level, using Terraform to define them. Be cautious of misconfigured subnets or unbalanced traffic, which affect availability. These concepts ensure scalable networking for web applications.",
                          "examples": [
                            "# Terraform VPC\nresource 'aws_vpc' 'main' {\n  cidr_block = '10.0.0.0/16'\n}\n\nresource 'aws_subnet' 'public' {\n  vpc_id     = aws_vpc.main.id\n  cidr_block = '10.0.1.0/24'\n}",
                            "# Load Balancer\nresource 'aws_lb' 'app' {\n  name               = 'app-lb'\n  load_balancer_type = 'application'\n  subnets            = [aws_subnet.public.id]\n}"
                          ],
                          "realWorldApplication": "Used in web apps to isolate databases in private subnets and distribute traffic via load balancers.",
                          "expertInsights": "Use VPCs for isolation; place APIs in public subnets, DBs in private; configure load balancers for high availability.",
                          "commonMistakes": [
                            "Exposing private subnets",
                            "Not distributing load balancer traffic",
                            "Ignoring VPC CIDR planning"
                          ],
                          "exercises": [
                            {
                              "title": "Define VPC and Subnet",
                              "prompt": "Write Terraform code to create a VPC with a public subnet for a web app.",
                              "difficulty": "medium",
                              "hints": [
                                "Use aws_vpc and aws_subnet",
                                "Set CIDR blocks"
                              ],
                              "solution": "# main.tf\nresource 'aws_vpc' 'main' {\n  cidr_block = '10.0.0.0/16'\n}\n\nresource 'aws_subnet' 'public' {\n  vpc_id     = aws_vpc.main.id\n  cidr_block = '10.0.1.0/24'\n  map_public_ip_on_launch = true\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What isolates cloud resources?",
                              "options": [
                                "Subnets",
                                "VPCs",
                                "Load balancers",
                                "S3"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What hosts web servers?",
                              "options": [
                                "Private subnets",
                                "Public subnets",
                                "VPCs",
                                "RDS"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What distributes traffic?",
                              "options": [
                                "VPCs",
                                "Subnets",
                                "Load balancers",
                                "Buckets"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "What risks misconfigured subnets?",
                              "options": [
                                "Caching",
                                "Availability",
                                "Styling",
                                "Testing"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "AWS VPC",
                              "url": "https://docs.aws.amazon.com/vpc/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439306",
                        "title": "Managed Services: RDS, Redis, S3, Cloud Storage Patterns",
                        "slug": "managed-services",
                        "description": "Learn to use managed services like RDS, Redis, and S3 for cloud patterns.",
                        "order": 3,
                        "content": {
                          "explanation": "Managed services simplify infrastructure management. AWS RDS provides managed relational databases (e.g., PostgreSQL), Redis offers in-memory caching, and S3 handles object storage (e.g., for images or backups). Cloud storage patterns include using S3 for static assets, RDS for user data, and Redis for session caching. For example, an S3 bucket stores user-uploaded files, while RDS stores order data. Intermediate learners should provision these services with Terraform and apply them to web apps. Be cautious of misconfigured permissions or unscalable patterns, which risk security or performance. These services enhance scalability and reliability in web applications.",
                          "examples": [
                            "# Terraform RDS\nresource 'aws_db_instance' 'main' {\n  engine           = 'postgres'\n  instance_class   = 'db.t3.micro'\n  db_name          = 'myapp'\n  username         = 'admin'\n  password         = 'securepassword'\n}",
                            "# S3 bucket\nresource 'aws_s3_bucket' 'assets' {\n  bucket = 'my-app-assets'\n  acl    = 'public-read'\n}"
                          ],
                          "realWorldApplication": "Used in e-commerce for storing product images in S3, user data in RDS, and sessions in Redis.",
                          "expertInsights": "Use RDS for relational data; S3 for static assets; Redis for caching; secure access with IAM.",
                          "commonMistakes": [
                            "Exposing S3 buckets publicly",
                            "Not encrypting RDS data",
                            "Ignoring Redis eviction policies"
                          ],
                          "exercises": [
                            {
                              "title": "Provision S3 and IAM Policy",
                              "prompt": "Write a Terraform module to create an S3 bucket with an IAM policy for read-only access.",
                              "difficulty": "medium",
                              "hints": [
                                "Use aws_s3_bucket and aws_iam_policy",
                                "Set read-only permissions"
                              ],
                              "solution": "# modules/s3-bucket/main.tf\nresource 'aws_s3_bucket' 'bucket' {\n  bucket = var.bucket_name\n  acl    = 'private'\n}\n\nresource 'aws_iam_policy' 'bucket_read' {\n  name   = '${var.bucket_name}-read-policy'\n  policy = jsonencode({\n    Version = '2012-10-17'\n    Statement = [{\n      Effect   = 'Allow'\n      Action   = ['s3:GetObject']\n      Resource = \"${aws_s3_bucket.bucket.arn}/*\"\n    }]\n  })\n}\n\n# variables.tf\nvariable 'bucket_name' { type = string }\n\n# main.tf\nmodule 's3' {\n  source      = './modules/s3-bucket'\n  bucket_name = 'my-app-bucket'\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does RDS provide?",
                              "options": [
                                "Caching",
                                "Databases",
                                "Storage",
                                "Compute"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is S3 used for?",
                              "options": [
                                "Databases",
                                "Object storage",
                                "Caching",
                                "Compute"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does Redis store?",
                              "options": [
                                "Files",
                                "Sessions",
                                "Schemas",
                                "Logs"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "AWS RDS",
                              "url": "https://docs.aws.amazon.com/rds/",
                              "type": "doc"
                            },
                            {
                              "title": "AWS S3",
                              "url": "https://docs.aws.amazon.com/s3/",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T21:05:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439310",
    "title": "Scaling, Caching & Cost Optimization",
    "slug": "scaling-caching-cost-optimization",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439311",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master scaling, caching, and cost optimization techniques to enhance performance and manage resources efficiently in web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439312",
            "title": "Scaling, Caching & Cost Optimization",
            "slug": "scaling-caching-cost-optimization",
            "shortDescription": "An intermediate course on scaling reads and writes, implementing caching, and optimizing cloud costs for web applications.",
            "longDescription": "This course covers CDN usage with edge caching and invalidation strategies, implementing caching layers like HTTP cache, Redis, CDN, and database replicas, and cost-aware practices such as sizing, autoscaling, and rightsizing resources to ensure scalable and cost-efficient web applications.",
            "tags": [
              "Scaling",
              "Caching",
              "Cost Optimization",
              "Web Development",
              "Intermediate"
            ],
            "thumbnail": "https://example.com/thumbnails/scaling-caching.jpg",
            "levels": [
              {
                "level": "Intermediate",
                "overview": "This intermediate level focuses on scaling web applications, implementing effective caching strategies, and optimizing cloud costs for performance and efficiency.",
                "goals": [
                  "Understand CDN usage, edge caching, and cache invalidation strategies",
                  "Implement caching layers including HTTP cache, Redis, CDN, and DB replicas",
                  "Apply cost-aware practices like sizing, autoscaling, and rightsizing resources"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439313",
                    "title": "Scaling, Caching & Cost Optimization",
                    "slug": "scaling-caching-cost-optimization",
                    "description": "Learn to scale web applications, implement caching layers, and optimize cloud costs for efficient performance.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439314",
                        "title": "CDN Usage, Edge Caching, and Cache Invalidation",
                        "slug": "cdn-edge-caching",
                        "description": "Learn to use CDNs, implement edge caching, and manage cache invalidation strategies.",
                        "order": 1,
                        "content": {
                          "explanation": "Content Delivery Networks (CDNs) like Cloudflare or AWS CloudFront cache static assets (e.g., images, CSS) at edge locations to reduce latency. Edge caching stores content closer to users, improving load times. Cache invalidation ensures updated content is served, using strategies like versioned URLs (e.g., `style.v2.css`) or purging cache (e.g., `PURGE /image.jpg`). For example, CloudFront caches a website’s assets with a TTL (time-to-live). Intermediate learners should configure a CDN for a web app and implement invalidation. Be cautious of stale caches or improper invalidation, which serve outdated content. These practices enhance performance in web applications.",
                          "examples": [
                            "// CloudFront distribution (Terraform)\nresource 'aws_cloudfront_distribution' 'cdn' {\n  origin {\n    domain_name = 'my-bucket.s3.amazonaws.com'\n    origin_id   = 'S3-my-bucket'\n  }\n  default_cache_behavior {\n    target_origin_id = 'S3-my-bucket'\n    min_ttl          = 0\n    default_ttl      = 86400\n    max_ttl          = 31536000\n  }\n}",
                            "// Versioned URL for invalidation\n<img src='/image.jpg?v=2' alt='Product'>"
                          ],
                          "realWorldApplication": "Used in e-commerce to serve product images quickly via CDNs or cache static assets for fast page loads.",
                          "expertInsights": "Use CloudFront or Cloudflare for CDNs; set appropriate TTLs; use versioned URLs or purges for invalidation.",
                          "commonMistakes": [
                            "Setting overly long TTLs",
                            "Not invalidating updated content",
                            "Ignoring CDN caching for dynamic content"
                          ],
                          "exercises": [
                            {
                              "title": "Configure CDN Caching",
                              "prompt": "Write Terraform code to set up a CloudFront distribution for an S3 bucket with a 1-day TTL.",
                              "difficulty": "medium",
                              "hints": [
                                "Use aws_cloudfront_distribution",
                                "Set default_ttl to 86400"
                              ],
                              "solution": "# main.tf\nresource 'aws_cloudfront_distribution' 'cdn' {\n  origin {\n    domain_name = 'my-bucket.s3.amazonaws.com'\n    origin_id   = 'S3-my-bucket'\n  }\n  enabled = true\n  default_cache_behavior {\n    target_origin_id = 'S3-my-bucket'\n    viewer_protocol_policy = 'redirect-to-https'\n    min_ttl   = 0\n    default_ttl = 86400\n    max_ttl   = 31536000\n    allowed_methods = ['GET', 'HEAD']\n    cached_methods  = ['GET', 'HEAD']\n  }\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does a CDN cache?",
                              "options": [
                                "Dynamic data",
                                "Static assets",
                                "Database",
                                "Logs"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What reduces latency in CDNs?",
                              "options": [
                                "Edge caching",
                                "Database",
                                "Indexing",
                                "Tracing"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What ensures updated content?",
                              "options": [
                                "TTL",
                                "Invalidation",
                                "Compression",
                                "Encryption"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "AWS CloudFront",
                              "url": "https://docs.aws.amazon.com/cloudfront/",
                              "type": "doc"
                            },
                            {
                              "title": "Cloudflare CDN",
                              "url": "https://www.cloudflare.com/cdn/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439315",
                        "title": "Caching Layers: HTTP Cache, Redis, CDN, DB Replicas",
                        "slug": "caching-layers",
                        "description": "Learn to implement caching layers including HTTP cache, Redis, CDN, and database replicas.",
                        "order": 2,
                        "content": {
                          "explanation": "Caching layers improve performance by storing frequently accessed data. HTTP caching uses headers like `Cache-Control: max-age=3600` to cache responses in browsers. Redis caches in-memory data (e.g., `SET user:1 '{'id':'1','name':'Alice'}'`), reducing database queries. CDNs cache static assets at edge locations. Database replicas (e.g., read replicas in RDS) offload read queries from primary databases. For example, Redis caches API responses, while replicas handle read-heavy queries. Intermediate learners should implement Redis caching and HTTP headers, exploring read replicas. Be cautious of stale caches or unscaled replicas, which affect performance. These layers ensure scalability in web applications.",
                          "examples": [
                            "// Redis caching (Express)\nconst redis = require('redis');\nconst client = redis.createClient();\napp.get('/user/:id', async (req, res) => {\n  const cached = await client.get(`user:${req.params.id}`);\n  if (cached) return res.json(JSON.parse(cached));\n  const user = await db.query('SELECT * FROM users WHERE id = $1', [req.params.id]);\n  await client.setEx(`user:${req.params.id}`, 3600, JSON.stringify(user));\n  res.json(user);\n});",
                            "// HTTP Cache-Control\napp.get('/static', (req, res) => {\n  res.set('Cache-Control', 'public, max-age=3600');\n  res.json({ data: 'cached' });\n});"
                          ],
                          "realWorldApplication": "Used in social media apps for caching user profiles or in e-commerce for product data.",
                          "expertInsights": "Use Redis for dynamic data; set Cache-Control for static responses; scale read replicas for heavy reads.",
                          "commonMistakes": [
                            "Not setting cache expiration",
                            "Caching sensitive data",
                            "Ignoring replica lag"
                          ],
                          "exercises": [
                            {
                              "title": "Add Redis Caching to Endpoint",
                              "prompt": "Add Redis caching to a read-heavy Express endpoint and measure latency improvement.",
                              "difficulty": "medium",
                              "hints": [
                                "Use redis.get and redis.setEx",
                                "Log response time"
                              ],
                              "solution": "const express = require('express');\nconst redis = require('redis');\nconst app = express();\nconst client = redis.createClient();\napp.get('/user/:id', async (req, res) => {\n  const start = Date.now();\n  const cached = await client.get(`user:${req.params.id}`);\n  if (cached) {\n    console.log(`Cache hit: ${Date.now() - start}ms`);\n    return res.json(JSON.parse(cached));\n  }\n  const user = { id: req.params.id, name: 'Alice' }; // Simulate DB\n  await client.setEx(`user:${req.params.id}`, 3600, JSON.stringify(user));\n  console.log(`Cache miss: ${Date.now() - start}ms`);\n  res.json(user);\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does HTTP caching use?",
                              "options": [
                                "Redis",
                                "Headers",
                                "Replicas",
                                "CDN"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What caches in-memory data?",
                              "options": ["S3", "Redis", "RDS", "CloudFront"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What offloads read queries?",
                              "options": [
                                "CDN",
                                "Replicas",
                                "Redis",
                                "Headers"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks stale caches?",
                              "options": [
                                "No expiration",
                                "Compression",
                                "Encryption",
                                "Indexing"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 100,
                          "resources": [
                            {
                              "title": "Redis Documentation",
                              "url": "https://redis.io/docs/",
                              "type": "doc"
                            },
                            {
                              "title": "HTTP Caching",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439316",
                        "title": "Cost-Awareness: Sizing, Autoscaling, Rightsizing Resources",
                        "slug": "cost-awareness",
                        "description": "Learn cost-aware practices like sizing, autoscaling, and rightsizing cloud resources.",
                        "order": 3,
                        "content": {
                          "explanation": "Cost-awareness optimizes cloud spending. Sizing chooses appropriate resource types (e.g., AWS EC2 t3.micro vs. m5.large). Autoscaling adjusts resources based on demand (e.g., scaling EC2 instances when CPU exceeds 70%). Rightsizing matches resources to workloads, avoiding over-provisioning (e.g., downsizing an oversized RDS instance). For example, using AWS Auto Scaling with a target CPU usage saves costs. Intermediate learners should configure autoscaling and analyze resource usage for rightsizing. Be cautious of under-scaling, which impacts performance, or over-provisioning, which increases costs. These practices ensure cost-efficient web applications.",
                          "examples": [
                            "# Terraform Autoscaling\nresource 'aws_autoscaling_group' 'app' {\n  min_size         = 1\n  max_size         = 3\n  desired_capacity = 2\n  launch_template {\n    id = aws_launch_template.app.id\n  }\n  target_group_arns = [aws_lb_target_group.app.arn]\n}",
                            "# Rightsizing (RDS example)\nresource 'aws_db_instance' 'main' {\n  instance_class = 'db.t3.micro' # Rightsized from db.m5.large\n  engine         = 'postgres'\n}"
                          ],
                          "realWorldApplication": "Used in web apps to scale APIs during traffic spikes or reduce costs for low-traffic periods.",
                          "expertInsights": "Use autoscaling for dynamic loads; monitor usage for rightsizing; prefer serverless for cost savings.",
                          "commonMistakes": [
                            "Over-provisioning resources",
                            "Not configuring autoscaling",
                            "Ignoring cost monitoring tools"
                          ],
                          "exercises": [
                            {
                              "title": "Configure Autoscaling",
                              "prompt": "Write Terraform code to set up an autoscaling group for an EC2-based web app.",
                              "difficulty": "medium",
                              "hints": [
                                "Use aws_autoscaling_group",
                                "Set min_size and max_size"
                              ],
                              "solution": "# main.tf\nresource 'aws_launch_template' 'app' {\n  name          = 'app-template'\n  image_id      = 'ami-12345678'\n  instance_type = 't3.micro'\n}\n\nresource 'aws_autoscaling_group' 'app' {\n  min_size         = 1\n  max_size         = 3\n  desired_capacity = 2\n  vpc_zone_identifier = ['subnet-12345678']\n  launch_template {\n    id = aws_launch_template.app.id\n  }\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does autoscaling adjust?",
                              "options": [
                                "Styles",
                                "Resources",
                                "Caching",
                                "Logs"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What matches resources to workloads?",
                              "options": [
                                "Autoscaling",
                                "Rightsizing",
                                "Caching",
                                "Tracing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks over-provisioning?",
                              "options": [
                                "Performance",
                                "High costs",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "AWS Auto Scaling",
                              "url": "https://docs.aws.amazon.com/autoscaling/",
                              "type": "doc"
                            },
                            {
                              "title": "AWS Cost Optimization",
                              "url": "https://aws.amazon.com/architecture/cost-optimization/",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T21:07:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439320",
    "title": "Capstone & Real-World Project",
    "slug": "capstone-real-world-project",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439321",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Integrate all learned concepts to design, build, test, deploy, and monitor a full-stack capstone project for real-world application.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439322",
            "title": "Capstone & Real-World Project",
            "slug": "capstone-real-world-project",
            "shortDescription": "An intermediate capstone course to combine skills in building, testing, and deploying a full-stack project.",
            "longDescription": "This capstone course guides you through combining HTML, CSS, JavaScript, backend, security, performance, and deployment to build a complete full-stack project, such as a task tracker or mini SaaS, with assessment based on functionality, code quality, and more.",
            "tags": [
              "Capstone",
              "Full-Stack",
              "Project",
              "Web Development",
              "Intermediate"
            ],
            "thumbnail": "https://example.com/thumbnails/capstone-project.jpg",
            "levels": [
              {
                "level": "Intermediate",
                "overview": "This intermediate capstone level focuses on applying all course concepts to build, test, deploy, and monitor a real-world full-stack project.",
                "goals": [
                  "Design and build a full-stack task tracker with auth, realtime notifications, persistence, and offline support",
                  "Develop a mini SaaS with user management, billing integration, admin dashboard, and multi-tenant considerations",
                  "Meet deliverables including functional features, code quality, performance, security, and deployment",
                  "Assess project based on the provided rubric for comprehensive evaluation"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439323",
                    "title": "Capstone & Real-World Project",
                    "slug": "capstone-real-world-project",
                    "description": "Combine all skills to build, test, deploy, and monitor a full-stack capstone project.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439324",
                        "title": "Capstone Overview and Goal",
                        "slug": "capstone-overview-goal",
                        "description": "Understand the capstone goal to integrate all concepts into a cohesive project.",
                        "order": 1,
                        "content": {
                          "explanation": "The capstone project combines frontend, backend, security, performance, testing, and deployment to create a complete full-stack application. The goal is to design, build, test, deploy, and monitor a project that demonstrates practical skills, such as a task tracker with auth and realtime features or a mini SaaS with billing. This hands-on experience reinforces learning by applying concepts in a real-world context, ensuring the project meets criteria for functionality, code quality, and more. Intermediate learners should plan the project architecture, select technologies, and follow best practices. Be cautious of scope creep or neglecting rubric categories, which can affect assessment. This overview prepares you for successful capstone completion.",
                          "examples": [
                            "// Project planning pseudocode\n- Frontend: React with state management\n- Backend: Express with auth\n- Database: Postgres with migrations\n- Deployment: Vercel or Cloud Run"
                          ],
                          "realWorldApplication": "Applies to building production-ready apps like task managers or SaaS tools for real users.",
                          "expertInsights": "Start with a clear scope; iterate based on rubric; document decisions for README.",
                          "commonMistakes": [
                            "Over-scoping the project",
                            "Ignoring testing or security",
                            "Not planning for deployment early"
                          ],
                          "exercises": [
                            {
                              "title": "Plan Capstone Project",
                              "prompt": "Outline the architecture for a task tracker capstone, including tech stack and features.",
                              "difficulty": "medium",
                              "hints": [
                                "Include auth, realtime, persistence",
                                "Use rubric categories"
                              ],
                              "solution": "// Outline\nTech Stack:\n- Frontend: React, Next.js\n- Backend: Express, Node.js\n- Database: Postgres\n- Auth: NextAuth\n- Realtime: Socket.IO\n- Persistence: localStorage for offline\nFeatures:\n- User auth\n- Add/delete tasks\n- Realtime notifications\n- Offline support\nRubric Alignment:\n- Functionality: Core features tested\n- Code Quality: ES6+, linted\n- Performance: Caching\n- Security: Secure auth\n- Deployment: Vercel with README"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is the capstone goal?",
                              "options": [
                                "Theory",
                                "Integrate concepts",
                                "Styling",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What ensures project success?",
                              "options": ["Rubric", "Colors", "Fonts", "Logs"],
                              "correctOption": [0]
                            },
                            {
                              "question": "What risks capstone failure?",
                              "options": [
                                "Scope creep",
                                "Planning",
                                "Testing",
                                "Deployment"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 180,
                          "resources": [
                            {
                              "title": "Full-Stack Project Guide",
                              "url": "https://www.freecodecamp.org/news/how-to-build-a-fullstack-project/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439325",
                        "title": "Full-Stack Task Tracker Project",
                        "slug": "task-tracker-project",
                        "description": "Build a full-stack task tracker with auth, realtime notifications, persistence, and offline support.",
                        "order": 2,
                        "content": {
                          "explanation": "The task tracker project integrates auth (e.g., NextAuth), realtime notifications (e.g., Socket.IO), persistence (e.g., Postgres), and offline support (e.g., localStorage for syncing). Frontend uses React for UI, backend uses Express or Next.js API routes. Implement features like add/update tasks, user auth, realtime updates, and offline mode with sync on reconnect. Deploy to a cloud provider like Vercel. Intermediate learners should follow the rubric, testing functionality and code quality. Be cautious of insecure auth or unsynced offline data. This project demonstrates full-stack skills in a practical application.",
                          "examples": [
                            "// Task tracker auth (NextAuth)\nNextAuth({\n  providers: [CredentialsProvider({...})],\n  callbacks: { jwt: ({ token, user }) => ({ ...token, id: user.id }) }\n});",
                            "// Realtime with Socket.IO\nio.on('connection', (socket) => {\n  socket.on('taskUpdate', (task) => io.emit('taskUpdated', task));\n});"
                          ],
                          "realWorldApplication": "Similar to Trello or Todoist for collaborative task management.",
                          "expertInsights": "Use IndexedDB for advanced offline; implement optimistic updates with realtime.",
                          "commonMistakes": [
                            "Not handling offline sync conflicts",
                            "Weak auth implementation",
                            "Ignoring performance in realtime"
                          ],
                          "exercises": [
                            {
                              "title": "Build Task Tracker",
                              "prompt": "Implement a task tracker with auth, realtime, persistence, and offline support.",
                              "difficulty": "hard",
                              "hints": [
                                "Use Next.js for full-stack",
                                "Integrate Socket.IO for realtime"
                              ],
                              "solution": "// Example snippet for offline sync\nuseEffect(() => {\n  if (navigator.onLine) {\n    const offlineTasks = JSON.parse(localStorage.getItem('offlineTasks') || '[]');\n    offlineTasks.forEach(task => addTask(task));\n    localStorage.removeItem('offlineTasks');\n  }\n}, []);\n// Add task function with offline fallback\nasync function addTask(task) {\n  if (!navigator.onLine) {\n    const offlineTasks = JSON.parse(localStorage.getItem('offlineTasks') || '[]');\n    offlineTasks.push(task);\n    localStorage.setItem('offlineTasks', JSON.stringify(offlineTasks));\n    return;\n  }\n  await fetch('/api/tasks', { method: 'POST', body: JSON.stringify(task) });\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What provides offline support?",
                              "options": [
                                "Socket.IO",
                                "localStorage",
                                "Postgres",
                                "NextAuth"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What handles realtime updates?",
                              "options": [
                                "localStorage",
                                "Socket.IO",
                                "Postgres",
                                "NextAuth"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What ensures persistence?",
                              "options": [
                                "Database",
                                "localStorage",
                                "Socket.IO",
                                "Auth"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What secures user access?",
                              "options": [
                                "Postgres",
                                "Auth",
                                "Socket.IO",
                                "localStorage"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 360,
                          "resources": [
                            {
                              "title": "Next.js Docs",
                              "url": "https://nextjs.org/docs",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439326",
                        "title": "Mini SaaS Project",
                        "slug": "mini-saas-project",
                        "description": "Build a mini SaaS with user management, billing integration, admin dashboard, and multi-tenant considerations.",
                        "order": 3,
                        "content": {
                          "explanation": "The mini SaaS project includes user management (auth, profiles), billing with Stripe sandbox (e.g., subscriptions), admin dashboard for oversight, and multi-tenant design (e.g., shared DB with tenant IDs or per-tenant DBs). Use Stripe for payment testing (`stripe.checkout.sessions.create`). Multi-tenant patterns ensure data isolation (e.g., filter by tenantId). Deploy to a cloud provider. Intermediate learners should integrate Stripe, design tenant-aware models, and build the dashboard. Be cautious of billing errors or data leakage in multi-tenancy. This project demonstrates full-stack SaaS development.",
                          "examples": [
                            "// Stripe billing\nimport Stripe from 'stripe';\nconst stripe = new Stripe(process.env.STRIPE_SECRET);\nconst session = await stripe.checkout.sessions.create({\n  payment_method_types: ['card'],\n  line_items: [{ price: 'price_id', quantity: 1 }],\n  mode: 'subscription'\n});",
                            "// Multi-tenant query\nawait db.query('SELECT * FROM data WHERE tenant_id = $1', [user.tenantId]);"
                          ],
                          "realWorldApplication": "Similar to SaaS like Slack or Dropbox for user management and billing.",
                          "expertInsights": "Use Stripe for billing; implement row-level security for multi-tenancy; test sandbox payments.",
                          "commonMistakes": [
                            "Not using Stripe sandbox",
                            "Ignoring tenant isolation",
                            "Complex dashboard without testing"
                          ],
                          "exercises": [
                            {
                              "title": "Build Mini SaaS",
                              "prompt": "Implement user management and billing with Stripe in a mini SaaS.",
                              "difficulty": "hard",
                              "hints": [
                                "Use Stripe sandbox",
                                "Add tenantId to models"
                              ],
                              "solution": "// Billing route\nimport Stripe from 'stripe';\nconst stripe = new Stripe(process.env.STRIPE_SECRET);\napp.post('/subscribe', async (req, res) => {\n  const session = await stripe.checkout.sessions.create({\n    customer_email: req.body.email,\n    mode: 'subscription',\n    payment_method_types: ['card'],\n    line_items: [{ price: 'price_123', quantity: 1 }]\n  });\n  res.json({ sessionId: session.id });\n});\n\n// Multi-tenant model\nmodel User {\n  id Int @id\n  tenantId String\n  @@index([tenantId])\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What integrates billing?",
                              "options": [
                                "Stripe",
                                "Redis",
                                "Postgres",
                                "Socket.IO"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What ensures multi-tenant isolation?",
                              "options": [
                                "Tenant IDs",
                                "Billing",
                                "Auth",
                                "Realtime"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What is Stripe sandbox?",
                              "options": [
                                "Production",
                                "Testing environment",
                                "Database",
                                "Frontend"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 360,
                          "resources": [
                            {
                              "title": "Stripe Documentation",
                              "url": "https://stripe.com/docs",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439327",
                        "title": "Deliverables & Rubric",
                        "slug": "deliverables-rubric",
                        "description": "Understand the capstone deliverables and assessment rubric.",
                        "order": 4,
                        "content": {
                          "explanation": "The capstone deliverables include a functional project with tested features, code quality (e.g., linted, typed), performance optimizations, security implementations, and deployment with README. The rubric assesses: functionality (40%), code quality (15%), performance (15%), security (15%), deployment/docs (15%). For example, functionality checks core features like auth and realtime. Intermediate learners should align work with the rubric, documenting in README. Be cautious of unbalanced focus, e.g., neglecting security. This rubric ensures comprehensive project evaluation.",
                          "examples": [
                            "// Rubric example\nFunctionality: 40% - All core features implemented and tested\nCode Quality: 15% - ES6+, linted, typed code"
                          ],
                          "realWorldApplication": "Similar to project assessments in professional development or portfolios.",
                          "expertInsights": "Document tradeoffs in README; test against rubric; prioritize high-weight categories.",
                          "commonMistakes": [
                            "Ignoring rubric percentages",
                            "Poor documentation",
                            "Untested features"
                          ],
                          "exercises": [
                            {
                              "title": "Assess Capstone",
                              "prompt": "Self-assess a capstone project against the rubric, noting scores for each category.",
                              "difficulty": "medium",
                              "hints": [
                                "Review features, code, etc.",
                                "Assign scores based on rubric"
                              ],
                              "solution": "// Self-Assessment\nFunctionality: 35/40 - All features work, minor bug\nCode Quality: 12/15 - Typed, but some lint errors\nPerformance: 13/15 - Caching implemented\nSecurity: 14/15 - Auth secure\nDeployment: 15/15 - Deployed with README\nTotal: 89/100"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What has the highest rubric weight?",
                              "options": [
                                "Functionality",
                                "Code Quality",
                                "Performance",
                                "Deployment"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What includes README?",
                              "options": [
                                "Functionality",
                                "Deployment",
                                "Security",
                                "Performance"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What assesses typesafety?",
                              "options": [
                                "Functionality",
                                "Code Quality",
                                "Performance",
                                "Security"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What checks auth?",
                              "options": [
                                "Security",
                                "Deployment",
                                "Code Quality",
                                "Functionality"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 180,
                          "resources": [
                            {
                              "title": "Project Rubric Guide",
                              "url": "https://www.example.com/project-rubric",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T21:10:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439330",
    "title": "Advanced JavaScript & Runtime Mastery",
    "slug": "advanced-js-runtime-mastery",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439331",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master advanced JavaScript internals and runtime behaviors to build robust, high-performance web systems.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439332",
            "title": "Advanced JavaScript & Runtime Mastery",
            "slug": "advanced-javascript-runtime-mastery",
            "shortDescription": "An advanced course on JavaScript engine internals, async patterns, memory management, performance optimizations, and metaprogramming.",
            "longDescription": "This course delves into JavaScript's V8 engine internals, event loop mechanics, advanced asynchronous patterns with cancellations, memory models and garbage collection tuning, low-level performance optimizations using TypedArrays, and advanced patterns like proxies and code generation for building robust web systems.",
            "tags": ["JavaScript", "Runtime", "Performance", "Advanced"],
            "thumbnail": "https://example.com/thumbnails/advanced-js-runtime.jpg",
            "levels": [
              {
                "level": "Advanced",
                "overview": "This advanced level explores JavaScript internals and runtime mastery to optimize and build high-performance web applications.",
                "goals": [
                  "Understand JavaScript engine internals and event loop mechanics",
                  "Implement advanced async patterns with cancellations and streams",
                  "Manage memory, detect leaks, and tune garbage collection",
                  "Apply low-level optimizations and advanced patterns like proxies"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439333",
                    "title": "Advanced JavaScript & Runtime Mastery",
                    "slug": "advanced-js-runtime-mastery",
                    "description": "Master JavaScript internals and runtime behaviors for robust, high-performance systems.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439334",
                        "title": "Engine Internals: V8, Event Loop, Microtasks vs Macrotasks",
                        "slug": "engine-internals-v8-event-loop",
                        "description": "Explore JavaScript engine internals, event loop, and task queues.",
                        "order": 1,
                        "content": {
                          "explanation": "JavaScript engines like V8 (Chrome/Node.js) compile code to machine code with JIT compilation for performance. The event loop manages execution, processing macrotasks (e.g., setTimeout, I/O) and microtasks (e.g., Promises, process.nextTick) in phases. Microtasks run after the current macrotask, before the next. For example, a Promise resolves in a microtask, ensuring priority over setTimeout. Advanced learners should understand loop phases to debug async issues. Be cautious of microtask overloads blocking the loop. These concepts are crucial for optimizing web apps.",
                          "examples": [
                            "console.log('Start');\nsetTimeout(() => console.log('Timeout'), 0);\nPromise.resolve().then(() => console.log('Promise'));\nconsole.log('End'); // Start, End, Promise, Timeout"
                          ],
                          "realWorldApplication": "Used in high-performance web apps to manage async flows without blocking UI.",
                          "expertInsights": "Use queueMicrotask for priority tasks; profile loop with DevTools.",
                          "commonMistakes": [
                            "Assuming setTimeout runs before Promises",
                            "Overloading microtasks",
                            "Ignoring event loop starvation"
                          ],
                          "exercises": [
                            {
                              "title": "Profile Memory Leak",
                              "prompt": "Create and fix a memory leak using closures in a loop; profile with Chrome DevTools.",
                              "difficulty": "hard",
                              "hints": [
                                "Use event listeners without removal",
                                "Inspect heap snapshots"
                              ],
                              "solution": "// Leak\nfor (let i = 0; i < 10; i++) {\n  document.addEventListener('click', () => console.log(i));\n}\n// Fix\nfor (let i = 0; i < 10; i++) {\n  const handler = () => console.log(i);\n  document.addEventListener('click', handler);\n  // Remove later: document.removeEventListener('click', handler);\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What processes microtasks?",
                              "options": [
                                "Macrotask queue",
                                "Event loop",
                                "V8",
                                "JIT"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What are Promises?",
                              "options": [
                                "Macrotasks",
                                "Microtasks",
                                "Sync",
                                "Async functions"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What compiles JS in V8?",
                              "options": ["Event loop", "JIT", "GC", "Proxies"],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "V8 Engine",
                              "url": "https://v8.dev/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439335",
                        "title": "Advanced Async: Cancellation, AbortController, Observable Patterns, Stream APIs",
                        "slug": "advanced-async",
                        "description": "Master advanced asynchronous patterns including cancellations and streams.",
                        "order": 2,
                        "content": {
                          "explanation": "Advanced async includes cancellation with AbortController, observables for reactive data (e.g., RxJS), and stream APIs for handling large data (e.g., ReadableStreams). AbortController signals cancellation (e.g., `controller.abort()` for fetch). Observables manage event streams, while streams process data in chunks. For example, a cancellable fetch uses `signal: controller.signal`. Advanced learners should implement cancellations for async tasks and use RxJS for observables. Be cautious of unhandled cancellations or stream backpressure. These patterns optimize realtime web apps.",
                          "examples": [
                            "const controller = new AbortController();\nfetch('/data', { signal: controller.signal }).catch(err => {\n  if (err.name === 'AbortError') console.log('Canceled');\n});\ncontroller.abort();"
                          ],
                          "realWorldApplication": "Used in web apps for cancellable API calls or streaming video processing.",
                          "expertInsights": "Use AbortController for all cancellable async; RxJS for complex observables; handle stream errors.",
                          "commonMistakes": [
                            "Not catching AbortError",
                            "Ignoring stream backpressure",
                            "Overusing observables for simple tasks"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Cancellable Fetch Wrapper",
                              "prompt": "Create a wrapper function for fetch that supports cancellation with AbortController.",
                              "difficulty": "medium",
                              "hints": [
                                "Return fetch promise and abort function",
                                "Use signal in fetch"
                              ],
                              "solution": "function cancellableFetch(url) {\n  const controller = new AbortController();\n  const promise = fetch(url, { signal: controller.signal });\n  return { promise, cancel: () => controller.abort() };\n}\nconst { promise, cancel } = cancellableFetch('/data');\npromise.catch(err => { if (err.name === 'AbortError') console.log('Canceled'); });\n// Later: cancel();"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What cancels a fetch?",
                              "options": [
                                "AbortController",
                                "Promise.reject",
                                "setTimeout",
                                "try-catch"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What are observables for?",
                              "options": [
                                "Reactive streams",
                                "Static data",
                                "Styling",
                                "Deployment"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What processes data in chunks?",
                              "options": [
                                "Promises",
                                "Streams",
                                "Generators",
                                "Proxies"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is RxJS?",
                              "options": [
                                "Styling library",
                                "Observable library",
                                "Database",
                                "Bundler"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "MDN AbortController",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/API/AbortController",
                              "type": "article"
                            },
                            {
                              "title": "RxJS Documentation",
                              "url": "https://rxjs.dev/guide/overview",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439336",
                        "title": "Memory Model & GC Tuning, Memory Leaks, Profiling",
                        "slug": "memory-model-gc",
                        "description": "Learn JavaScript memory management, garbage collection, leak detection, and profiling.",
                        "order": 3,
                        "content": {
                          "explanation": "JavaScript's memory model allocates objects in the heap, managed by garbage collection (GC) like V8's mark-and-sweep. GC tuning (e.g., Node `--max-old-space-size=4096`) adjusts heap size. Memory leaks occur from unreleased resources (e.g., event listeners). Profiling with Chrome DevTools (heap snapshots, allocation timelines) detects leaks. For example, a closure retaining references causes leaks if not cleared. Advanced learners should profile apps, fix leaks by removing listeners, and tune GC for high-memory apps. Be cautious of large retained objects or frequent GC pauses. These concepts ensure memory-efficient web apps.",
                          "examples": [
                            "// Memory leak\ndocument.addEventListener('click', () => console.log('Click'));\n// Fix\ndocument.removeEventListener('click', handler);",
                            "// Heap snapshot in DevTools\n// Navigate to Memory tab, take snapshot, inspect retained objects"
                          ],
                          "realWorldApplication": "Used in long-running web apps like dashboards to prevent memory leaks and crashes.",
                          "expertInsights": "Use DevTools for profiling; clear references in closures; tune heap for Node servers.",
                          "commonMistakes": [
                            "Not removing event listeners",
                            "Retaining large arrays in closures",
                            "Ignoring GC pauses"
                          ],
                          "exercises": [
                            {
                              "title": "Profile and Fix Memory Leak",
                              "prompt": "Create a script with a memory leak using event listeners and fix it; suggest profiling in DevTools.",
                              "difficulty": "hard",
                              "hints": [
                                "Add listener without removal",
                                "Use removeEventListener to fix"
                              ],
                              "solution": "// Leak\nlet handlers = [];\nfor (let i = 0; i < 100; i++) {\n  handlers.push(() => console.log(i));\n  document.addEventListener('click', handlers[i]);\n}\n// Fix\nhandlers.forEach(h => document.removeEventListener('click', h));\n// Profile: Use Chrome DevTools Memory tab to take heap snapshots before/after fix and inspect retained objects."
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What manages JS memory?",
                              "options": ["Event loop", "GC", "JIT", "Proxies"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What causes memory leaks?",
                              "options": [
                                "Released resources",
                                "Unreleased resources",
                                "GC tuning",
                                "Profiling"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What tool profiles memory?",
                              "options": [
                                "Console",
                                "DevTools",
                                "ESLint",
                                "Webpack"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "How do you tune V8 GC?",
                              "options": [
                                "--max-old-space-size",
                                "--min-new-space-size",
                                "--optimize",
                                "--profile"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "V8 Memory Management",
                              "url": "https://v8.dev/blog/memory",
                              "type": "article"
                            },
                            {
                              "title": "Chrome DevTools Memory",
                              "url": "https://developer.chrome.com/docs/devtools/memory/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439337",
                        "title": "Performance Patterns and Low-Level Optimizations",
                        "slug": "performance-patterns-low-level",
                        "description": "Learn performance patterns and low-level optimizations with TypedArrays and structured cloning.",
                        "order": 4,
                        "content": {
                          "explanation": "Performance patterns optimize JS code, using TypedArrays for efficient binary data (e.g., `new Uint8Array([1, 2, 3])`) and structured cloning for deep copies (`structuredClone(obj)`). TypedArrays provide faster operations for large data sets, like processing images. Structured cloning copies objects without reference issues, useful in workers. Advanced learners should use TypedArrays for data-intensive tasks and structuredClone for safe copying. Be cautious of TypedArray immutability or cloning large objects, which impact memory. These optimizations enhance high-performance web apps.",
                          "examples": [
                            "// TypedArray\nconst arr = new Uint8Array(1024);\narr[0] = 255;\nconsole.log(arr.length); // 1024",
                            "// Structured clone\nconst obj = { a: 1, b: [2, 3] };\nconst clone = structuredClone(obj);\nclone.b[0] = 4;\nconsole.log(obj.b[0]); // 2"
                          ],
                          "realWorldApplication": "Used in web apps for image processing (TypedArrays) or worker communication (structuredClone).",
                          "expertInsights": "Use TypedArrays for binary data; structuredClone for deep copies; profile optimizations.",
                          "commonMistakes": [
                            "Using regular arrays for large binary data",
                            "Mutating cloned objects unintentionally",
                            "Not checking structuredClone support"
                          ],
                          "exercises": [
                            {
                              "title": "Use TypedArrays",
                              "prompt": "Create a TypedArray to store and manipulate binary data for an image buffer simulation.",
                              "difficulty": "medium",
                              "hints": ["Use Uint8Array", "Set and get values"],
                              "solution": "const buffer = new Uint8Array(4);\nbuffer.set([255, 0, 0, 255], 0);\nconsole.log(buffer[0]); // 255\n// Simulate RGBA pixel data"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What are TypedArrays for?",
                              "options": [
                                "Strings",
                                "Binary data",
                                "Objects",
                                "Functions"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does structuredClone do?",
                              "options": [
                                "Shallow copy",
                                "Deep copy",
                                "Reference copy",
                                "Delete object"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What optimizes large data?",
                              "options": [
                                "Arrays",
                                "TypedArrays",
                                "Objects",
                                "Strings"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "MDN TypedArrays",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray",
                              "type": "article"
                            },
                            {
                              "title": "MDN structuredClone",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/API/structuredClone",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439338",
                        "title": "Advanced Patterns: Proxies, Metaprogramming, Code Generation",
                        "slug": "advanced-patterns-proxies-metaprogramming",
                        "description": "Learn advanced patterns like proxies, metaprogramming, and code generation.",
                        "order": 5,
                        "content": {
                          "explanation": "Proxies wrap objects for custom behavior (e.g., validation on set). Metaprogramming modifies code at runtime, using Proxies or Reflect. Code generation creates code dynamically (e.g., `new Function('x', 'return x + 1')`). For example, a Proxy validates object properties. Advanced learners should use Proxies for reactive systems and code generation for DSLs. Be cautious of performance overhead or security risks in code generation. These patterns enable sophisticated web apps.",
                          "examples": [
                            "// Proxy validation\nconst handler = {\n  set: (obj, prop, value) => {\n    if (typeof value !== 'string') throw new TypeError('String only');\n    obj[prop] = value;\n    return true;\n  }\n};\nconst proxy = new Proxy({}, handler);\nproxy.name = 'Alice';"
                          ],
                          "realWorldApplication": "Used in libraries like Vue for reactivity (Proxies) or templating engines (code generation).",
                          "expertInsights": "Use Proxies for metaprogramming; avoid code generation for security; Reflect for consistent operations.",
                          "commonMistakes": [
                            "Overusing Proxies, causing slowdowns",
                            "Generating unsafe code from inputs",
                            "Ignoring Reflect for Proxy traps"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Proxy Validation",
                              "prompt": "Create a Proxy that validates number properties.",
                              "difficulty": "medium",
                              "hints": [
                                "Use set trap",
                                "Throw TypeError on invalid"
                              ],
                              "solution": "const handler = {\n  set: (obj, prop, value) => {\n    if (typeof value !== 'number') throw new TypeError('Number only');\n    obj[prop] = value;\n    return true;\n  }\n};\nconst proxy = new Proxy({}, handler);\nproxy.age = 25;"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do Proxies customize?",
                              "options": [
                                "Functions",
                                "Object operations",
                                "Loops",
                                "Promises"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is metaprogramming?",
                              "options": [
                                "Styling code",
                                "Modifying code at runtime",
                                "Testing code",
                                "Deploying code"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks code generation?",
                              "options": [
                                "Performance",
                                "Security",
                                "Readability",
                                "All of these"
                              ],
                              "correctOption": [3]
                            },
                            {
                              "question": "What complements Proxies?",
                              "options": ["Event loop", "Reflect", "GC", "JIT"],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "MDN Proxies",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
                              "type": "article"
                            },
                            {
                              "title": "MDN Reflect",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Reflect",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T21:12:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439340",
    "title": "Advanced TypeScript & Type Systems",
    "slug": "advanced-typescript-type-systems",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439341",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master advanced TypeScript and type systems to architect large, type-safe codebases for client and server applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439342",
            "title": "Advanced TypeScript & Type Systems",
            "slug": "advanced-typescript-type-systems",
            "shortDescription": "An advanced course on architecting type-safe codebases with TypeScript across client and server.",
            "longDescription": "This course explores strict TypeScript configurations, advanced types like mapped and conditional types, generics for scalable components, type-safe API contracts with Zod/io-ts and codegen, and strategies for migrating large codebases to TypeScript with runtime type checks.",
            "tags": [
              "TypeScript",
              "Type Systems",
              "Web Development",
              "Advanced"
            ],
            "thumbnail": "https://example.com/thumbnails/advanced-typescript.jpg",
            "levels": [
              {
                "level": "Advanced",
                "overview": "This advanced level focuses on architecting large, type-safe TypeScript codebases for robust client and server applications.",
                "goals": [
                  "Configure strict TypeScript settings and use project references",
                  "Utilize advanced types like mapped, conditional, and template literals",
                  "Apply generics for scalable, polymorphic components",
                  "Implement type-safe API contracts with Zod/io-ts and codegen",
                  "Migrate large codebases with runtime type checks"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439343",
                    "title": "Advanced TypeScript & Type Systems",
                    "slug": "advanced-typescript-type-systems",
                    "description": "Learn to architect large, type-safe TypeScript codebases for client and server applications.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439344",
                        "title": "Strict Configs, Project References, Composite Builds",
                        "slug": "strict-configs-project-references",
                        "description": "Learn strict TypeScript configurations, project references, and composite builds.",
                        "order": 1,
                        "content": {
                          "explanation": "Strict TypeScript configurations (e.g., `strict: true`, `noImplicitAny`) enforce type safety in large projects. Project references (`tsconfig.json` with `references`) split monorepos into smaller builds, improving compilation speed. Composite builds (`composite: true`) enable incremental compilation across projects. For example, a monorepo with client and server uses separate `tsconfig.json` files referencing shared types. Advanced learners should configure strict settings and project references for scalability. Be cautious of loose configs or unlinked references, which introduce errors. These practices ensure robust, maintainable codebases.",
                          "examples": [
                            "// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"composite\": true\n  },\n  \"references\": [{ \"path\": \"../shared\" }]\n}",
                            "// Shared tsconfig.json\n{\n  \"compilerOptions\": {\n    \"composite\": true,\n    \"declaration\": true\n  }\n}"
                          ],
                          "realWorldApplication": "Used in monorepos for large web apps like e-commerce platforms to manage client/server code.",
                          "expertInsights": "Enable strict mode; use project references for monorepos; leverage composite for fast builds.",
                          "commonMistakes": [
                            "Disabling strict mode",
                            "Not using project references in monorepos",
                            "Ignoring composite build benefits"
                          ],
                          "exercises": [
                            {
                              "title": "Configure Strict TypeScript",
                              "prompt": "Create a tsconfig.json with strict settings and project references for a shared types module.",
                              "difficulty": "medium",
                              "hints": [
                                "Set strict: true",
                                "Reference a shared project"
                              ],
                              "solution": "// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"strict\": true,\n    \"noImplicitAny\": true,\n    \"module\": \"esnext\",\n    \"target\": \"es2020\",\n    \"composite\": true,\n    \"outDir\": \"./dist\"\n  },\n  \"references\": [{ \"path\": \"../shared\" }]\n}\n// shared/tsconfig.json\n{\n  \"compilerOptions\": {\n    \"composite\": true,\n    \"declaration\": true,\n    \"outDir\": \"./dist\"\n  }\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does strict: true enforce?",
                              "options": [
                                "Loose types",
                                "Type safety",
                                "Fast builds",
                                "Module imports"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What splits monorepo builds?",
                              "options": [
                                "Project references",
                                "Strict mode",
                                "Type aliases",
                                "Generics"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What enables incremental builds?",
                              "options": [
                                "Strict mode",
                                "Composite builds",
                                "Type inference",
                                "Modules"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "TypeScript Handbook: Project References",
                              "url": "https://www.typescriptlang.org/docs/handbook/project-references.html",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439345",
                        "title": "Advanced Types: Mapped, Conditional, Infer, Template Literal Types",
                        "slug": "advanced-types",
                        "description": "Explore advanced TypeScript types for complex type systems.",
                        "order": 2,
                        "content": {
                          "explanation": "Advanced TypeScript types include mapped types (e.g., { [K in keyof T]: string }), conditional types (T extends string ? A : B), infer types (T extends infer U ? U : never), and template literal types (type Route = '/user/${string}'). These enable flexible, reusable type definitions. For example, a mapped type converts object properties to readonly. Advanced learners should use these types to model complex data. Be cautious of overcomplicated conditionals or ambiguous infer types, which reduce readability. These types ensure robust type safety in web apps.",
                          "examples": [
                            "// Mapped type\ntype Stringify<T> = { [K in keyof T]: string };\ninterface User { id: number; name: string; }\ntype StringUser = Stringify<User>; // { id: string; name: string }",
                            "// Conditional type\ntype IsString<T> = T extends string ? true : false;\ntype Result = IsString<'test'>; // true"
                          ],
                          "realWorldApplication": "Used in web frameworks to type dynamic APIs or UI components.",
                          "expertInsights": "Use mapped types for transformations; conditionals for logic; template literals for routes.",
                          "commonMistakes": [
                            "Overusing conditional types",
                            "Complex infer types reducing clarity",
                            "Ignoring keyof for mapped types"
                          ],
                          "exercises": [
                            {
                              "title": "Design Shared Types",
                              "prompt": "Create a mapped type to make all properties of an interface optional and string-typed.",
                              "difficulty": "medium",
                              "hints": [
                                "Use keyof and Partial",
                                "Map to string type"
                              ],
                              "solution": "type OptionalString<T> = { [K in keyof T]?: string };\ninterface User { id: number; name: string; }\ntype UserOptionalString = OptionalString<User>; // { id?: string; name?: string }"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do mapped types transform?",
                              "options": [
                                "Functions",
                                "Object properties",
                                "Arrays",
                                "Promises"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What do conditional types evaluate?",
                              "options": [
                                "Values",
                                "Types",
                                "Functions",
                                "Objects"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What are template literal types for?",
                              "options": [
                                "String patterns",
                                "Number types",
                                "Object keys",
                                "Arrays"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What extracts types in conditionals?",
                              "options": [
                                "keyof",
                                "infer",
                                "extends",
                                "typeof"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "TypeScript Advanced Types",
                              "url": "https://www.typescriptlang.org/docs/handbook/2/types-from-types.html",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439346",
                        "title": "Generics at Scale, Polymorphic Components, Conditional Props",
                        "slug": "generics-polymorphic-components",
                        "description": "Learn to use generics for scalable, polymorphic components with conditional props.",
                        "order": 3,
                        "content": {
                          "explanation": "Generics enable reusable, type-safe code (e.g., `function identity<T>(arg: T): T`). At scale, generics create polymorphic components in React (e.g., a generic Table component). Conditional props use type conditions to restrict props based on context (e.g., `type Props<T> = T extends 'button' ? { onClick: () => void } : { href: string }`). For example, a generic List component accepts any data type. Advanced learners should build generic components and conditional props. Be cautious of over-genericizing or complex constraints, which hurt readability. These ensure scalable, type-safe UIs.",
                          "examples": [
                            "// Generic component\ntype ListProps<T> = { items: T[]; render: (item: T) => JSX.Element };\nconst List = <T,>({ items, render }: ListProps<T>) => (\n  <ul>{items.map(render)}</ul>\n);",
                            "// Conditional props\ntype ButtonProps<T> = T extends 'button' ? { onClick: () => void } : { href: string };\nconst Component = <T extends 'button' | 'link'>({ type, ...props }: { type: T } & ButtonProps<T>) => null;"
                          ],
                          "realWorldApplication": "Used in React apps for reusable components like tables or forms with dynamic data.",
                          "expertInsights": "Use generics for reusable components; constrain types for clarity; avoid over-complex conditions.",
                          "commonMistakes": [
                            "Overusing generics",
                            "Complex conditional props",
                            "Not constraining generic types"
                          ],
                          "exercises": [
                            {
                              "title": "Build Generic Component",
                              "prompt": "Create a generic React List component with typed items and a render prop.",
                              "difficulty": "hard",
                              "hints": [
                                "Define generic type for items",
                                "Use render prop for flexibility"
                              ],
                              "solution": "interface ListProps<T> {\n  items: T[];\n  render: (item: T) => JSX.Element;\n}\nfunction List<T>({ items, render }: ListProps<T>) {\n  return <ul>{items.map((item, i) => <li key={i}>{render(item)}</li>)}</ul>;\n}\n// Usage\nconst users = [{ id: 1, name: 'Alice' }];\n<List items={users} render={user => <span>{user.name}</span>} />;"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do generics enable?",
                              "options": [
                                "Styling",
                                "Reusable types",
                                "Async code",
                                "Deployment"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What are polymorphic components?",
                              "options": [
                                "Static components",
                                "Generic components",
                                "Untyped components",
                                "Async components"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What restricts props dynamically?",
                              "options": [
                                "Generics",
                                "Conditional props",
                                "Mapped types",
                                "Infer types"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "TypeScript Generics",
                              "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439347",
                        "title": "Type-Safe API Contracts: Zod/io-ts + Codegen",
                        "slug": "type-safe-api-contracts",
                        "description": "Implement type-safe API contracts with Zod/io-ts and generate OpenAPI/GraphQL types.",
                        "order": 4,
                        "content": {
                          "explanation": "Type-safe API contracts ensure client-server consistency using Zod or io-ts for schema validation. Zod defines schemas (e.g., `z.object({ id: z.number() })`) and infers types. Codegen tools like OpenAPI or GraphQL generate types from specs (e.g., `openapi-typescript`). For example, a Zod schema validates an API response and generates OpenAPI docs. Advanced learners should create schemas and generate types for APIs. Be cautious of unvalidated data or missing codegen, which break type safety. These practices ensure reliable APIs in web apps.",
                          "examples": [
                            "// Zod schema\nimport { z } from 'zod';\nconst UserSchema = z.object({ id: z.number(), name: z.string() });\ntype User = z.infer<typeof UserSchema>;\n// Validate\nconst user = UserSchema.parse({ id: 1, name: 'Alice' });",
                            "// OpenAPI codegen\n// openapi.yaml\ncomponents:\n  schemas:\n    User:\n      type: object\n      properties:\n        id: { type: integer }\n        name: { type: string }"
                          ],
                          "realWorldApplication": "Used in REST or GraphQL APIs to validate data and generate client types.",
                          "expertInsights": "Use Zod for validation; generate types with OpenAPI; automate codegen in CI.",
                          "commonMistakes": [
                            "Not validating API responses",
                            "Skipping codegen for APIs",
                            "Overly complex schemas"
                          ],
                          "exercises": [
                            {
                              "title": "Design Zod Schema and Generate OpenAPI",
                              "prompt": "Create a Zod schema for a user API and generate OpenAPI types.",
                              "difficulty": "hard",
                              "hints": [
                                "Use z.object for schema",
                                "Define OpenAPI spec"
                              ],
                              "solution": "import { z } from 'zod';\nconst UserSchema = z.object({\n  id: z.number(),\n  name: z.string()\n});\ntype User = z.infer<typeof UserSchema>;\n// OpenAPI spec\n/* openapi.yaml\ncomponents:\n  schemas:\n    User:\n      type: object\n      required: [id, name]\n      properties:\n        id: { type: integer }\n        name: { type: string }\n*/\n// Generate types: npx openapi-typescript openapi.yaml --output types.ts"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What validates API data?",
                              "options": [
                                "Zod",
                                "Promises",
                                "Generics",
                                "Proxies"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What does codegen produce?",
                              "options": [
                                "Styles",
                                "Types",
                                "Tests",
                                "Configs"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does Zod infer?",
                              "options": [
                                "Schemas",
                                "Types",
                                "Functions",
                                "Objects"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What standardizes API specs?",
                              "options": ["OpenAPI", "ESLint", "Webpack", "V8"],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "Zod Documentation",
                              "url": "https://zod.dev/",
                              "type": "doc"
                            },
                            {
                              "title": "OpenAPI TypeScript",
                              "url": "https://github.com/drwpow/openapi-typescript",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439348",
                        "title": "Migrating Large Codebases & Runtime Type Checks",
                        "slug": "migrating-codebases-runtime-checks",
                        "description": "Learn strategies for migrating codebases to TypeScript and implementing runtime type checks.",
                        "order": 5,
                        "content": {
                          "explanation": "Migrating large JavaScript codebases to TypeScript involves gradual typing (e.g., `any` to specific types), adding `tsconfig.json`, and using `// @ts-ignore` sparingly. Runtime type checks with Zod or io-ts validate dynamic data (e.g., API responses). For example, incrementally add types to a module, then validate runtime data with Zod. Advanced learners should plan migrations and implement runtime checks. Be cautious of overusing `any` or skipping runtime validation, which reduce safety. These practices ensure smooth transitions and robust apps.",
                          "examples": [
                            "// Gradual typing\nfunction fetchUser(id: number): any { /* Migrate to User type */ }\ninterface User { id: number; name: string; }\n// Runtime check with Zod\nconst { z } = require('zod');\nconst UserSchema = z.object({ id: z.number(), name: z.string() });\nconst user = UserSchema.parse(await fetchUser(1));"
                          ],
                          "realWorldApplication": "Used in legacy web apps to add TypeScript or validate external API data.",
                          "expertInsights": "Migrate incrementally; use Zod for runtime checks; avoid overusing any or ts-ignore.",
                          "commonMistakes": [
                            "Overusing any types",
                            "Skipping runtime validation",
                            "Not testing migrations"
                          ],
                          "exercises": [
                            {
                              "title": "Migrate and Add Runtime Checks",
                              "prompt": "Migrate a JavaScript function to TypeScript and add Zod runtime validation.",
                              "difficulty": "hard",
                              "hints": [
                                "Replace any with specific type",
                                "Use Zod parse"
                              ],
                              "solution": "// Original JS\nfunction getUser(id) { return fetch(`/user/${id}`); }\n// Migrated TS\ninterface User { id: number; name: string; }\nasync function getUser(id: number): Promise<User> {\n  const response = await fetch(`/user/${id}`);\n  return response.json();\n}\n// Runtime check\nimport { z } from 'zod';\nconst UserSchema = z.object({ id: z.number(), name: z.string() });\nconst user = UserSchema.parse(await getUser(1));"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What enables gradual typing?",
                              "options": [
                                "Zod",
                                "any type",
                                "Generics",
                                "Proxies"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What validates runtime data?",
                              "options": [
                                "TypeScript",
                                "Zod",
                                "ESLint",
                                "Webpack"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks migrations?",
                              "options": [
                                "Overusing any",
                                "Strict mode",
                                "Generics",
                                "Modules"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "TypeScript Migration Guide",
                              "url": "https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T21:15:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439350",
    "title": "Scalable Frontend Architectures",
    "slug": "scalable-frontend-architectures",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439351",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master scalable frontend architectures for maintainable, high-performance web applications optimized for team collaboration.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439352",
            "title": "Scalable Frontend Architectures",
            "slug": "scalable-frontend-architectures",
            "shortDescription": "An advanced course on designing scalable, maintainable, and performant frontend architectures.",
            "longDescription": "This course explores microfrontends and module federation, advanced server-side rendering (SSR), incremental static regeneration (ISR), and static site generation (SSG) strategies, performance budgets with resource loading, scalable component libraries and design systems, and accessibility and internationalization for large-scale web applications.",
            "tags": [
              "Frontend",
              "Scalability",
              "Microfrontends",
              "Web Development",
              "Advanced"
            ],
            "thumbnail": "https://example.com/thumbnails/scalable-frontend.jpg",
            "levels": [
              {
                "level": "Advanced",
                "overview": "This advanced level focuses on designing scalable, maintainable, and high-performance frontend architectures for team collaboration.",
                "goals": [
                  "Implement microfrontends and module federation for modular UIs",
                  "Apply advanced SSR, ISR, and SSG strategies with hydration tradeoffs",
                  "Enforce performance budgets and optimize resource loading",
                  "Build scalable component libraries and design systems",
                  "Ensure accessibility and internationalization at scale"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439353",
                    "title": "Scalable Frontend Architectures",
                    "slug": "scalable-frontend-architectures",
                    "description": "Learn to design scalable, maintainable, and performant frontend architectures for large-scale web applications.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439354",
                        "title": "Microfrontends, Module Federation, Composition Patterns",
                        "slug": "microfrontends-module-federation",
                        "description": "Learn to implement microfrontends and module federation for modular UI architectures.",
                        "order": 1,
                        "content": {
                          "explanation": "Microfrontends split monolithic UIs into independent, deployable modules, improving team scalability. Module federation (e.g., Webpack 5) enables sharing code across apps (e.g., `ModuleFederationPlugin` for remote components). Composition patterns combine microfrontends via iframes, server-side includes, or client-side rendering. For example, a dashboard app loads a remote chart module. Advanced learners should implement module federation for a composable UI. Be cautious of cross-app dependencies or bundle size issues, which affect performance. These patterns ensure modular, team-friendly frontends.",
                          "examples": [
                            "// Webpack Module Federation\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'host',\n      remotes: { chart: 'chart@http://remote/chart.js' }\n    })\n  ]\n};",
                            "// Consuming remote module\nimport('chart/Chart').then(Chart => <Chart data={data} />);"
                          ],
                          "realWorldApplication": "Used in large web apps like e-commerce dashboards to split features across teams.",
                          "expertInsights": "Use module federation for shared components; isolate microfrontends; monitor bundle sizes.",
                          "commonMistakes": [
                            "Overloading remote dependencies",
                            "Not isolating microfrontend state",
                            "Ignoring versioning in federation"
                          ],
                          "exercises": [
                            {
                              "title": "Convert Monolith to Microfrontend",
                              "prompt": "Convert a monolithic React UI into a microfrontend demo using module federation.",
                              "difficulty": "hard",
                              "hints": [
                                "Use ModuleFederationPlugin",
                                "Expose and consume a component"
                              ],
                              "solution": "// Host webpack.config.js\nconst { ModuleFederationPlugin } = require('webpack');\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'host',\n      remotes: { chart: 'chart@http://localhost:3001/remoteEntry.js' }\n    })\n  ]\n};\n// Remote webpack.config.js\nmodule.exports = {\n  plugins: [\n    new ModuleFederationPlugin({\n      name: 'chart',\n      exposes: { './Chart': './src/Chart' }\n    })\n  ]\n};\n// Host App.jsx\nimport('chart/Chart').then(({ default: Chart }) => <Chart />);"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do microfrontends enable?",
                              "options": [
                                "Monolithic UI",
                                "Team scalability",
                                "Server-side logic",
                                "Database scaling"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What shares code across apps?",
                              "options": [
                                "Module federation",
                                "SSR",
                                "ISR",
                                "SSG"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What risks microfrontends?",
                              "options": [
                                "Small bundles",
                                "Cross-app dependencies",
                                "Fast builds",
                                "Isolated state"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Module Federation",
                              "url": "https://webpack.js.org/concepts/module-federation/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439355",
                        "title": "Advanced SSR/ISR/SSG Strategies and Hydration Tradeoffs",
                        "slug": "advanced-ssr-isr-ssg",
                        "description": "Explore advanced SSR, ISR, and SSG strategies with hydration tradeoffs in Next.js.",
                        "order": 2,
                        "content": {
                          "explanation": "Server-Side Rendering (SSR) renders pages on each request, Incremental Static Regeneration (ISR) regenerates static pages periodically (e.g., `revalidate: 60` in Next.js), and Static Site Generation (SSG) pre-renders at build time. Hydration adds interactivity, but over-hydration increases bundle size. For example, Next.js `getServerSideProps` enables SSR, while `getStaticProps` supports SSG/ISR. Advanced learners should optimize rendering strategies and minimize hydration. Be cautious of slow SSR or large hydrated bundles, which degrade performance. These strategies balance speed and interactivity in web apps.",
                          "examples": [
                            "// Next.js SSG with ISR\nexport async function getStaticProps() {\n  const data = await fetchData();\n  return { props: { data }, revalidate: 60 };\n}",
                            "// SSR in Next.js\nexport async function getServerSideProps() {\n  const data = await fetchData();\n  return { props: { data } };\n}"
                          ],
                          "realWorldApplication": "Used in content-heavy sites like blogs (SSG/ISR) or dynamic apps like dashboards (SSR).",
                          "expertInsights": "Use ISR for dynamic content; minimize hydration with partial interactivity; cache SSR responses.",
                          "commonMistakes": [
                            "Overusing SSR for static content",
                            "Not leveraging ISR for cacheable pages",
                            "Hydrating unnecessary components"
                          ],
                          "exercises": [
                            {
                              "title": "Implement ISR in Next.js",
                              "prompt": "Create a Next.js page using ISR with a 60-second revalidation period.",
                              "difficulty": "medium",
                              "hints": [
                                "Use getStaticProps",
                                "Set revalidate option"
                              ],
                              "solution": "// pages/index.js\nimport { fetchData } from '../lib/api';\nexport async function getStaticProps() {\n  const data = await fetchData();\n  return {\n    props: { data },\n    revalidate: 60\n  };\n}\nexport default function Home({ data }) {\n  return <div>{data.title}</div>;\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does ISR enable?",
                              "options": [
                                "Dynamic requests",
                                "Periodic regeneration",
                                "Full hydration",
                                "Serverless"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does SSR render?",
                              "options": [
                                "At build time",
                                "On each request",
                                "Periodically",
                                "Client-side only"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What increases bundle size?",
                              "options": ["ISR", "SSG", "Hydration", "Caching"],
                              "correctOption": [2]
                            },
                            {
                              "question": "What is getStaticProps for?",
                              "options": [
                                "SSR",
                                "SSG/ISR",
                                "Client-side",
                                "API routes"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Next.js Data Fetching",
                              "url": "https://nextjs.org/docs/pages/building-your-application/data-fetching",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439356",
                        "title": "Frontend Performance Budgets & Resource Loading",
                        "slug": "frontend-performance-budgets",
                        "description": "Learn to enforce performance budgets and optimize resource loading.",
                        "order": 3,
                        "content": {
                          "explanation": "Performance budgets set limits (e.g., 200ms LCP, 100KB JS) to ensure fast UIs. Resource loading optimizations include critical CSS (inline styles for above-the-fold content), font strategies (e.g., `font-display: swap`), and lazy-loading images. For example, `<style>` tags inline critical CSS, while `woff2` fonts reduce load time. Advanced learners should set budgets with Lighthouse and optimize resources. Be cautious of large JS bundles or blocking fonts, which violate budgets. These practices ensure performant web apps.",
                          "examples": [
                            "// Critical CSS\n<style>\n  .hero { background: blue; }\n</style>",
                            "// Font optimization\n<link href='font.woff2' rel='stylesheet' media='print' onload='this.media=\"all\"'>"
                          ],
                          "realWorldApplication": "Used in e-commerce to ensure fast product pages or media sites for quick loads.",
                          "expertInsights": "Use Lighthouse for budgets; inline critical CSS; use font-display: swap; lazy-load images.",
                          "commonMistakes": [
                            "Ignoring performance budgets",
                            "Not inlining critical CSS",
                            "Using blocking font loads"
                          ],
                          "exercises": [
                            {
                              "title": "Optimize Resource Loading",
                              "prompt": "Optimize an HTML page with critical CSS and font loading for performance.",
                              "difficulty": "medium",
                              "hints": [
                                "Inline critical CSS",
                                "Use font-display: swap"
                              ],
                              "solution": "<!DOCTYPE html>\n<html>\n<head>\n  <style>.hero { background: blue; color: white; }</style>\n  <link href='https://fonts.googleapis.com/css2?family=Roboto&display=swap' rel='stylesheet'>\n</head>\n<body>\n  <div class='hero'>Welcome</div>\n  <img src='image.jpg' loading='lazy'>\n</body>\n</html>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do performance budgets limit?",
                              "options": [
                                "Features",
                                "Load times",
                                "Styles",
                                "Tests"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What optimizes above-the-fold content?",
                              "options": [
                                "Lazy-loading",
                                "Critical CSS",
                                "Fonts",
                                "Images"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does font-display: swap do?",
                              "options": [
                                "Blocks rendering",
                                "Swaps fonts",
                                "Lazy-loads",
                                "Inlines CSS"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Web Vitals",
                              "url": "https://web.dev/vitals/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439357",
                        "title": "Component Libraries & Design Systems at Scale",
                        "slug": "component-libraries-design-systems",
                        "description": "Learn to build scalable component libraries and design systems with tokens and theming.",
                        "order": 4,
                        "content": {
                          "explanation": "Component libraries (e.g., Material-UI) provide reusable UI components, while design systems define tokens (e.g., `--color-primary: #007bff`) and theming (e.g., CSS custom properties or ThemeProvider). For example, a button component uses tokens for consistency. Scalable systems use monorepos and tools like Storybook. Advanced learners should build a component library with themed tokens. Be cautious of inconsistent tokens or unversioned components, which break scalability. These practices ensure consistent, maintainable UIs.",
                          "examples": [
                            "// Component with tokens\nconst Button = ({ children }) => (\n  <button style={{ background: 'var(--color-primary)' }}>{children}</button>\n);",
                            "// CSS tokens\n:root { --color-primary: #007bff; --font-size: 16px; }"
                          ],
                          "realWorldApplication": "Used in enterprise apps for consistent UI across teams, like in banking platforms.",
                          "expertInsights": "Use tokens for theming; version components; integrate with Storybook for docs.",
                          "commonMistakes": [
                            "Hardcoding styles",
                            "Not versioning components",
                            "Ignoring Storybook for previews"
                          ],
                          "exercises": [
                            {
                              "title": "Build Themed Component",
                              "prompt": "Create a themed button component using CSS custom properties.",
                              "difficulty": "medium",
                              "hints": [
                                "Define tokens in :root",
                                "Apply to button"
                              ],
                              "solution": ":root {\n  --color-primary: #007bff;\n}\nconst Button = ({ children }) => (\n  <button style={{ backgroundColor: 'var(--color-primary)', color: 'white' }}>{children}</button>\n);\n// Usage\n<Button>Click me</Button>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do design systems define?",
                              "options": ["APIs", "Tokens", "Tests", "Routes"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What ensures theme consistency?",
                              "options": [
                                "Hardcoded styles",
                                "CSS variables",
                                "Images",
                                "Fonts"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What documents components?",
                              "options": [
                                "Webpack",
                                "Storybook",
                                "ESLint",
                                "Vercel"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks unversioned components?",
                              "options": [
                                "Consistency",
                                "Breakages",
                                "Performance",
                                "Security"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Storybook",
                              "url": "https://storybook.js.org/docs",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439358",
                        "title": "Accessibility at Scale and Internationalization (i18n)",
                        "slug": "accessibility-internationalization",
                        "description": "Learn to implement accessibility and internationalization at scale.",
                        "order": 5,
                        "content": {
                          "explanation": "Accessibility (a11y) ensures apps are usable for all (e.g., ARIA attributes, `role='button'`). Internationalization (i18n) supports multiple languages with libraries like `react-i18next`. For example, `<button aria-label='Close'>X</button>` aids screen readers, and i18n translates UI strings. Advanced learners should add a11y attributes and i18n support to components. Be cautious of missing ARIA or untranslated strings, which exclude users. These practices ensure inclusive, global web apps.",
                          "examples": [
                            "// Accessibility\n<button aria-label='Close dialog'>X</button>",
                            "// i18n with react-i18next\nimport { useTranslation } from 'react-i18next';\nconst { t } = useTranslation();\n<p>{t('welcome')}</p>;"
                          ],
                          "realWorldApplication": "Used in global apps like social media for multilingual support and accessibility.",
                          "expertInsights": "Use ARIA for a11y; test with screen readers; automate i18n with translation files.",
                          "commonMistakes": [
                            "Missing ARIA attributes",
                            "Not testing with screen readers",
                            "Hardcoding strings for i18n"
                          ],
                          "exercises": [
                            {
                              "title": "Add Accessibility and i18n",
                              "prompt": "Create a button component with ARIA attributes and i18n support.",
                              "difficulty": "medium",
                              "hints": ["Add aria-label", "Use react-i18next"],
                              "solution": "import { useTranslation } from 'react-i18next';\nconst Button = () => {\n  const { t } = useTranslation();\n  return (\n    <button aria-label={t('close_button')}>\n      {t('close')}\n    </button>\n  );\n};\n// i18n/en.json\n{\n  \"close_button\": \"Close dialog\",\n  \"close\": \"Close\"\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does ARIA improve?",
                              "options": [
                                "Performance",
                                "Accessibility",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does i18n support?",
                              "options": [
                                "Styling",
                                "Languages",
                                "Testing",
                                "Deployment"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What tests accessibility?",
                              "options": [
                                "Webpack",
                                "Screen readers",
                                "ESLint",
                                "Vercel"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "WAI-ARIA",
                              "url": "https://www.w3.org/WAI/standards-guidelines/aria/",
                              "type": "doc"
                            },
                            {
                              "title": "react-i18next",
                              "url": "https://react.i18next.com/",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T21:27:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439360",
    "title": "Advanced State & Data Caching",
    "slug": "advanced-state-data-caching",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439361",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master advanced client and server caching strategies and state synchronization for high-performance web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439362",
            "title": "Advanced State & Data Caching",
            "slug": "advanced-state-data-caching",
            "shortDescription": "An advanced course on robust caching and state synchronization strategies for client and server.",
            "longDescription": "This course explores advanced caching layers with CDN and cache-control, server-state management with React Query for pagination and infinite queries, conflict resolution with CRDTs and offline-first sync, and cache invalidation patterns with metrics to measure effectiveness in web applications.",
            "tags": [
              "Caching",
              "State Management",
              "React Query",
              "Web Development",
              "Advanced"
            ],
            "thumbnail": "https://example.com/thumbnails/advanced-state-caching.jpg",
            "levels": [
              {
                "level": "Advanced",
                "overview": "This advanced level focuses on implementing robust caching and state synchronization strategies for scalable web applications.",
                "goals": [
                  "Master advanced caching with CDN, edge caching, and cache-control",
                  "Implement server-state management with React Query for pagination and refetching",
                  "Apply conflict resolution and offline-first sync with CRDTs",
                  "Design cache invalidation patterns and measure cache effectiveness"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439363",
                    "title": "Advanced State & Data Caching",
                    "slug": "advanced-state-data-caching",
                    "description": "Learn advanced caching and state synchronization strategies for robust web applications.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439364",
                        "title": "Advanced Caching Layers: CDN, Edge Caching, Stale-While-Revalidate",
                        "slug": "advanced-caching-layers",
                        "description": "Learn advanced caching with CDN, edge caching, and stale-while-revalidate strategies.",
                        "order": 1,
                        "content": {
                          "explanation": "Advanced caching layers include Content Delivery Networks (CDNs) for edge caching (e.g., Cloudflare caching assets globally), `Cache-Control` headers for fine-grained control (e.g., `max-age=3600`), and stale-while-revalidate (SWR) for serving stale data while fetching updates. For example, `Cache-Control: max-age=3600, stale-while-revalidate=60` ensures fast responses with fresh data. Advanced learners should configure CDNs and SWR strategies for optimal performance. Be cautious of stale data or misconfigured headers, which affect freshness. These practices enhance web app performance.",
                          "examples": [
                            "// Cache-Control header in Next.js API route\nexport default function handler(req, res) {\n  res.setHeader('Cache-Control', 'max-age=3600, stale-while-revalidate=60');\n  res.json({ data: 'cached' });\n}",
                            "// Cloudflare Worker for edge caching\naddEventListener('fetch', event => {\n  event.respondWith(fetch(event.request, { cf: { cacheTtl: 3600 } }));\n});"
                          ],
                          "realWorldApplication": "Used in e-commerce for caching product pages or media apps for fast asset delivery.",
                          "expertInsights": "Use CDNs for static assets; implement SWR for dynamic data; test cache headers with Lighthouse.",
                          "commonMistakes": [
                            "Misconfiguring Cache-Control",
                            "Serving stale data without revalidation",
                            "Ignoring CDN cache purging"
                          ],
                          "exercises": [
                            {
                              "title": "Implement SWR Caching",
                              "prompt": "Create a Next.js API route with SWR caching using Cache-Control headers.",
                              "difficulty": "medium",
                              "hints": [
                                "Use max-age and stale-while-revalidate",
                                "Set headers in API route"
                              ],
                              "solution": "// pages/api/data.js\nexport default function handler(req, res) {\n  res.setHeader('Cache-Control', 'max-age=3600, stale-while-revalidate=60');\n  res.json({ data: 'Cached data', timestamp: Date.now() });\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does stale-while-revalidate do?",
                              "options": [
                                "Blocks cache",
                                "Serves stale data",
                                "Invalidates cache",
                                "Encrypts data"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What caches assets globally?",
                              "options": [
                                "Server",
                                "CDN",
                                "Browser",
                                "Database"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What controls cache duration?",
                              "options": [
                                "Cache-Control",
                                "Content-Type",
                                "Authorization",
                                "ETag"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "HTTP Cache-Control",
                              "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control",
                              "type": "article"
                            },
                            {
                              "title": "Cloudflare Caching",
                              "url": "https://developers.cloudflare.com/cache/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439365",
                        "title": "Server-State Clients: React Query Advanced",
                        "slug": "server-state-react-query",
                        "description": "Master advanced React Query features like pagination, infinite queries, and background refetching.",
                        "order": 2,
                        "content": {
                          "explanation": "React Query manages server-state with features like pagination (`useQuery` with page params), infinite queries (`useInfiniteQuery` for scroll-based loading), and background refetching (e.g., `refetchOnWindowFocus`). For example, `useInfiniteQuery` fetches paginated posts, appending new data on scroll. Advanced learners should implement pagination and optimistic updates with React Query. Be cautious of over-fetching or stale data, which impact performance. These features ensure efficient state management in web apps.",
                          "examples": [
                            "// Infinite query with React Query\nimport { useInfiniteQuery } from '@tanstack/react-query';\nconst { data, fetchNextPage } = useInfiniteQuery({\n  queryKey: ['posts'],\n  queryFn: ({ pageParam = 1 }) => fetchPosts(pageParam),\n  getNextPageParam: (lastPage) => lastPage.nextPage\n});",
                            "// Optimistic update\nimport { useMutation } from '@tanstack/react-query';\nconst mutation = useMutation({ mutationFn: updatePost, onMutate: async () => {...} });"
                          ],
                          "realWorldApplication": "Used in social media apps for infinite post feeds or dashboards for real-time data.",
                          "expertInsights": "Use infinite queries for scrollable lists; implement optimistic updates; cache queries efficiently.",
                          "commonMistakes": [
                            "Over-fetching in infinite queries",
                            "Not handling optimistic update rollbacks",
                            "Ignoring refetch tuning"
                          ],
                          "exercises": [
                            {
                              "title": "Implement React Query with Optimistic Updates",
                              "prompt": "Create a React Query hook with optimistic updates for a post creation endpoint.",
                              "difficulty": "hard",
                              "hints": [
                                "Use useMutation",
                                "Update cache optimistically"
                              ],
                              "solution": "import { useMutation, useQueryClient } from '@tanstack/react-query';\nfunction useCreatePost() {\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: (post) => fetch('/api/posts', { method: 'POST', body: JSON.stringify(post) }),\n    onMutate: async (newPost) => {\n      await queryClient.cancelQueries(['posts']);\n      const previousPosts = queryClient.getQueryData(['posts']);\n      queryClient.setQueryData(['posts'], (old) => [...old, newPost]);\n      return { previousPosts };\n    },\n    onError: (err, newPost, context) => {\n      queryClient.setQueryData(['posts'], context.previousPosts);\n    }\n  });\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does useInfiniteQuery handle?",
                              "options": [
                                "Static pages",
                                "Infinite scrolling",
                                "Single fetch",
                                "Styling"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What enables optimistic updates?",
                              "options": [
                                "useQuery",
                                "useMutation",
                                "useEffect",
                                "useState"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does refetchOnWindowFocus do?",
                              "options": [
                                "Caches data",
                                "Refetches on focus",
                                "Invalidates cache",
                                "Loads styles"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks over-fetching?",
                              "options": [
                                "Infinite queries",
                                "Static queries",
                                "Caching",
                                "Styles"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 100,
                          "resources": [
                            {
                              "title": "React Query Documentation",
                              "url": "https://tanstack.com/query/v4/docs",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439366",
                        "title": "Conflict Resolution, CRDTs, and Offline-First Sync",
                        "slug": "conflict-resolution-crdts-offline",
                        "description": "Learn conflict resolution and offline-first sync with CRDTs.",
                        "order": 3,
                        "content": {
                          "explanation": "Conflict resolution in offline-first apps handles data conflicts during sync. Conflict-free Replicated Data Types (CRDTs) like counters or mergeable JSON structures (e.g., Yjs) resolve conflicts automatically. Offline-first sync uses localStorage or IndexedDB to store data offline, syncing when online. For example, a CRDT-based todo list merges changes without conflicts. Advanced learners should implement offline sync with CRDTs. Be cautious of complex merges or unsynced data, which cause inconsistencies. These practices ensure robust offline web apps.",
                          "examples": [
                            "// Offline sync with localStorage\nfunction syncTodos(todos) {\n  if (navigator.onLine) {\n    localStorage.setItem('todos', JSON.stringify(todos));\n    fetch('/api/todos', { method: 'POST', body: JSON.stringify(todos) });\n  } else {\n    localStorage.setItem('todos', JSON.stringify(todos));\n  }\n}",
                            "// Yjs CRDT example\nimport * as Y from 'yjs';\nconst doc = new Y.Doc();\nconst todos = doc.getArray('todos');\ntodos.push(['Buy milk']);"
                          ],
                          "realWorldApplication": "Used in collaborative apps like Notion or offline-first task managers.",
                          "expertInsights": "Use CRDTs for automatic merges; store offline data in IndexedDB; test sync edge cases.",
                          "commonMistakes": [
                            "Not handling sync conflicts",
                            "Using localStorage for large data",
                            "Ignoring CRDT merge logic"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Offline Sync",
                              "prompt": "Create an offline-first todo list with localStorage sync.",
                              "difficulty": "medium",
                              "hints": [
                                "Use localStorage for offline",
                                "Sync when online"
                              ],
                              "solution": "function TodoList() {\n  const [todos, setTodos] = useState(JSON.parse(localStorage.getItem('todos') || '[]'));\n  useEffect(() => {\n    localStorage.setItem('todos', JSON.stringify(todos));\n    if (navigator.onLine) {\n      fetch('/api/todos', { method: 'POST', body: JSON.stringify(todos) });\n    }\n  }, [todos]);\n  const addTodo = (todo) => setTodos([...todos, todo]);\n  return <div>{todos.map(t => <div>{t}</div>)}</div>;\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do CRDTs resolve?",
                              "options": [
                                "Styles",
                                "Conflicts",
                                "Caching",
                                "Deployment"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What stores offline data?",
                              "options": ["CDN", "IndexedDB", "Redis", "S3"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks offline sync?",
                              "options": [
                                "Fast loads",
                                "Data conflicts",
                                "Caching",
                                "Styling"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "Yjs CRDT",
                              "url": "https://docs.yjs.dev/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439367",
                        "title": "Cache Invalidation Patterns and Metrics",
                        "slug": "cache-invalidation-patterns",
                        "description": "Learn cache invalidation patterns and metrics to measure effectiveness.",
                        "order": 4,
                        "content": {
                          "explanation": "Cache invalidation patterns include time-based (e.g., `max-age`), event-based (e.g., invalidate on data update), and versioned URLs (e.g., `/data?v=2`). Metrics like cache hit rate (hits/total requests) or latency measure effectiveness. For example, React Query invalidates queries with `queryClient.invalidateQueries`. Advanced learners should implement invalidation and track metrics. Be cautious of stale data or over-invalidation, which reduce efficiency. These patterns ensure fresh, performant web apps.",
                          "examples": [
                            "// React Query invalidation\nimport { useQueryClient } from '@tanstack/react-query';\nconst queryClient = useQueryClient();\nqueryClient.invalidateQueries(['posts']);",
                            "// Versioned URL\n<img src='/image.jpg?v=2' alt='Updated image'>"
                          ],
                          "realWorldApplication": "Used in dashboards to refresh data or media apps to update cached assets.",
                          "expertInsights": "Use event-based invalidation for dynamic data; track hit rates; version URLs for assets.",
                          "commonMistakes": [
                            "Over-invalidating caches",
                            "Not tracking cache metrics",
                            "Ignoring stale data risks"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Cache Invalidation",
                              "prompt": "Create a React Query hook with cache invalidation for a post update.",
                              "difficulty": "medium",
                              "hints": [
                                "Use useMutation",
                                "Call invalidateQueries"
                              ],
                              "solution": "import { useMutation, useQueryClient } from '@tanstack/react-query';\nfunction useUpdatePost() {\n  const queryClient = useQueryClient();\n  return useMutation({\n    mutationFn: (post) => fetch(`/api/posts/${post.id}`, { method: 'PUT', body: JSON.stringify(post) }),\n    onSuccess: () => queryClient.invalidateQueries(['posts'])\n  });\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What invalidates cache on update?",
                              "options": [
                                "Time-based",
                                "Event-based",
                                "Max-age",
                                "Stale-while-revalidate"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What measures cache effectiveness?",
                              "options": [
                                "Hit rate",
                                "Styles",
                                "Tests",
                                "Routes"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What do versioned URLs prevent?",
                              "options": [
                                "Stale data",
                                "Fast loads",
                                "Caching",
                                "Sync"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What risks over-invalidation?",
                              "options": [
                                "Fast loads",
                                "Reduced efficiency",
                                "Security",
                                "Styling"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "Cache Invalidation Patterns",
                              "url": "https://www.cloudflare.com/learning/cdn/glossary/cache-invalidation/",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T21:30:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439370",
    "title": "API Design at Scale (GraphQL Federation & RPC)",
    "slug": "api-design-at-scale",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439371",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master designing scalable, composable, and observable APIs for large-scale, team-oriented web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439372",
            "title": "API Design at Scale (GraphQL Federation & RPC)",
            "slug": "api-design-at-scale",
            "shortDescription": "An advanced course on designing scalable APIs with GraphQL federation and RPC for multiple teams.",
            "longDescription": "This course covers API design principles for scalability, advanced GraphQL with schema federation and subscriptions, RPC and gRPC for internal services, API gateways with throttling, and contract testing with API governance using OpenAPI and schema registries for robust web applications.",
            "tags": [
              "API Design",
              "GraphQL",
              "RPC",
              "Web Development",
              "Advanced"
            ],
            "thumbnail": "https://example.com/thumbnails/api-design-scale.jpg",
            "levels": [
              {
                "level": "Advanced",
                "overview": "This advanced level focuses on designing composable and observable APIs for scalable, team-oriented web applications.",
                "goals": [
                  "Apply API design principles for scalability and compatibility",
                  "Implement GraphQL schema federation, persisted queries, and subscriptions",
                  "Use RPC and gRPC for internal services and evaluate tradeoffs",
                  "Configure API gateways with throttling and request shaping",
                  "Implement contract testing and API governance with OpenAPI"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439373",
                    "title": "API Design at Scale",
                    "slug": "api-design-at-scale",
                    "description": "Learn to design scalable, composable APIs for large-scale web applications and team collaboration.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439374",
                        "title": "API Design Principles for Scale",
                        "slug": "api-design-principles",
                        "description": "Learn API design principles for scalability, including backward compatibility and pagination.",
                        "order": 1,
                        "content": {
                          "explanation": "API design for scale requires backward compatibility (e.g., avoid breaking changes in schema), versioning (e.g., `/v1/resource`), pagination (e.g., `offset` or cursor-based), and idempotency (e.g., same request yields same result). For example, a REST API uses `?limit=10&offset=20` for pagination. Advanced learners should design APIs with these principles to support large teams. Be cautious of breaking changes or non-idempotent endpoints, which disrupt clients. These principles ensure scalable, reliable APIs.",
                          "examples": [
                            "// Paginated REST API\nGET /v1/users?limit=10&offset=20\n// Response\n{ \"users\": [...], \"next\": \"/v1/users?limit=10&offset=30\" }",
                            "// Idempotent POST\nPOST /v1/orders { \"idempotency-key\": \"abc123\", \"item\": \"book\" }"
                          ],
                          "realWorldApplication": "Used in large-scale APIs like e-commerce platforms for consistent, scalable endpoints.",
                          "expertInsights": "Use cursor-based pagination; enforce idempotency with keys; version APIs explicitly.",
                          "commonMistakes": [
                            "Breaking backward compatibility",
                            "Using offset-based pagination for large datasets",
                            "Ignoring idempotency for POSTs"
                          ],
                          "exercises": [
                            {
                              "title": "Design Paginated API",
                              "prompt": "Design a REST API endpoint with cursor-based pagination and idempotency.",
                              "difficulty": "medium",
                              "hints": [
                                "Use cursor in query params",
                                "Add idempotency-key header"
                              ],
                              "solution": "// Endpoint\nGET /v1/posts?limit=10&cursor=abc123\n// Headers\nIdempotency-Key: xyz789\n// Response\n{\n  \"posts\": [{ id: \"def456\", title: \"Post\" }],\n  \"nextCursor\": \"ghi789\"\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What ensures backward compatibility?",
                              "options": [
                                "Breaking changes",
                                "Versioning",
                                "Pagination",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does idempotency ensure?",
                              "options": [
                                "Unique responses",
                                "Same result",
                                "Fast responses",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is cursor-based pagination?",
                              "options": [
                                "Offset-based",
                                "Token-based",
                                "Limit-based",
                                "Time-based"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "REST API Design",
                              "url": "https://restfulapi.net/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439375",
                        "title": "GraphQL Advanced: Schema Federation, Persisted Queries, Subscriptions",
                        "slug": "graphql-advanced",
                        "description": "Learn advanced GraphQL with schema federation, persisted queries, and subscriptions.",
                        "order": 2,
                        "content": {
                          "explanation": "GraphQL schema federation splits schemas across services (e.g., Apollo Federation with `@key` directives). Persisted queries store query strings server-side for performance (e.g., hash-based). Subscriptions enable real-time updates via WebSockets (e.g., `subscribe { messageAdded }`). For example, a federated schema combines user and post services. Advanced learners should design federated schemas and implement subscriptions. Be cautious of over-fetching or subscription leaks, which impact performance. These features enable scalable, real-time APIs.",
                          "examples": [
                            "// Federated schema\nextend type User @key(fields: \"id\") {\n  id: ID! @external\n  posts: [Post]\n}\ntype Post { id: ID!, title: String }",
                            "// Subscription\nsubscription { messageAdded(channelId: \"1\") { content } }"
                          ],
                          "realWorldApplication": "Used in social media apps for real-time feeds or modular APIs across teams.",
                          "expertInsights": "Use Apollo Federation for modularity; persist queries for performance; secure subscriptions.",
                          "commonMistakes": [
                            "Over-fetching in federated queries",
                            "Not securing subscriptions",
                            "Ignoring persisted query caching"
                          ],
                          "exercises": [
                            {
                              "title": "Design GraphQL Federated Schema",
                              "prompt": "Create a federated GraphQL schema for user and post services.",
                              "difficulty": "hard",
                              "hints": [
                                "Use @key directive",
                                "Split schemas across services"
                              ],
                              "solution": "// User service schema\ntype User @key(fields: \"id\") {\n  id: ID!\n  name: String!\n}\ntype Query {\n  user(id: ID!): User\n}\n// Post service schema\nextend type User @key(fields: \"id\") {\n  id: ID! @external\n  posts: [Post]\n}\ntype Post {\n  id: ID!\n  title: String!\n}\ntype Query {\n  posts: [Post]\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does schema federation do?",
                              "options": [
                                "Caches queries",
                                "Splits schemas",
                                "Encrypts data",
                                "Paginates results"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What are persisted queries?",
                              "options": [
                                "Real-time",
                                "Server-stored",
                                "Client-only",
                                "Encrypted"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What enables real-time updates?",
                              "options": [
                                "Queries",
                                "Mutations",
                                "Subscriptions",
                                "Federation"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "What risks subscriptions?",
                              "options": [
                                "Caching",
                                "Leaks",
                                "Pagination",
                                "Versioning"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 100,
                          "resources": [
                            {
                              "title": "Apollo Federation",
                              "url": "https://www.apollographql.com/docs/federation/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439376",
                        "title": "RPC & gRPC for Internal Services",
                        "slug": "rpc-grpc-internal-services",
                        "description": "Explore RPC and gRPC for internal services and their tradeoffs.",
                        "order": 3,
                        "content": {
                          "explanation": "RPC (Remote Procedure Call) and gRPC (Google RPC) treat API calls like local functions, ideal for internal services (e.g., `service.proto` defines methods). gRPC uses Protocol Buffers for efficient serialization. Pros: fast, type-safe; cons: less flexible than REST/GraphQL. For example, a gRPC service defines `GetUser` with typed inputs. Advanced learners should design gRPC services and compare with REST. Be cautious of complex proto definitions or client incompatibility. These are suited for high-performance internal APIs.",
                          "examples": [
                            "// service.proto\nservice UserService {\n  rpc GetUser (UserRequest) returns (UserResponse);\n}\nmessage UserRequest { int32 id = 1; }\nmessage UserResponse { string name = 1; }",
                            "// gRPC client\nconst { UserServiceClient } = require('user-service');\nconst client = new UserServiceClient('localhost:50051');\nclient.GetUser({ id: 1 }, (err, response) => console.log(response.name));"
                          ],
                          "realWorldApplication": "Used in microservices for fast internal communication, like in payment systems.",
                          "expertInsights": "Use gRPC for performance; define clear proto contracts; compare with REST/GraphQL for flexibility.",
                          "commonMistakes": [
                            "Overcomplicating proto schemas",
                            "Using gRPC for public APIs",
                            "Ignoring client compatibility"
                          ],
                          "exercises": [
                            {
                              "title": "Design gRPC Service",
                              "prompt": "Define a gRPC service for fetching posts with Protocol Buffers.",
                              "difficulty": "medium",
                              "hints": [
                                "Use service and message",
                                "Define request/response types"
                              ],
                              "solution": "syntax = \"proto3\";\nservice PostService {\n  rpc GetPost (PostRequest) returns (PostResponse);\n}\nmessage PostRequest {\n  int32 id = 1;\n}\nmessage PostResponse {\n  string title = 1;\n  string content = 2;\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does gRPC use for serialization?",
                              "options": [
                                "JSON",
                                "Protocol Buffers",
                                "XML",
                                "YAML"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is a gRPC pro?",
                              "options": [
                                "Flexibility",
                                "Type safety",
                                "Slow performance",
                                "Public API"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is a gRPC con?",
                              "options": [
                                "Fast performance",
                                "Less flexibility",
                                "Type safety",
                                "Caching"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "gRPC Documentation",
                              "url": "https://grpc.io/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439377",
                        "title": "API Gateways, Throttling, Request Shaping",
                        "slug": "api-gateways-throttling",
                        "description": "Learn to configure API gateways with throttling and request shaping.",
                        "order": 4,
                        "content": {
                          "explanation": "API gateways (e.g., AWS API Gateway, Kong) centralize routing, authentication, and throttling (e.g., 100 requests/second per client). Request shaping prioritizes or limits traffic (e.g., rate-limiting by IP). For example, an API gateway enforces a rate limit on a GraphQL endpoint. Advanced learners should configure gateways with throttling rules. Be cautious of over-throttling or misconfigured routes, which block legitimate traffic. These practices ensure scalable, secure APIs.",
                          "examples": [
                            "// AWS API Gateway throttling (CloudFormation)\nResources:\n  ApiGateway:\n    Type: AWS::ApiGateway::RestApi\n    Properties:\n      EndpointConfiguration:\n        Types: [REGIONAL]\n      ThrottlingRateLimit: 100",
                            "// Kong rate-limiting\nhttp.post('http://kong:8001/services/my-api/plugins', {\n  name = 'rate-limiting',\n  config = { second = 100 }\n})"
                          ],
                          "realWorldApplication": "Used in public APIs to manage traffic for large-scale apps like streaming services.",
                          "expertInsights": "Use gateways for centralized control; enforce throttling; monitor traffic patterns.",
                          "commonMistakes": [
                            "Over-throttling users",
                            "Not monitoring gateway metrics",
                            "Ignoring request shaping"
                          ],
                          "exercises": [
                            {
                              "title": "Configure API Gateway",
                              "prompt": "Set up an API gateway with rate-limiting for a GraphQL endpoint.",
                              "difficulty": "medium",
                              "hints": [
                                "Use AWS API Gateway",
                                "Set throttling limit"
                              ],
                              "solution": "// CloudFormation template\nResources:\n  GraphQLApi:\n    Type: AWS::ApiGateway::RestApi\n    Properties:\n      Name: GraphQLApi\n      EndpointConfiguration:\n        Types: [REGIONAL]\n      ThrottlingRateLimit: 100\n      ThrottlingBurstLimit: 200"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does an API gateway centralize?",
                              "options": [
                                "Database",
                                "Routing",
                                "Caching",
                                "Styling"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does throttling limit?",
                              "options": [
                                "Request rate",
                                "Response size",
                                "Database queries",
                                "Styles"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What does request shaping do?",
                              "options": [
                                "Encrypts data",
                                "Prioritizes traffic",
                                "Caches responses",
                                "Paginates"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks over-throttling?",
                              "options": [
                                "Fast responses",
                                "Blocking users",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "AWS API Gateway",
                              "url": "https://docs.aws.amazon.com/apigateway/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439378",
                        "title": "Contract Testing and API Governance",
                        "slug": "contract-testing-governance",
                        "description": "Learn contract testing and API governance with OpenAPI and schema registries.",
                        "order": 5,
                        "content": {
                          "explanation": "Contract testing (e.g., Pact) ensures API providers and consumers align on schemas. API governance uses OpenAPI specs or schema registries (e.g., Confluent) to enforce standards. For example, an OpenAPI spec defines `/users` endpoints, and contract tests verify compatibility. Advanced learners should write contract tests and maintain OpenAPI specs. Be cautious of outdated schemas or untested contracts, which cause integration issues. These practices ensure reliable, governed APIs.",
                          "examples": [
                            "// OpenAPI spec\nopenapi: 3.0.0\npaths:\n  /users:\n    get:\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  type: object\n                  properties:\n                    id: { type: integer }\n                    name: { type: string }",
                            "// Pact contract test\nconst { Pact } = require('@pact-foundation/pact');\nconst provider = new Pact({ consumer: 'Client', provider: 'UserService' });\nprovider.addInteraction({\n  state: 'Users exist',\n  uponReceiving: 'GET users',\n  withRequest: { method: 'GET', path: '/users' },\n  willRespondWith: { status: 200, body: [{ id: 1, name: 'Alice' }] }\n});"
                          ],
                          "realWorldApplication": "Used in microservices to ensure API compatibility across teams, like in SaaS platforms.",
                          "expertInsights": "Use OpenAPI for specs; automate contract tests in CI; centralize schemas in registries.",
                          "commonMistakes": [
                            "Not updating OpenAPI specs",
                            "Skipping contract tests",
                            "Ignoring schema registries"
                          ],
                          "exercises": [
                            {
                              "title": "Write Contract Tests",
                              "prompt": "Create an OpenAPI spec and Pact contract test for a user API.",
                              "difficulty": "hard",
                              "hints": [
                                "Define OpenAPI schema",
                                "Use Pact for contract test"
                              ],
                              "solution": "// openapi.yaml\nopenapi: 3.0.0\npaths:\n  /users:\n    get:\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                type: array\n                items:\n                  type: object\n                  properties:\n                    id: { type: integer }\n                    name: { type: string }\n// contract.test.js\nconst { Pact } = require('@pact-foundation/pact');\nconst provider = new Pact({ consumer: 'Client', provider: 'UserService' });\nprovider.addInteraction({\n  state: 'Users exist',\n  uponReceiving: 'GET users',\n  withRequest: { method: 'GET', path: '/users' },\n  willRespondWith: { status: 200, body: [{ id: 1, name: 'Alice' }] }\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do contract tests ensure?",
                              "options": [
                                "Performance",
                                "Schema alignment",
                                "Caching",
                                "Styling"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does OpenAPI define?",
                              "options": [
                                "Styles",
                                "API schemas",
                                "Tests",
                                "Routes"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What centralizes schemas?",
                              "options": [
                                "Schema registries",
                                "API gateways",
                                "CDNs",
                                "Databases"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "OpenAPI Specification",
                              "url": "https://swagger.io/specification/",
                              "type": "doc"
                            },
                            {
                              "title": "Pact Documentation",
                              "url": "https://docs.pact.io/",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T21:40:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439380",
    "title": "Distributed Systems & Architecture Patterns",
    "slug": "distributed-systems-architecture-patterns",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439381",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master designing reliable and scalable distributed systems for large-scale web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439382",
            "title": "Distributed Systems & Architecture Patterns",
            "slug": "distributed-systems-architecture-patterns",
            "shortDescription": "An advanced course on designing reliable, scalable distributed systems.",
            "longDescription": "This course explores CAP theorem and consistency models, event-driven architectures with event-sourcing and CQRS, sagas and eventual consistency, message brokers like Kafka and RabbitMQ, service discovery with resilience patterns, and data sharding for multi-region systems in web applications.",
            "tags": [
              "Distributed Systems",
              "Event-Driven",
              "Scalability",
              "Web Development",
              "Advanced"
            ],
            "thumbnail": "https://example.com/thumbnails/distributed-systems.jpg",
            "levels": [
              {
                "level": "Advanced",
                "overview": "This advanced level focuses on designing reliable and scalable distributed systems for large-scale web applications.",
                "goals": [
                  "Understand CAP theorem, consistency models, and leader election",
                  "Implement event-driven architectures with event-sourcing and CQRS",
                  "Design sagas and compensation patterns for eventual consistency",
                  "Utilize message brokers like Kafka and RabbitMQ for reliable messaging",
                  "Apply service discovery and resilience patterns like circuit breakers",
                  "Design data sharding and multi-region architectures"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439383",
                    "title": "Distributed Systems & Architecture Patterns",
                    "slug": "distributed-systems-architecture-patterns",
                    "description": "Learn to design reliable and scalable distributed systems for web applications.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439384",
                        "title": "CAP, Consistency Models, Partitions, Leader Election",
                        "slug": "cap-consistency-partitions",
                        "description": "Learn CAP theorem, consistency models, partitions, and leader election basics.",
                        "order": 1,
                        "content": {
                          "explanation": "CAP theorem states a distributed system can only guarantee two of consistency, availability, and partition tolerance. Consistency models include strong (e.g., immediate consistency) and eventual (e.g., delayed updates). Partitions split data across nodes, requiring leader election (e.g., Raft algorithm) for coordination. For example, a distributed database like DynamoDB uses eventual consistency. Advanced learners should understand tradeoffs and implement leader election basics. Be cautious of misjudging CAP tradeoffs, which impact reliability. These concepts ensure robust distributed systems.",
                          "examples": [
                            "// DynamoDB eventual consistency\nconst AWS = require('aws-sdk');\nconst dynamo = new AWS.DynamoDB.DocumentClient();\nawait dynamo.get({ TableName: 'Users', Key: { id: '1' }, ConsistentRead: false }).promise();",
                            "// Raft leader election pseudocode\nif (node.isCandidate && votes > majority) { node.becomeLeader(); }"
                          ],
                          "realWorldApplication": "Used in databases like Cassandra or DynamoDB for scalable, reliable data access.",
                          "expertInsights": "Choose consistency based on use case; use Raft for leader election; understand CAP tradeoffs.",
                          "commonMistakes": [
                            "Ignoring partition tolerance",
                            "Assuming strong consistency everywhere",
                            "Misconfiguring leader election"
                          ],
                          "exercises": [
                            {
                              "title": "Model CAP Tradeoffs",
                              "prompt": "Design a system prioritizing availability over consistency with pseudocode for leader election.",
                              "difficulty": "medium",
                              "hints": [
                                "Focus on eventual consistency",
                                "Include leader election logic"
                              ],
                              "solution": "// System prioritizing availability\n// Use eventual consistency (e.g., DynamoDB)\nconst readData = async (key) => {\n  return await dynamo.get({ TableName: 'Data', Key: { id: key }, ConsistentRead: false }).promise();\n};\n// Leader election\nif (node.votes > majority) {\n  node.state = 'leader';\n  node.broadcastHeartbeat();\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does CAP prioritize?",
                              "options": [
                                "Security",
                                "Two of three properties",
                                "Performance",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What uses eventual consistency?",
                              "options": [
                                "SQL databases",
                                "DynamoDB",
                                "Redis",
                                "MySQL"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does leader election do?",
                              "options": [
                                "Coordinates nodes",
                                "Caches data",
                                "Encrypts",
                                "Paginates"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "CAP Theorem",
                              "url": "https://en.wikipedia.org/wiki/CAP_theorem",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439385",
                        "title": "Event-Driven Architectures: Event-Sourcing, CQRS, Idempotence",
                        "slug": "event-driven-architectures",
                        "description": "Learn event-driven architectures with event-sourcing, CQRS, and idempotence patterns.",
                        "order": 2,
                        "content": {
                          "explanation": "Event-driven architectures use events to trigger actions. Event-sourcing stores state as a sequence of events (e.g., `OrderPlaced`, `OrderShipped`). CQRS (Command Query Responsibility Segregation) separates read and write models. Idempotence ensures repeated actions yield the same result. For example, an event-sourced order system replays events to rebuild state. Advanced learners should model event-sourced systems. Be cautious of event replay issues or non-idempotent commands, which cause inconsistencies. These patterns ensure scalable, decoupled systems.",
                          "examples": [
                            "// Event-sourcing\nconst events = [\n  { type: 'OrderPlaced', data: { id: 1, item: 'book' } },\n  { type: 'OrderShipped', data: { id: 1, date: '2025-09-15' } }\n];\nconst state = events.reduce((state, event) => ({ ...state, ...event.data }), {});",
                            "// Idempotent command\nconst placeOrder = async (order, idempotencyKey) => {\n  if (await db.exists(idempotencyKey)) return;\n  await db.save(order, idempotencyKey);\n};"
                          ],
                          "realWorldApplication": "Used in e-commerce for order tracking or banking for transaction logs.",
                          "expertInsights": "Use event-sourcing for auditability; implement CQRS for scalability; ensure idempotence.",
                          "commonMistakes": [
                            "Not ensuring idempotence",
                            "Complex event replay logic",
                            "Ignoring CQRS read/write separation"
                          ],
                          "exercises": [
                            {
                              "title": "Model Event-Sourced Order Flow",
                              "prompt": "Design an event-sourced order system with events for placing and shipping.",
                              "difficulty": "hard",
                              "hints": [
                                "Store events in array",
                                "Rebuild state with reduce"
                              ],
                              "solution": "const events = [];\nfunction placeOrder(id, item) {\n  events.push({ type: 'OrderPlaced', data: { id, item, timestamp: Date.now() } });\n}\nfunction shipOrder(id, date) {\n  events.push({ type: 'OrderShipped', data: { id, date, timestamp: Date.now() } });\n}\nfunction getOrderState(id) {\n  return events\n    .filter(e => e.data.id === id)\n    .reduce((state, e) => ({ ...state, ...e.data }), {});\n}\nplaceOrder(1, 'book');\nshipOrder(1, '2025-09-15');\nconsole.log(getOrderState(1)); // { id: 1, item: 'book', date: '2025-09-15' }"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does event-sourcing store?",
                              "options": [
                                "State",
                                "Events",
                                "Queries",
                                "Commands"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does CQRS separate?",
                              "options": [
                                "Read/write models",
                                "Events/queries",
                                "State/cache",
                                "Nodes/partitions"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What ensures same result on repeat?",
                              "options": [
                                "Pagination",
                                "Idempotence",
                                "Caching",
                                "Sharding"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks event-sourcing?",
                              "options": [
                                "Fast queries",
                                "Replay issues",
                                "Security",
                                "Styling"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Event Sourcing",
                              "url": "https://martinfowler.com/eaaDev/EventSourcing.html",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439386",
                        "title": "Sagas, Compensation Patterns, Eventual Consistency",
                        "slug": "sagas-compensation-consistency",
                        "description": "Learn sagas, compensation patterns, and eventual consistency design.",
                        "order": 3,
                        "content": {
                          "explanation": "Sagas orchestrate distributed transactions with steps (e.g., `ReserveInventory`, `ProcessPayment`). Compensation patterns undo steps on failure (e.g., `CancelReservation`). Eventual consistency ensures data aligns over time, not instantly. For example, a saga for order processing retries failed steps or compensates. Advanced learners should design sagas with compensation. Be cautious of unhandled failures or inconsistent states, which break reliability. These patterns ensure robust distributed workflows.",
                          "examples": [
                            "// Saga pseudocode\nconst orderSaga = async (order) => {\n  try {\n    await reserveInventory(order);\n    await processPayment(order);\n  } catch (error) {\n    await cancelReservation(order); // Compensation\n  }\n};",
                            "// Eventual consistency\nconst updateStock = async (item, qty) => {\n  await db.update({ item, qty }); // Eventually consistent across nodes\n};"
                          ],
                          "realWorldApplication": "Used in e-commerce for order processing or travel systems for booking flows.",
                          "expertInsights": "Use sagas for workflows; implement compensation; embrace eventual consistency for scale.",
                          "commonMistakes": [
                            "Not implementing compensation",
                            "Assuming immediate consistency",
                            "Ignoring saga failure handling"
                          ],
                          "exercises": [
                            {
                              "title": "Design Saga for Order",
                              "prompt": "Create a saga for an order process with compensation for failures.",
                              "difficulty": "hard",
                              "hints": [
                                "Define steps like reserve and pay",
                                "Add compensation logic"
                              ],
                              "solution": "async function orderSaga(order) {\n  try {\n    await reserveInventory(order.id, order.item);\n    await processPayment(order.id, order.amount);\n    return { status: 'success' };\n  } catch (error) {\n    await cancelReservation(order.id);\n    return { status: 'failed', error };\n  }\n}\nasync function reserveInventory(id, item) { /* Reserve logic */ }\nasync function processPayment(id, amount) { /* Payment logic */ }\nasync function cancelReservation(id) { /* Undo reservation */ }"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do sagas orchestrate?",
                              "options": [
                                "Caching",
                                "Distributed transactions",
                                "Styles",
                                "Queries"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What do compensation patterns do?",
                              "options": [
                                "Undo failures",
                                "Cache data",
                                "Paginate",
                                "Encrypt"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What does eventual consistency ensure?",
                              "options": [
                                "Immediate updates",
                                "Delayed alignment",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Sagas Pattern",
                              "url": "https://microservices.io/patterns/data/saga.html",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439387",
                        "title": "Message Brokers and Patterns (Kafka, RabbitMQ)",
                        "slug": "message-brokers-patterns",
                        "description": "Learn message brokers like Kafka and RabbitMQ with partitioning and retention strategies.",
                        "order": 4,
                        "content": {
                          "explanation": "Message brokers like Kafka and RabbitMQ enable asynchronous communication. Kafka uses topics with partitions for scalability, retaining messages (e.g., 7-day retention). RabbitMQ uses queues for task distribution. Patterns include publish-subscribe and work queues. For example, Kafka partitions order events across nodes. Advanced learners should configure brokers and partitioning. Be cautious of message loss or misconfigured retention, which disrupt workflows. These ensure reliable messaging in distributed systems.",
                          "examples": [
                            "// Kafka producer\nconst { Kafka } = require('kafkajs');\nconst kafka = new Kafka({ clientId: 'app', brokers: ['localhost:9092'] });\nconst producer = kafka.producer();\nawait producer.send({ topic: 'orders', messages: [{ value: JSON.stringify({ id: 1 }) }] });",
                            "// RabbitMQ work queue\nconst amqp = require('amqplib');\nconst conn = await amqp.connect('amqp://localhost');\nconst ch = await conn.createChannel();\nawait ch.sendToQueue('tasks', Buffer.from('Work'));"
                          ],
                          "realWorldApplication": "Used in microservices for event streaming in analytics or task queues in workflows.",
                          "expertInsights": "Use Kafka for high-throughput; RabbitMQ for queues; set retention policies; partition wisely.",
                          "commonMistakes": [
                            "Not setting retention policies",
                            "Ignoring partition scaling",
                            "Losing messages without retries"
                          ],
                          "exercises": [
                            {
                              "title": "Configure Kafka Topic",
                              "prompt": "Set up a Kafka topic with partitioning for order events.",
                              "difficulty": "medium",
                              "hints": ["Use kafkajs", "Define partitions"],
                              "solution": "const { Kafka } = require('kafkajs');\nconst kafka = new Kafka({ clientId: 'app', brokers: ['localhost:9092'] });\nconst admin = kafka.admin();\nawait admin.createTopics({\n  topics: [{ topic: 'orders', numPartitions: 3 }]\n});\nconst producer = kafka.producer();\nawait producer.send({\n  topic: 'orders',\n  messages: [{ value: JSON.stringify({ id: 1, item: 'book' }) }]\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does Kafka use for scalability?",
                              "options": [
                                "Queues",
                                "Partitions",
                                "Caches",
                                "Nodes"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does RabbitMQ use?",
                              "options": [
                                "Topics",
                                "Queues",
                                "Shards",
                                "Events"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks message loss?",
                              "options": [
                                "Retries",
                                "No retries",
                                "Caching",
                                "Encryption"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What defines message retention?",
                              "options": [
                                "Partitioning",
                                "Retention policy",
                                "Queue size",
                                "Broker"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Kafka Documentation",
                              "url": "https://kafka.apache.org/documentation/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439388",
                        "title": "Service Discovery & Resilience",
                        "slug": "service-discovery-resilience",
                        "description": "Learn service discovery and resilience patterns like circuit breakers and retries.",
                        "order": 5,
                        "content": {
                          "explanation": "Service discovery (e.g., Consul, Eureka) locates services dynamically. Resilience patterns include circuit breakers (e.g., stop requests after failures), bulkheads (isolate failures), and retries with exponential backoff. For example, a circuit breaker halts calls to a failing service. Advanced learners should implement discovery and resilience. Be cautious of retry storms or unisolated failures, which degrade systems. These ensure reliable distributed services.",
                          "examples": [
                            "// Retry with backoff\nconst retry = async (fn, retries = 3, delay = 1000) => {\n  for (let i = 0; i < retries; i++) {\n    try { return await fn(); } catch (err) {\n      if (i === retries - 1) throw err;\n      await new Promise(res => setTimeout(res, delay * Math.pow(2, i)));\n    }\n  }\n};",
                            "// Circuit breaker pseudocode\nif (failures > threshold) { circuit.open(); } else { circuit.close(); }"
                          ],
                          "realWorldApplication": "Used in microservices for reliable service communication, like in payment systems.",
                          "expertInsights": "Use Consul for discovery; implement circuit breakers; tune retries with backoff.",
                          "commonMistakes": [
                            "Not implementing backoff in retries",
                            "Ignoring circuit breaker states",
                            "Not isolating failures with bulkheads"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Retry/Backoff Strategy",
                              "prompt": "Create a retry function with exponential backoff for an unreliable API.",
                              "difficulty": "medium",
                              "hints": [
                                "Use async retries",
                                "Implement exponential delay"
                              ],
                              "solution": "async function retry(fn, retries = 3, delay = 1000) {\n  for (let i = 0; i < retries; i++) {\n    try {\n      return await fn();\n    } catch (err) {\n      if (i === retries - 1) throw err;\n      await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));\n    }\n  }\n}\n// Usage\nconst fetchData = () => fetch('/api/data');\nawait retry(fetchData);"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does service discovery locate?",
                              "options": [
                                "Databases",
                                "Services",
                                "Caches",
                                "Styles"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What do circuit breakers prevent?",
                              "options": [
                                "Caching",
                                "Repeated failures",
                                "Encryption",
                                "Pagination"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does exponential backoff do?",
                              "options": [
                                "Increases delay",
                                "Decreases delay",
                                "Caches data",
                                "Shards data"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Consul Service Discovery",
                              "url": "https://www.consul.io/docs/discovery",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439389",
                        "title": "Data Sharding and Multi-Region Design",
                        "slug": "data-sharding-multi-region",
                        "description": "Learn data sharding and multi-region design for distributed systems.",
                        "order": 6,
                        "content": {
                          "explanation": "Data sharding splits data across nodes (e.g., by user ID) for scalability. Multi-region design replicates data across regions (e.g., AWS multi-region DynamoDB) for low latency and redundancy. For example, shard by `userId % numShards` to distribute load. Advanced learners should design sharded, multi-region systems. Be cautious of hotspot shards or replication lag, which affect performance. These ensure scalable, globally available systems.",
                          "examples": [
                            "// Sharding logic\nconst shardData = (userId, numShards) => {\n  const shard = userId % numShards;\n  return db.saveToShard(shard, data);\n};",
                            "// Multi-region DynamoDB\nconst dynamo = new AWS.DynamoDB.DocumentClient({ region: 'us-east-1' });\nawait dynamo.put({ TableName: 'GlobalTable', Item: { id: '1', data: 'value' } }).promise();"
                          ],
                          "realWorldApplication": "Used in global apps like social media for user data or e-commerce for inventory.",
                          "expertInsights": "Shard by consistent keys; use global tables; monitor replication lag.",
                          "commonMistakes": [
                            "Uneven sharding causing hotspots",
                            "Ignoring replication lag",
                            "Not planning for region failover"
                          ],
                          "exercises": [
                            {
                              "title": "Design Sharded System",
                              "prompt": "Create a sharding function for a user database with 4 shards.",
                              "difficulty": "medium",
                              "hints": [
                                "Use modulo for sharding",
                                "Distribute by user ID"
                              ],
                              "solution": "function shardUser(userId, data, numShards = 4) {\n  const shard = userId % numShards;\n  return db.saveToShard(`shard-${shard}`, { userId, ...data });\n}\n// Usage\nshardUser(123, { name: 'Alice' }); // Saves to shard-3"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does sharding do?",
                              "options": [
                                "Encrypts data",
                                "Splits data",
                                "Caches data",
                                "Styles data"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does multi-region design improve?",
                              "options": [
                                "Caching",
                                "Latency/redundancy",
                                "Security",
                                "Testing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks uneven sharding?",
                              "options": [
                                "Hotspots",
                                "Fast queries",
                                "Encryption",
                                "Caching"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What causes replication lag?",
                              "options": [
                                "Fast writes",
                                "Multi-region sync",
                                "Caching",
                                "Sharding"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "DynamoDB Global Tables",
                              "url": "https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/GlobalTables.html",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T21:45:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439390",
    "title": "Advanced Databases & Storage Strategies",
    "slug": "advanced-databases-storage-strategies",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439391",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master choosing and tuning data stores for performance and correctness in large-scale web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439392",
            "title": "Advanced Databases & Storage Strategies",
            "slug": "advanced-databases-storage-strategies",
            "shortDescription": "An advanced course on optimizing and designing databases and storage systems for performance and scalability.",
            "longDescription": "This course explores advanced PostgreSQL optimization with indexing and partitioning, distributed NoSQL patterns for Cassandra, MongoDB, and DynamoDB, search and analytics with Elasticsearch and vector stores, object storage with S3 lifecycle policies, and OLTP vs OLAP pipelines with ETL processes for data warehouses like BigQuery and Redshift.",
            "tags": [
              "Databases",
              "NoSQL",
              "Storage",
              "Web Development",
              "Advanced"
            ],
            "thumbnail": "https://example.com/thumbnails/advanced-databases.jpg",
            "levels": [
              {
                "level": "Advanced",
                "overview": "This advanced level focuses on selecting and optimizing data stores for performance, scalability, and correctness in web applications.",
                "goals": [
                  "Optimize PostgreSQL with indexing, query tuning, and replication",
                  "Apply distributed NoSQL patterns for scalability and anti-entropy",
                  "Implement search and analytics with Elasticsearch or vector stores",
                  "Design object storage strategies with S3 lifecycle and cost optimization",
                  "Understand OLTP vs OLAP and build ETL pipelines for data warehouses"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439393",
                    "title": "Advanced Databases & Storage Strategies",
                    "slug": "advanced-databases-storage-strategies",
                    "description": "Learn to choose and tune data stores for performance and correctness in web applications.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439394",
                        "title": "Deep Postgres: Indexing Strategies, Query Tuning, Partitioning, Logical Replication",
                        "slug": "deep-postgres",
                        "description": "Learn advanced PostgreSQL optimization with indexing, query tuning, partitioning, and replication.",
                        "order": 1,
                        "content": {
                          "explanation": "PostgreSQL optimization includes indexing (e.g., B-tree, GIN for JSONB), query tuning with `EXPLAIN ANALYZE`, table partitioning for large datasets (e.g., range partitioning by date), and logical replication for streaming changes. For example, a GIN index speeds up JSONB queries. Advanced learners should optimize slow queries and configure replication. Be cautious of over-indexing or replication lag, which impact performance. These techniques ensure fast, reliable SQL databases.",
                          "examples": [
                            "-- Create GIN index\nCREATE INDEX idx_data_jsonb ON data USING GIN(data_jsonb);\n-- Query tuning\nEXPLAIN ANALYZE SELECT * FROM data WHERE data_jsonb @> '{\"key\": \"value\"}';",
                            "-- Partition by range\nCREATE TABLE orders (id SERIAL, date DATE, amount DECIMAL) PARTITION BY RANGE (date);\nCREATE TABLE orders_2025 PARTITION OF orders FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');"
                          ],
                          "realWorldApplication": "Used in e-commerce for fast order queries or analytics for large datasets.",
                          "expertInsights": "Use EXPLAIN for query tuning; index strategically; set up logical replication for HA.",
                          "commonMistakes": [
                            "Over-indexing tables",
                            "Ignoring EXPLAIN output",
                            "Not monitoring replication lag"
                          ],
                          "exercises": [
                            {
                              "title": "Optimize Slow Query",
                              "prompt": "Optimize a slow PostgreSQL query with indexing and analyze its plan.",
                              "difficulty": "hard",
                              "hints": [
                                "Use EXPLAIN ANALYZE",
                                "Add appropriate index"
                              ],
                              "solution": "-- Slow query\nSELECT * FROM orders WHERE created_at >= '2025-01-01' AND status = 'pending';\n-- Analyze\nEXPLAIN ANALYZE SELECT * FROM orders WHERE created_at >= '2025-01-01' AND status = 'pending';\n-- Optimize with index\nCREATE INDEX idx_orders_date_status ON orders(created_at, status);\n-- Re-run\nEXPLAIN ANALYZE SELECT * FROM orders WHERE created_at >= '2025-01-01' AND status = 'pending';"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does EXPLAIN ANALYZE show?",
                              "options": [
                                "Query results",
                                "Execution plan",
                                "Table schema",
                                "Indexes"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What speeds up JSONB queries?",
                              "options": [
                                "B-tree",
                                "GIN index",
                                "Hash index",
                                "Primary key"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does partitioning split?",
                              "options": [
                                "Indexes",
                                "Tables",
                                "Queries",
                                "Replicas"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks replication lag?",
                              "options": [
                                "Fast queries",
                                "Data inconsistency",
                                "Indexing",
                                "Caching"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "PostgreSQL Documentation",
                              "url": "https://www.postgresql.org/docs/current/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439395",
                        "title": "Distributed NoSQL Patterns: Hot Keys, Anti-Entropy, TTLs",
                        "slug": "distributed-nosql-patterns",
                        "description": "Learn distributed NoSQL patterns for Cassandra, MongoDB, and DynamoDB.",
                        "order": 2,
                        "content": {
                          "explanation": "Distributed NoSQL databases (Cassandra, MongoDB, DynamoDB) handle scale with patterns like avoiding hot keys (e.g., sharding by balanced keys), anti-entropy (e.g., repair in Cassandra), and TTLs (time-to-live for auto-expiry). For example, DynamoDB uses partition keys to avoid hot spots. Advanced learners should design sharding and anti-entropy strategies. Be cautious of hot keys or unmaintained TTLs, which degrade performance. These patterns ensure scalable NoSQL systems.",
                          "examples": [
                            "// DynamoDB balanced partition key\nconst AWS = require('aws-sdk');\nconst dynamo = new AWS.DynamoDB.DocumentClient();\nawait dynamo.put({ TableName: 'Users', Item: { userId: '123', shard: 'shard1', data: 'value' } }).promise();",
                            "// MongoDB TTL index\ndb.collection.createIndex({ createdAt: 1 }, { expireAfterSeconds: 3600 });"
                          ],
                          "realWorldApplication": "Used in social media for user data or IoT for time-series storage.",
                          "expertInsights": "Shard to avoid hot keys; configure TTLs for cleanup; run anti-entropy repairs.",
                          "commonMistakes": [
                            "Causing hot keys with poor sharding",
                            "Not setting TTLs for temporary data",
                            "Ignoring anti-entropy processes"
                          ],
                          "exercises": [
                            {
                              "title": "Design Sharding/Replica Strategy",
                              "prompt": "Design a DynamoDB sharding and replica strategy for user data.",
                              "difficulty": "hard",
                              "hints": [
                                "Use composite partition key",
                                "Enable global tables"
                              ],
                              "solution": "const dynamo = new AWS.DynamoDB.DocumentClient();\nasync function saveUser(userId, data) {\n  const shard = userId % 4; // Balanced sharding\n  await dynamo.put({\n    TableName: 'Users',\n    Item: { userId, shardKey: `shard${shard}`, ...data }\n  }).promise();\n}\n// Enable global tables for replication\n// AWS Console: Enable DynamoDB Global Tables for multi-region"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do hot keys cause?",
                              "options": [
                                "Fast queries",
                                "Performance bottlenecks",
                                "Caching",
                                "Replication"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does anti-entropy fix?",
                              "options": [
                                "Indexing",
                                "Data inconsistencies",
                                "TTLs",
                                "Sharding"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What do TTLs do?",
                              "options": [
                                "Encrypt data",
                                "Auto-expire data",
                                "Shard data",
                                "Cache data"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "DynamoDB Best Practices",
                              "url": "https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/best-practices.html",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439396",
                        "title": "Search & Analytics: Elasticsearch/Opensearch or Vector Stores",
                        "slug": "search-analytics",
                        "description": "Learn search and analytics with Elasticsearch and vector stores for semantic search.",
                        "order": 3,
                        "content": {
                          "explanation": "Elasticsearch and Opensearch enable full-text search and analytics (e.g., `match` queries), while vector stores (e.g., Pinecone) support semantic search with embeddings. For example, Elasticsearch indexes documents for fast search, and vector stores query by similarity. Advanced learners should configure indexes and vector searches. Be cautious of unoptimized indexes or high-dimensional vectors, which slow queries. These tools power search and analytics in web apps.",
                          "examples": [
                            "// Elasticsearch query\nconst { Client } = require('@elastic/elasticsearch');\nconst client = new Client({ node: 'http://localhost:9200' });\nawait client.search({ index: 'products', query: { match: { name: 'book' } } });",
                            "// Vector search pseudocode\nconst vector = [0.1, 0.2, ...]; // Embedding\nconst results = await pinecone.query({ vector, topK: 5 });"
                          ],
                          "realWorldApplication": "Used in e-commerce for product search or AI apps for semantic search.",
                          "expertInsights": "Optimize Elasticsearch mappings; use sparse vectors; shard indexes for scale.",
                          "commonMistakes": [
                            "Not optimizing index mappings",
                            "Using high-dimensional vectors",
                            "Ignoring shard balancing"
                          ],
                          "exercises": [
                            {
                              "title": "Configure Elasticsearch Index",
                              "prompt": "Create an Elasticsearch index for products with a text search field.",
                              "difficulty": "medium",
                              "hints": [
                                "Define text field in mapping",
                                "Use match query"
                              ],
                              "solution": "const { Client } = require('@elastic/elasticsearch');\nconst client = new Client({ node: 'http://localhost:9200' });\nawait client.indices.create({\n  index: 'products',\n  body: {\n    mappings: {\n      properties: {\n        name: { type: 'text' },\n        price: { type: 'float' }\n      }\n    }\n  }\n});\nawait client.index({ index: 'products', body: { name: 'Book', price: 10 } });\nawait client.search({ index: 'products', query: { match: { name: 'Book' } } });"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does Elasticsearch enable?",
                              "options": [
                                "Caching",
                                "Full-text search",
                                "Sharding",
                                "Replication"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What do vector stores support?",
                              "options": [
                                "SQL queries",
                                "Semantic search",
                                "Indexing",
                                "TTLs"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks unoptimized indexes?",
                              "options": [
                                "Fast queries",
                                "Slow performance",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What balances search load?",
                              "options": [
                                "Sharding",
                                "Caching",
                                "Encryption",
                                "Replication"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Elasticsearch Guide",
                              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439397",
                        "title": "Storage Patterns: Object Storage (S3) Lifecycles, Cost/IO",
                        "slug": "object-storage-patterns",
                        "description": "Learn object storage with S3 lifecycle policies and cost/IO optimization.",
                        "order": 4,
                        "content": {
                          "explanation": "Object storage like AWS S3 stores unstructured data with lifecycle policies (e.g., transition to Glacier after 30 days) and optimizes cost/IO (e.g., infrequent access tiers). For example, S3 stores images with a lifecycle rule to archive old files. Advanced learners should design lifecycle policies and optimize access patterns. Be cautious of high IO costs or unarchived data, which increase expenses. These patterns ensure cost-effective storage.",
                          "examples": [
                            "// S3 upload\nconst AWS = require('aws-sdk');\nconst s3 = new AWS.S3();\nawait s3.putObject({ Bucket: 'my-bucket', Key: 'image.jpg', Body: file }).promise();",
                            "// S3 lifecycle policy\n{\n  \"Rules\": [{\n    \"Status\": \"Enabled\",\n    \"Prefix\": \"archive/\",\n    \"Transitions\": [{ \"Days\": 30, \"StorageClass\": \"GLACIER\" }]\n  }]\n}"
                          ],
                          "realWorldApplication": "Used in media apps for storing images or backups for archival.",
                          "expertInsights": "Use lifecycle policies for archiving; choose IA tiers for cost; monitor IO patterns.",
                          "commonMistakes": [
                            "Not setting lifecycle policies",
                            "Using standard tier for all data",
                            "Ignoring IO cost monitoring"
                          ],
                          "exercises": [
                            {
                              "title": "Design S3 Lifecycle Policy",
                              "prompt": "Create an S3 lifecycle policy to archive files after 60 days.",
                              "difficulty": "medium",
                              "hints": [
                                "Use Glacier transition",
                                "Set rule for prefix"
                              ],
                              "solution": "const AWS = require('aws-sdk');\nconst s3 = new AWS.S3();\nawait s3.putBucketLifecycleConfiguration({\n  Bucket: 'my-bucket',\n  LifecycleConfiguration: {\n    Rules: [{\n      Status: 'Enabled',\n      Prefix: 'archive/',\n      Transitions: [{ Days: 60, StorageClass: 'GLACIER' }]\n    }]\n  }\n}).promise();"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does S3 lifecycle do?",
                              "options": [
                                "Encrypts data",
                                "Archives data",
                                "Indexes data",
                                "Caches data"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What reduces S3 costs?",
                              "options": [
                                "Standard tier",
                                "Infrequent access tier",
                                "Caching",
                                "Sharding"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks high IO costs?",
                              "options": [
                                "Lifecycle policies",
                                "Unoptimized access",
                                "Archiving",
                                "Encryption"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "AWS S3 Lifecycle",
                              "url": "https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lifecycle-mgmt.html",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439398",
                        "title": "OLTP vs OLAP Pipelines; ETL Basics and Data Warehouses",
                        "slug": "oltp-olap-etl",
                        "description": "Learn OLTP vs OLAP pipelines and ETL processes for data warehouses.",
                        "order": 5,
                        "content": {
                          "explanation": "OLTP (Online Transaction Processing) handles transactional data (e.g., PostgreSQL for orders), while OLAP (Online Analytical Processing) supports analytics (e.g., BigQuery for reports). ETL (Extract, Transform, Load) pipelines move data to warehouses like Redshift. For example, an ETL job extracts orders, aggregates totals, and loads into BigQuery. Advanced learners should design ETL pipelines. Be cautious of unoptimized transforms or data skew, which slow pipelines. These ensure efficient analytics.",
                          "examples": [
                            "// ETL pipeline pseudocode\nconst extract = async () => await db.query('SELECT * FROM orders');\nconst transform = (data) => data.map(row => ({ ...row, total: row.price * row.quantity }));\nconst load = async (data) => await bigquery.insert('analytics.orders', data);",
                            "// BigQuery query\nSELECT SUM(total) FROM analytics.orders WHERE date >= '2025-01-01';"
                          ],
                          "realWorldApplication": "Used in business intelligence for sales reports or analytics dashboards.",
                          "expertInsights": "Use OLTP for transactions; OLAP for analytics; optimize ETL with batching.",
                          "commonMistakes": [
                            "Using OLTP for analytics",
                            "Not batching ETL jobs",
                            "Ignoring data skew in warehouses"
                          ],
                          "exercises": [
                            {
                              "title": "Design ETL Pipeline",
                              "prompt": "Create an ETL pipeline to extract orders, transform totals, and load into BigQuery.",
                              "difficulty": "hard",
                              "hints": [
                                "Extract with SQL",
                                "Transform with aggregation"
                              ],
                              "solution": "const { BigQuery } = require('@google-cloud/bigquery');\nconst bigquery = new BigQuery();\nasync function etlPipeline() {\n  // Extract\nconst orders = await db.query('SELECT id, price, quantity FROM orders');\n  // Transform\nconst transformed = orders.map(o => ({ id: o.id, total: o.price * o.quantity }));\n  // Load\n  await bigquery.dataset('analytics').table('orders').insert(transformed);\n}\netlPipeline();"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does OLTP handle?",
                              "options": [
                                "Analytics",
                                "Transactions",
                                "Search",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does OLAP support?",
                              "options": [
                                "Transactions",
                                "Analytics",
                                "Indexing",
                                "Sharding"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does ETL do?",
                              "options": [
                                "Encrypts data",
                                "Moves data",
                                "Caches data",
                                "Styles data"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "BigQuery ETL",
                              "url": "https://cloud.google.com/bigquery/docs/loading-data",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T21:47:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439400",
    "title": "Security Engineering & Threat Modeling",
    "slug": "security-engineering-threat-modeling",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439401",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master advanced security engineering and threat modeling to secure web systems end-to-end and integrate security into the SDLC.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439402",
            "title": "Security Engineering & Threat Modeling (Advanced)",
            "slug": "security-engineering-threat-modeling-advanced",
            "shortDescription": "An advanced course on securing systems and embedding security practices into the development lifecycle.",
            "longDescription": "This course covers threat modeling with STRIDE, advanced authentication flows like OAuth2 and OIDC, secure data practices including encryption and key rotation, application security against SSRF and XSS, supply chain security with SCA and reproducible builds, and compliance basics for GDPR and PCI DSS in web applications.",
            "tags": [
              "Security",
              "Threat Modeling",
              "Authentication",
              "Web Development",
              "Advanced"
            ],
            "thumbnail": "https://example.com/thumbnails/security-engineering.jpg",
            "levels": [
              {
                "level": "Advanced",
                "overview": "This advanced level focuses on securing web systems end-to-end and integrating security into the SDLC.",
                "goals": [
                  "Apply threat modeling and secure design patterns using STRIDE",
                  "Implement advanced authentication with OAuth2, OIDC, and token management",
                  "Design secure data practices with encryption and key rotation",
                  "Handle advanced application security scenarios like SSRF and XSS",
                  "Ensure supply chain security with SCA and reproducible builds",
                  "Understand compliance basics for GDPR and PCI DSS in payments"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439403",
                    "title": "Security Engineering & Threat Modeling",
                    "slug": "security-engineering-threat-modeling",
                    "description": "Learn to secure systems end-to-end and embed security into the SDLC for web applications.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439404",
                        "title": "Threat Modeling and Secure Design Patterns (STRIDE)",
                        "slug": "threat-modeling-stride",
                        "description": "Learn threat modeling using STRIDE and apply secure design patterns.",
                        "order": 1,
                        "content": {
                          "explanation": "Threat modeling identifies security risks using STRIDE (Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, Elevation of Privilege). Secure design patterns like least privilege mitigate these. For example, apply STRIDE to a login flow to identify CSRF (Tampering). Advanced learners should run threat models and design mitigations. Be cautious of incomplete modeling or unaddressed threats, which leave vulnerabilities. These practices ensure secure web systems.",
                          "examples": [
                            "// STRIDE example for API\n// Spoofing: Use auth tokens\n// Tampering: Input validation\n// Repudiation: Logging\n// Information Disclosure: Encryption\n// Denial of Service: Rate limiting\n// Elevation: Role checks"
                          ],
                          "realWorldApplication": "Used in web apps to identify risks in auth or data flows before coding.",
                          "expertInsights": "Use STRIDE for modeling; integrate into SDLC; prioritize high-impact threats.",
                          "commonMistakes": [
                            "Skipping threat modeling",
                            "Ignoring low-probability threats",
                            "Not documenting mitigations"
                          ],
                          "exercises": [
                            {
                              "title": "Run Threat Model on Capstone",
                              "prompt": "Apply STRIDE to a capstone design and produce mitigations for each category.",
                              "difficulty": "hard",
                              "hints": [
                                "List STRIDE categories",
                                "Identify risks and mitigations"
                              ],
                              "solution": "// Threat Model for Task Tracker\n// Spoofing: Use JWT auth; Mitigation: Verify tokens\n// Tampering: Validate inputs; Mitigation: Sanitize data\n// Repudiation: Log actions; Mitigation: Audit logs\n// Information Disclosure: Encrypt sensitive data; Mitigation: HTTPS\n// Denial of Service: Rate limit APIs; Mitigation: Throttling\n// Elevation of Privilege: RBAC; Mitigation: Role checks"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does STRIDE stand for?",
                              "options": [
                                "Security Tools",
                                "Threat categories",
                                "Design patterns",
                                "Encryption"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What mitigates Tampering?",
                              "options": [
                                "Logging",
                                "Validation",
                                "Rate limiting",
                                "Tokens"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is least privilege?",
                              "options": [
                                "Max access",
                                "Min access",
                                "No access",
                                "All access"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "OWASP Threat Modeling",
                              "url": "https://owasp.org/www-community/Threat_Modeling",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439405",
                        "title": "Advanced Auth: OAuth2 Flows, OIDC, Token Rotation, Delegation, PKCE",
                        "slug": "advanced-auth",
                        "description": "Learn advanced authentication flows and security mechanisms.",
                        "order": 2,
                        "content": {
                          "explanation": "OAuth2 flows include authorization code (for web apps) and client credentials (for servers). OIDC adds identity on OAuth2 (e.g., ID tokens). Token rotation refreshes access tokens with rotating refresh tokens. Delegation grants limited access (e.g., scopes). PKCE secures code flow. For example, PKCE uses code challenge in OAuth. Advanced learners should implement these in web apps. Be cautious of insecure flows or unrotated tokens, risking breaches. These ensure secure auth.",
                          "examples": [
                            "// PKCE in OAuth2\nconst codeVerifier = 'random-string';\nconst codeChallenge = base64url(sha256(codeVerifier));\n// Authorization request with code_challenge",
                            "// Token rotation\nif (tokenExpired) {\n  const newTokens = await refreshToken(refreshToken);\n  updateTokens(newTokens);\n}"
                          ],
                          "realWorldApplication": "Used in apps for secure SSO or API access delegation.",
                          "expertInsights": "Use PKCE for public clients; rotate tokens for security; limit scopes.",
                          "commonMistakes": [
                            "Skipping PKCE in code flow",
                            "Not rotating refresh tokens",
                            "Over-granting scopes"
                          ],
                          "exercises": [
                            {
                              "title": "Implement OAuth2 with PKCE",
                              "prompt": "Design an OAuth2 authorization code flow with PKCE.",
                              "difficulty": "hard",
                              "hints": [
                                "Generate code verifier/challenge",
                                "Include in auth request"
                              ],
                              "solution": "const crypto = require('crypto');\nconst base64url = (str) => Buffer.from(str).toString('base64url');\nconst codeVerifier = crypto.randomBytes(32).toString('base64url');\nconst codeChallenge = base64url(crypto.createHash('sha256').update(codeVerifier).digest('base64'));\n// Auth URL: /authorize?code_challenge=${codeChallenge}&code_challenge_method=S256"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does OIDC add to OAuth2?",
                              "options": [
                                "Encryption",
                                "Identity",
                                "Caching",
                                "Sharding"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What secures code flow?",
                              "options": [
                                "Token rotation",
                                "PKCE",
                                "Delegation",
                                "Scopes"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does token rotation improve?",
                              "options": [
                                "Performance",
                                "Security",
                                "Caching",
                                "Scalability"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What limits access in OAuth?",
                              "options": ["Scopes", "Tokens", "Flows", "PKCE"],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "OAuth2.0",
                              "url": "https://oauth.net/2/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439406",
                        "title": "Secure Data Practices: Encryption At-Rest/In-Transit, Key Rotation",
                        "slug": "secure-data-practices",
                        "description": "Learn secure data practices with encryption and key management.",
                        "order": 3,
                        "content": {
                          "explanation": "Secure data practices include encryption at-rest (e.g., AES-256 for databases) and in-transit (HTTPS/TLS). Key rotation periodically changes encryption keys. Envelope encryption uses data keys encrypted by master keys. For example, AWS KMS manages key rotation. Advanced learners should implement encryption and rotation. Be cautious of weak encryption or unrotated keys, risking breaches. These practices protect sensitive data in web apps.",
                          "examples": [
                            "// AES encryption (Node.js)\nconst crypto = require('crypto');\nconst cipher = crypto.createCipher('aes-256-cbc', 'key');\nlet encrypted = cipher.update('data', 'utf8', 'hex');\nencrypted += cipher.final('hex');",
                            "// Key rotation (pseudocode)\nif (keyAge > 90) {\n  newKey = generateKey();\n  reencryptData(newKey);\n  updateKey(newKey);\n}"
                          ],
                          "realWorldApplication": "Used in banking apps for secure data storage and transmission.",
                          "expertInsights": "Use AES-256; automate key rotation; use envelope encryption for scalability.",
                          "commonMistakes": [
                            "Using weak encryption",
                            "Not rotating keys",
                            "Storing keys in code"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Encryption",
                              "prompt": "Create a function to encrypt and decrypt data with AES-256.",
                              "difficulty": "medium",
                              "hints": ["Use crypto module", "Generate IV"],
                              "solution": "const crypto = require('crypto');\nconst encrypt = (text, key) => {\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv('aes-256-cbc', key, iv);\n  let encrypted = cipher.update(text, 'utf8', 'hex');\n  encrypted += cipher.final('hex');\n  return { iv: iv.toString('hex'), encrypted };\n};\nconst decrypt = (data, key) => {\n  const decipher = crypto.createDecipheriv('aes-256-cbc', key, Buffer.from(data.iv, 'hex'));\n  let decrypted = decipher.update(data.encrypted, 'hex', 'utf8');\n  decrypted += decipher.final('utf8');\n  return decrypted;\n};"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What encrypts data in-transit?",
                              "options": [
                                "AES",
                                "HTTPS/TLS",
                                "Hashing",
                                "Salting"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is envelope encryption?",
                              "options": [
                                "Single key",
                                "Data key + master key",
                                "No encryption",
                                "Hashing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What reduces key compromise risk?",
                              "options": [
                                "Encryption",
                                "Key rotation",
                                "Hashing",
                                "Caching"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "AWS KMS",
                              "url": "https://docs.aws.amazon.com/kms/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439407",
                        "title": "Application Security: SSRF, Complex XSS Scenarios, CSP Tuning",
                        "slug": "application-security",
                        "description": "Learn to handle advanced application security scenarios.",
                        "order": 4,
                        "content": {
                          "explanation": "Application security addresses vulnerabilities like Server-Side Request Forgery (SSRF), where attackers trick servers into accessing internal resources. Complex XSS involves advanced payloads (e.g., DOM-based). CSP tuning configures headers to block attacks (e.g., `script-src 'self'`). For example, validate URLs to prevent SSRF. Advanced learners should implement protections and tune CSP. Be cautious of loose CSP or unvalidated inputs, which leave vulnerabilities. These ensure secure web apps.",
                          "examples": [
                            "// SSRF protection\nfunction isValidUrl(url) {\n  const allowed = new URL(url);\n  if (allowed.hostname === 'localhost') throw new Error('Invalid');\n  return url;\n}",
                            "// CSP header\napp.use((req, res, next) => {\n  res.header('Content-Security-Policy', \"default-src 'self'; script-src 'self' example.com\");\n  next();\n});"
                          ],
                          "realWorldApplication": "Used in web apps to prevent data leaks via SSRF or script injections.",
                          "expertInsights": "Validate all URLs for SSRF; tune CSP incrementally; test XSS scenarios.",
                          "commonMistakes": [
                            "Not validating URLs",
                            "Loose CSP directives",
                            "Ignoring DOM-based XSS"
                          ],
                          "exercises": [
                            {
                              "title": "Tune CSP Headers",
                              "prompt": "Add and tune CSP headers in an Express app to allow scripts from self and a trusted domain.",
                              "difficulty": "medium",
                              "hints": [
                                "Use res.header for CSP",
                                "Set script-src"
                              ],
                              "solution": "const express = require('express');\nconst app = express();\napp.use((req, res, next) => {\n  res.header('Content-Security-Policy', \"default-src 'self'; script-src 'self' https://trusted.com; img-src 'self' data:\");\n  next();\n});\napp.get('/', (req, res) => res.send('Secure app'));"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does SSRF exploit?",
                              "options": [
                                "Client-side",
                                "Server requests",
                                "Database",
                                "Styles"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What blocks XSS?",
                              "options": [
                                "CSP",
                                "HTTPS",
                                "Caching",
                                "Sharding"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What is DOM-based XSS?",
                              "options": [
                                "Server-side",
                                "Client-side",
                                "Database",
                                "API"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "OWASP SSRF",
                              "url": "https://owasp.org/www-community/attacks/Server_Side_Request_Forgery",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439408",
                        "title": "Supply Chain Security: SCA, Signed Artifacts, Reproducible Builds",
                        "slug": "supply-chain-security",
                        "description": "Learn to secure the supply chain with SCA, signed artifacts, and reproducible builds.",
                        "order": 5,
                        "content": {
                          "explanation": "Supply chain security protects against vulnerable dependencies using Software Composition Analysis (SCA) tools like Snyk. Signed artifacts (e.g., npm packages with signatures) verify authenticity. Reproducible builds ensure identical outputs from source code. For example, Snyk scans `package.json` for CVEs. Advanced learners should integrate SCA in CI and use reproducible builds. Be cautious of unsigned dependencies or ignored SCA alerts, which risk attacks. These practices ensure secure web apps.",
                          "examples": [
                            "// Snyk in CI\nsnyk test # Scans for vulnerabilities",
                            "// Signed artifact (npm)\nnpm publish --tag latest # With signature if configured"
                          ],
                          "realWorldApplication": "Used in web development to secure libraries like React or Express from supply chain attacks.",
                          "expertInsights": "Integrate SCA in CI; use signed packages; enforce reproducible builds with Docker.",
                          "commonMistakes": [
                            "Ignoring SCA alerts",
                            "Using unsigned dependencies",
                            "Not pinning dependencies"
                          ],
                          "exercises": [
                            {
                              "title": "Set Up SCA in CI",
                              "prompt": "Add Snyk SCA to a GitHub Action CI pipeline.",
                              "difficulty": "medium",
                              "hints": ["Use snyk test step", "Install Snyk"],
                              "solution": "# .github/workflows/ci.yml\nname: CI\non: [push]\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: actions/setup-node@v3\n      - run: npm install\n      - name: Snyk Scan\n        uses: snyk/actions/node@master\n        env:\n          SNYK_TOKEN: ${{ secrets.SNYK_TOKEN }}\n        with:\n          args: --all-projects"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does SCA detect?",
                              "options": [
                                "Styles",
                                "Vulnerabilities",
                                "Performance",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What verifies artifact authenticity?",
                              "options": [
                                "SCA",
                                "Signed artifacts",
                                "Reproducible builds",
                                "Encryption"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What ensures identical builds?",
                              "options": [
                                "Signed artifacts",
                                "Reproducible builds",
                                "SCA",
                                "Encryption"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Snyk Documentation",
                              "url": "https://docs.snyk.io/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439409",
                        "title": "Compliance Basics (GDPR, PCI/PCI DSS)",
                        "slug": "compliance-basics",
                        "description": "Learn compliance basics for GDPR and PCI DSS in web applications.",
                        "order": 6,
                        "content": {
                          "explanation": "GDPR requires data protection (e.g., consent for cookies), while PCI DSS secures payment data (e.g., tokenization). For example, store consent logs for GDPR. Advanced learners should design compliant features. Be cautious of non-compliant data handling, risking fines. These ensure legal security in web apps.",
                          "examples": [
                            "// GDPR consent\nlocalStorage.setItem('consent', JSON.stringify({ cookies: true }));",
                            "// PCI tokenization (Stripe)\nconst { token } = await stripe.createToken(cardElement);"
                          ],
                          "realWorldApplication": "Used in e-commerce for payments or EU apps for data privacy.",
                          "expertInsights": "Obtain consent for GDPR; use PCI-compliant providers; audit compliance regularly.",
                          "commonMistakes": [
                            "Not obtaining consent",
                            "Storing raw card data",
                            "Ignoring data deletion requests"
                          ],
                          "exercises": [
                            {
                              "title": "Implement GDPR Consent",
                              "prompt": "Create a consent mechanism for cookies in a web app.",
                              "difficulty": "medium",
                              "hints": [
                                "Use localStorage",
                                "Check consent before tracking"
                              ],
                              "solution": "function getConsent() {\n  return JSON.parse(localStorage.getItem('consent')) || {};\n}\nfunction setConsent(type, value) {\n  const consent = getConsent();\n  consent[type] = value;\n  localStorage.setItem('consent', JSON.stringify(consent));\n}\n// Usage\nsetConsent('cookies', true);\nif (getConsent().cookies) { /* Track */ }"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does GDPR require?",
                              "options": [
                                "Payments",
                                "Data protection",
                                "Caching",
                                "Sharding"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What secures payments?",
                              "options": ["GDPR", "PCI DSS", "STRIDE", "OAuth"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks non-compliance?",
                              "options": [
                                "Fast performance",
                                "Fines",
                                "Caching",
                                "Scalability"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "GDPR Guide",
                              "url": "https://gdpr.eu/",
                              "type": "article"
                            },
                            {
                              "title": "PCI DSS",
                              "url": "https://www.pcisecuritystandards.org/pci_security/",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T21:50:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439410",
    "title": "Observability, Tracing & SLOs (SRE Practices)",
    "slug": "observability-tracing-slos",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439411",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master observability and reliability practices to monitor and maintain scalable web systems using SRE principles.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439412",
            "title": "Observability, Tracing & SLOs (SRE Practices)",
            "slug": "observability-tracing-slos",
            "shortDescription": "An advanced course on observability, distributed tracing, and SLOs for reliable web systems.",
            "longDescription": "This course covers centralized logging with structured logs, metrics and dashboards using Prometheus and Grafana, distributed tracing with OpenTelemetry, alerting and incident response, defining and measuring SLOs/SLIs with error budgets, and chaos engineering for resilience testing in web applications.",
            "tags": [
              "Observability",
              "SRE",
              "Tracing",
              "SLOs",
              "Web Development",
              "Advanced"
            ],
            "thumbnail": "https://example.com/thumbnails/observability-sre.jpg",
            "levels": [
              {
                "level": "Advanced",
                "overview": "This advanced level focuses on implementing observability and reliability practices for scalable web systems using SRE principles.",
                "goals": [
                  "Implement centralized logging with structured logs and retention strategies",
                  "Build metrics and dashboards with Prometheus and Grafana",
                  "Instrument distributed tracing using OpenTelemetry",
                  "Design alerting systems and incident response runbooks",
                  "Define and measure SLOs/SLIs with error budgets",
                  "Apply chaos engineering for resilience testing"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439413",
                    "title": "Observability, Tracing & SLOs",
                    "slug": "observability-tracing-slos",
                    "description": "Learn to make web systems observable and manage reliability with SRE practices.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439414",
                        "title": "Centralized Logging, Structured Logs, Log Sampling, Retention Strategy",
                        "slug": "centralized-logging",
                        "description": "Learn centralized logging with structured logs, sampling, and retention strategies.",
                        "order": 1,
                        "content": {
                          "explanation": "Centralized logging aggregates logs from services (e.g., ELK stack). Structured logs use JSON for parsing (e.g., `{level: 'error', message: 'failed'}`). Log sampling reduces volume (e.g., sample 10% of requests). Retention strategies set expiry (e.g., 30 days in Elasticsearch). For example, Fluentd forwards logs to a central store. Advanced learners should implement structured logging and retention. Be cautious of high log volume or missing fields, which hinder analysis. These ensure observable systems.",
                          "examples": [
                            "// Structured log\nconst log = { level: 'info', message: 'User logged in', userId: '123', timestamp: new Date() };\nconsole.log(JSON.stringify(log));",
                            "// Fluentd config\n<source>\n  @type forward\n  port 24224\n</source>\n<match app.**>\n  @type elasticsearch\n  host localhost\n  port 9200\n  index_name logs\n</match>"
                          ],
                          "realWorldApplication": "Used in microservices to debug issues across services like payment systems.",
                          "expertInsights": "Use JSON logs; sample high-traffic logs; set retention based on compliance.",
                          "commonMistakes": [
                            "Using unstructured logs",
                            "Not sampling high-volume logs",
                            "Ignoring retention policies"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Structured Logging",
                              "prompt": "Create a Node.js service with structured JSON logging.",
                              "difficulty": "medium",
                              "hints": ["Use JSON format", "Include metadata"],
                              "solution": "const log = (level, message, meta = {}) => {\n  const logEntry = { level, message, timestamp: new Date().toISOString(), ...meta };\n  console.log(JSON.stringify(logEntry));\n};\nlog('info', 'User logged in', { userId: '123' });"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do structured logs use?",
                              "options": ["Plain text", "JSON", "XML", "CSV"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What reduces log volume?",
                              "options": [
                                "Sampling",
                                "Retention",
                                "Encryption",
                                "Indexing"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What sets log expiry?",
                              "options": [
                                "Sampling",
                                "Retention policy",
                                "Structured logs",
                                "Tracing"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "ELK Stack",
                              "url": "https://www.elastic.co/elastic-stack",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439415",
                        "title": "Metrics and Dashboards (Prometheus + Grafana): Key Metrics, Cardinality",
                        "slug": "metrics-dashboards",
                        "description": "Learn to build metrics and dashboards with Prometheus and Grafana.",
                        "order": 2,
                        "content": {
                          "explanation": "Prometheus collects time-series metrics (e.g., `http_requests_total`). Grafana visualizes them in dashboards. Key metrics include latency, error rate, and throughput. Cardinality control avoids high-dimensional metrics (e.g., limit unique labels). For example, a Prometheus counter tracks API requests. Advanced learners should configure metrics and dashboards. Be cautious of high cardinality or missing metrics, which obscure issues. These enable system monitoring.",
                          "examples": [
                            "// Prometheus counter\nconst { Counter } = require('prom-client');\nconst requests = new Counter({\n  name: 'http_requests_total',\n  help: 'Total HTTP requests',\n  labelNames: ['path']\n});\nrequests.inc({ path: '/api' });",
                            "// Grafana dashboard JSON\n{\n  \"panels\": [{\n    \"type\": \"graph\",\n    \"datasource\": \"Prometheus\",\n    \"targets\": [{ \"expr\": \"rate(http_requests_total[5m])\" }]\n  }]\n}"
                          ],
                          "realWorldApplication": "Used in web apps to monitor API performance or server health.",
                          "expertInsights": "Track latency and errors; limit label cardinality; use Grafana for visualization.",
                          "commonMistakes": [
                            "High-cardinality labels",
                            "Not monitoring key metrics",
                            "Ignoring dashboard usability"
                          ],
                          "exercises": [
                            {
                              "title": "Create SLO Dashboard",
                              "prompt": "Set up a Prometheus metric and Grafana dashboard for API latency.",
                              "difficulty": "hard",
                              "hints": [
                                "Use Prometheus Histogram",
                                "Configure Grafana panel"
                              ],
                              "solution": "const { Histogram } = require('prom-client');\nconst latency = new Histogram({\n  name: 'http_request_duration_seconds',\n  help: 'API latency',\n  buckets: [0.1, 0.5, 1]\n});\napp.get('/api', (req, res) => {\n  const end = latency.startTimer();\n  res.send('OK');\n  end();\n});\n// Grafana dashboard JSON\n{\n  \"panels\": [{\n    \"type\": \"graph\",\n    \"datasource\": \"Prometheus\",\n    \"targets\": [{ \"expr\": \"histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le))\" }]\n  }]\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does Prometheus collect?",
                              "options": [
                                "Logs",
                                "Metrics",
                                "Traces",
                                "Events"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What visualizes metrics?",
                              "options": [
                                "Prometheus",
                                "Grafana",
                                "OpenTelemetry",
                                "Fluentd"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What causes high cardinality?",
                              "options": [
                                "Few labels",
                                "Unique labels",
                                "Low metrics",
                                "Dashboards"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is a key metric?",
                              "options": [
                                "Styles",
                                "Latency",
                                "Colors",
                                "Logs"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Prometheus Documentation",
                              "url": "https://prometheus.io/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439416",
                        "title": "Distributed Tracing (OpenTelemetry): Spans, Traces, Tail-Based Sampling",
                        "slug": "distributed-tracing",
                        "description": "Learn distributed tracing with OpenTelemetry for spans and traces.",
                        "order": 3,
                        "content": {
                          "explanation": "Distributed tracing tracks requests across services using OpenTelemetry. Spans represent operations (e.g., API call), and traces group spans. Tail-based sampling decides which traces to store (e.g., sample errors). For example, OpenTelemetry instruments an Express app for tracing. Advanced learners should instrument services with tracing. Be cautious of missing spans or oversampling, which obscure issues or overload storage. These enable request tracking in web systems.",
                          "examples": [
                            "// OpenTelemetry in Node.js\nconst { NodeTracerProvider } = require('@opentelemetry/sdk-trace-node');\nconst provider = new NodeTracerProvider();\nconst tracer = provider.getTracer('app');\napp.get('/api', (req, res) => {\n  const span = tracer.startSpan('handleRequest');\n  res.send('OK');\n  span.end();\n});",
                            "// Tail-based sampling\nexporter: { sample: { type: 'tail', errorOnly: true } }"
                          ],
                          "realWorldApplication": "Used in microservices to trace requests across APIs or databases.",
                          "expertInsights": "Instrument all services; use tail-based sampling; export to Jaeger.",
                          "commonMistakes": [
                            "Missing spans in services",
                            "Oversampling traces",
                            "Not correlating traces"
                          ],
                          "exercises": [
                            {
                              "title": "Instrument Service with OpenTelemetry",
                              "prompt": "Instrument an Express API with OpenTelemetry tracing.",
                              "difficulty": "hard",
                              "hints": [
                                "Use NodeTracerProvider",
                                "Add spans for routes"
                              ],
                              "solution": "const { NodeTracerProvider } = require('@opentelemetry/sdk-trace-node');\nconst { SimpleSpanProcessor } = require('@opentelemetry/sdk-trace-base');\nconst { JaegerExporter } = require('@opentelemetry/exporter-jaeger');\nconst provider = new NodeTracerProvider();\nprovider.addSpanProcessor(new SimpleSpanProcessor(new JaegerExporter({ endpoint: 'http://localhost:14268/api/traces' })));\nprovider.register();\nconst tracer = provider.getTracer('app');\nconst express = require('express');\nconst app = express();\napp.get('/api', (req, res) => {\n  const span = tracer.startSpan('handle-api');\n  res.send('OK');\n  span.end();\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does a span represent?",
                              "options": [
                                "Log",
                                "Operation",
                                "Metric",
                                "Event"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What groups spans?",
                              "options": [
                                "Metrics",
                                "Traces",
                                "Logs",
                                "Dashboards"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does tail-based sampling do?",
                              "options": [
                                "Encrypts traces",
                                "Selects traces",
                                "Caches spans",
                                "Indexes logs"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "OpenTelemetry Documentation",
                              "url": "https://opentelemetry.io/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439417",
                        "title": "Alerting and On-Call Design, Incident Response Runbooks",
                        "slug": "alerting-oncall",
                        "description": "Learn alerting, on-call design, and incident response runbooks.",
                        "order": 4,
                        "content": {
                          "explanation": "Alerting triggers notifications for issues (e.g., PagerDuty for high error rates). On-call design schedules responders. Runbooks document steps for incidents (e.g., restart service). For example, Prometheus alerts on `error_rate > 0.05`. Advanced learners should configure alerts and runbooks. Be cautious of alert fatigue or vague runbooks, which delay resolution. These ensure rapid incident response.",
                          "examples": [
                            "// Prometheus alert rule\nALERT HighErrorRate\n  IF rate(http_errors_total[5m]) > 0.05\n  FOR 5m\n  LABELS { severity = \"critical\" }\n  ANNOTATIONS { summary = \"High error rate detected\" }",
                            "// Runbook example\n# Incident: High Error Rate\n1. Check Prometheus dashboard\n2. Restart service: `kubectl rollout restart deployment`"
                          ],
                          "realWorldApplication": "Used in web apps to handle outages or performance issues in production.",
                          "expertInsights": "Set alert thresholds carefully; rotate on-call; keep runbooks actionable.",
                          "commonMistakes": [
                            "Causing alert fatigue",
                            "Vague runbooks",
                            "Not testing alerts"
                          ],
                          "exercises": [
                            {
                              "title": "Configure Prometheus Alert",
                              "prompt": "Create a Prometheus alert rule for high latency.",
                              "difficulty": "medium",
                              "hints": [
                                "Use rate() for metrics",
                                "Set severity label"
                              ],
                              "solution": "groups:\n- name: latency-alerts\n  rules:\n  - alert: HighLatency\n    expr: rate(http_request_duration_seconds[5m]) > 1\n    for: 5m\n    labels:\n      severity: critical\n    annotations:\n      summary: 'High API latency detected'"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What triggers notifications?",
                              "options": [
                                "Logs",
                                "Alerts",
                                "Traces",
                                "Metrics"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What do runbooks document?",
                              "options": [
                                "Styles",
                                "Incident steps",
                                "Metrics",
                                "Traces"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What causes alert fatigue?",
                              "options": [
                                "Few alerts",
                                "Too many alerts",
                                "Clear runbooks",
                                "Sampling"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "PagerDuty Documentation",
                              "url": "https://www.pagerduty.com/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439418",
                        "title": "Defining SLOs/SLIs and Error Budgets",
                        "slug": "slos-slis-error-budgets",
                        "description": "Learn to define and measure SLOs/SLIs and manage error budgets.",
                        "order": 5,
                        "content": {
                          "explanation": "SLOs (Service Level Objectives) set reliability targets (e.g., 99.9% uptime). SLIs (Service Level Indicators) measure them (e.g., uptime percentage). Error budgets allow controlled failures (e.g., 0.1% downtime). For example, an SLO dashboard tracks request success rate. Advanced learners should define SLOs and monitor budgets. Be cautious of unrealistic SLOs or untracked SLIs, which misguide reliability. These ensure measurable reliability.",
                          "examples": [
                            "// SLI: Success rate\nexpr: sum(rate(http_requests_success_total[5m])) / sum(rate(http_requests_total[5m]))",
                            "// Error budget pseudocode\nif (sli < slo) {\n  budgetConsumed += (slo - sli);\n  if (budgetConsumed > budget) { pauseReleases(); }\n}"
                          ],
                          "realWorldApplication": "Used in web services to balance reliability and feature velocity.",
                          "expertInsights": "Set realistic SLOs; measure SLIs with Prometheus; act on budget exhaustion.",
                          "commonMistakes": [
                            "Setting 100% SLOs",
                            "Not measuring SLIs",
                            "Ignoring error budgets"
                          ],
                          "exercises": [
                            {
                              "title": "Define SLO and SLI",
                              "prompt": "Create an SLO for API availability and an SLI to measure it.",
                              "difficulty": "medium",
                              "hints": [
                                "Use Prometheus for SLI",
                                "Set 99.9% SLO"
                              ],
                              "solution": "# SLO: 99.9% API availability\n# SLI: Success rate\ngroups:\n- name: slo\n  rules:\n  - record: sli:api_availability\n    expr: sum(rate(http_requests_success_total[5m])) / sum(rate(http_requests_total[5m]))\n# SLO Check\n  - alert: SLOBreach\n    expr: sli:api_availability < 0.999\n    for: 5m\n    annotations:\n      summary: 'API availability below 99.9%'"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does an SLO define?",
                              "options": [
                                "Logs",
                                "Reliability target",
                                "Traces",
                                "Metrics"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What measures SLOs?",
                              "options": [
                                "SLIs",
                                "Logs",
                                "Traces",
                                "Dashboards"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What does an error budget allow?",
                              "options": [
                                "Unlimited errors",
                                "Controlled failures",
                                "Caching",
                                "Sampling"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "SRE SLOs",
                              "url": "https://sre.google/sre-book/service-level-objectives/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439419",
                        "title": "Chaos Engineering Basics: Failure Injection and Resilience Testing",
                        "slug": "chaos-engineering",
                        "description": "Learn chaos engineering for failure injection and resilience testing.",
                        "order": 6,
                        "content": {
                          "explanation": "Chaos engineering tests resilience by injecting failures (e.g., Chaos Mesh kills pods). Resilience testing verifies system recovery (e.g., retry logic). For example, terminate a service to test failover. Advanced learners should run chaos experiments. Be cautious of uncontrolled failures or untested recovery, which risk outages. These ensure robust web systems.",
                          "examples": [
                            "// Chaos Mesh pod failure\napiVersion: chaos-mesh.org/v1alpha1\nkind: PodChaos\nmetadata:\n  name: pod-failure\nspec:\n  selector:\n    namespaces: ['default']\n  action: pod-kill\n  mode: one",
                            "// Retry logic\nconst retry = async (fn) => {\n  try { return await fn(); } catch (e) { await new Promise(res => setTimeout(res, 1000)); return retry(fn); }\n};"
                          ],
                          "realWorldApplication": "Used in cloud apps to test failover in microservices or databases.",
                          "expertInsights": "Start with small failures; test recovery; use tools like Chaos Mesh.",
                          "commonMistakes": [
                            "Injecting uncontrolled failures",
                            "Not testing recovery",
                            "Ignoring chaos results"
                          ],
                          "exercises": [
                            {
                              "title": "Run Chaos Experiment",
                              "prompt": "Create a Chaos Mesh experiment to kill a pod and verify retry logic.",
                              "difficulty": "hard",
                              "hints": [
                                "Use PodChaos kind",
                                "Add retry in code"
                              ],
                              "solution": "# chaos.yaml\napiVersion: chaos-mesh.org/v1alpha1\nkind: PodChaos\nmetadata:\n  name: pod-kill-test\nspec:\n  selector:\n    namespaces: ['default']\n    labelSelectors:\n      app: my-app\n  action: pod-kill\n  mode: one\n# Retry logic\nconst retry = async (fn, max = 3) => {\n  for (let i = 0; i < max; i++) {\n    try { return await fn(); } catch (e) { if (i === max - 1) throw e; await new Promise(res => setTimeout(res, 1000)); }\n  }\n};\n// Usage\nconst fetchData = () => fetch('/api');\nawait retry(fetchData);"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does chaos engineering test?",
                              "options": [
                                "Styles",
                                "Resilience",
                                "Logs",
                                "Metrics"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What verifies recovery?",
                              "options": [
                                "Chaos Mesh",
                                "Resilience testing",
                                "SLIs",
                                "Traces"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks uncontrolled failures?",
                              "options": [
                                "Fast recovery",
                                "Outages",
                                "Caching",
                                "Sampling"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Chaos Mesh Documentation",
                              "url": "https://chaos-mesh.org/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T21:55:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439420",
    "title": "Performance Engineering & Cost Optimization",
    "slug": "performance-engineering-cost-optimization",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439421",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master performance engineering and cost optimization to improve latency, throughput, and cloud spend in web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439422",
            "title": "Performance Engineering & Cost Optimization",
            "slug": "performance-engineering-cost-optimization",
            "shortDescription": "An advanced course on optimizing latency, throughput, and cloud costs in web systems.",
            "longDescription": "This course explores frontend performance metrics like LCP/CLS/FID, backend optimization with connection pooling and async workers, caching and CDN strategies with invalidation at scale, cost engineering with right-sizing and savings plans, and performance budgets with automated CI checks for web applications.",
            "tags": [
              "Performance",
              "Cost Optimization",
              "Caching",
              "Web Development",
              "Advanced"
            ],
            "thumbnail": "https://example.com/thumbnails/performance-cost.jpg",
            "levels": [
              {
                "level": "Advanced",
                "overview": "This advanced level focuses on optimizing performance and cloud costs for scalable web applications.",
                "goals": [
                  "Improve frontend performance with LCP, CLS, and FID optimizations",
                  "Optimize backend with connection pooling, query tuning, and async workers",
                  "Implement caching and CDN strategies with scalable invalidation",
                  "Apply cost engineering using right-sizing and savings plans",
                  "Enforce performance budgets with automated CI checks"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439423",
                    "title": "Performance Engineering & Cost Optimization",
                    "slug": "performance-engineering-cost-optimization",
                    "description": "Learn to optimize latency, throughput, and cloud costs for web applications.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439424",
                        "title": "Frontend Performance: LCP/CLS/FID, Image Optimization, Critical-Path Rendering",
                        "slug": "frontend-performance",
                        "description": "Learn to optimize frontend performance with LCP, CLS, and FID improvements.",
                        "order": 1,
                        "content": {
                          "explanation": "Frontend performance focuses on Largest Contentful Paint (LCP) for main content load, Cumulative Layout Shift (CLS) for visual stability, and First Input Delay (FID) for interactivity. Image optimization (e.g., WebP format) and critical-path rendering (e.g., inline CSS) reduce load times. For example, use `<img loading='lazy'>` for images. Advanced learners should optimize these metrics. Be cautious of large images or render-blocking scripts, which degrade user experience. These practices ensure fast web apps.",
                          "examples": [
                            "<!-- Lazy-load image -->\n<img src='image.webp' loading='lazy' alt='Optimized image'>",
                            "/* Inline critical CSS */\n<style>\n  .hero { font-size: 2rem; }\n</style>"
                          ],
                          "realWorldApplication": "Used in e-commerce for fast product pages or media sites for quick loads.",
                          "expertInsights": "Optimize LCP with server-side rendering; reduce CLS with fixed layouts; use WebP.",
                          "commonMistakes": [
                            "Not lazy-loading images",
                            "Ignoring CLS in dynamic layouts",
                            "Blocking render with scripts"
                          ],
                          "exercises": [
                            {
                              "title": "Optimize LCP with Lazy-Loading",
                              "prompt": "Optimize a webpage by lazy-loading images and inlining critical CSS.",
                              "difficulty": "medium",
                              "hints": [
                                "Use loading='lazy'",
                                "Inline CSS for above-the-fold content"
                              ],
                              "solution": "<!DOCTYPE html>\n<html>\n<head>\n  <style>.hero { font-size: 2rem; color: #333; }</style>\n</head>\n<body>\n  <div class='hero'>Welcome</div>\n  <img src='image.webp' loading='lazy' alt='Product'>\n</body>\n</html>"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does LCP measure?",
                              "options": [
                                "Interactivity",
                                "Main content load",
                                "Layout shift",
                                "Script execution"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What reduces CLS?",
                              "options": [
                                "Lazy-loading",
                                "Fixed layouts",
                                "Large images",
                                "Inline scripts"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does WebP optimize?",
                              "options": ["Scripts", "Images", "CSS", "HTML"],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 100,
                          "resources": [
                            {
                              "title": "Web Vitals",
                              "url": "https://web.dev/vitals/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439425",
                        "title": "Backend Performance: Connection Pooling, Query Tuning, Async Workers, Batching",
                        "slug": "backend-performance",
                        "description": "Learn to optimize backend performance with connection pooling and query tuning.",
                        "order": 2,
                        "content": {
                          "explanation": "Backend performance uses connection pooling (e.g., pgxpool for PostgreSQL) to reuse database connections, query tuning to optimize SQL (e.g., `EXPLAIN`), async workers (e.g., Bull for Node.js) for background tasks, and batching requests to reduce round-trips. For example, batch inserts in SQL improve throughput. Advanced learners should implement these optimizations. Be cautious of connection leaks or unoptimized queries, which slow systems. These ensure scalable backends.",
                          "examples": [
                            "// Connection pooling (Node.js)\nconst { Pool } = require('pg');\nconst pool = new Pool({ max: 20 });\nawait pool.query('SELECT * FROM users');",
                            "// Batching inserts\nINSERT INTO orders (id, item) VALUES (1, 'book'), (2, 'pen');"
                          ],
                          "realWorldApplication": "Used in APIs for fast data retrieval or task processing in web apps.",
                          "expertInsights": "Tune queries with EXPLAIN; limit pool size; batch writes; offload tasks to workers.",
                          "commonMistakes": [
                            "Not pooling connections",
                            "Running unoptimized queries",
                            "Ignoring async workers"
                          ],
                          "exercises": [
                            {
                              "title": "Optimize Query with Pooling",
                              "prompt": "Create a Node.js function with connection pooling and batch insert.",
                              "difficulty": "hard",
                              "hints": [
                                "Use pg.Pool",
                                "Batch multiple inserts"
                              ],
                              "solution": "const { Pool } = require('pg');\nconst pool = new Pool({ max: 20 });\nasync function batchInsert(orders) {\n  const values = orders.map((o, i) => `($${2*i+1}, $${2*i+2})`).join(',');\n  const params = orders.flatMap(o => [o.id, o.item]);\n  await pool.query(`INSERT INTO orders (id, item) VALUES ${values}`, params);\n}\nbatchInsert([{ id: 1, item: 'book' }, { id: 2, item: 'pen' }]);"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does connection pooling reuse?",
                              "options": [
                                "Queries",
                                "Connections",
                                "Workers",
                                "Caches"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What optimizes SQL queries?",
                              "options": [
                                "EXPLAIN",
                                "Pooling",
                                "Batching",
                                "Async"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What reduces round-trips?",
                              "options": [
                                "Pooling",
                                "Batching",
                                "Workers",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What offloads tasks?",
                              "options": [
                                "Async workers",
                                "Pooling",
                                "Queries",
                                "CDNs"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "PostgreSQL EXPLAIN",
                              "url": "https://www.postgresql.org/docs/current/using-explain.html",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439426",
                        "title": "Caching & CDN Strategies Plus Cache Invalidation at Scale",
                        "slug": "caching-cdn-strategies",
                        "description": "Learn caching and CDN strategies with scalable invalidation.",
                        "order": 3,
                        "content": {
                          "explanation": "Caching (e.g., Redis) stores frequent data to reduce database load. CDNs (e.g., Cloudflare) cache assets globally. Cache invalidation at scale uses strategies like versioned URLs or event-based purging (e.g., invalidate on update). For example, Redis caches user data. Advanced learners should implement caching to reduce load. Be cautious of stale caches or over-purging, which impact performance. These ensure low-latency web apps.",
                          "examples": [
                            "// Redis caching\nconst redis = require('redis');\nconst client = redis.createClient();\nasync function getUser(id) {\n  const cached = await client.get(`user:${id}`);\n  if (cached) return JSON.parse(cached);\n  const user = await db.query('SELECT * FROM users WHERE id = $1', [id]);\n  await client.set(`user:${id}`, JSON.stringify(user), 'EX', 3600);\n  return user;\n}",
                            "// CDN invalidation (Cloudflare)\nawait fetch('https://api.cloudflare.com/client/v4/zones/{zone}/purge_cache', {\n  method: 'POST',\n  headers: { 'Authorization': 'Bearer {token}' },\n  body: JSON.stringify({ files: ['/image.jpg'] })\n});"
                          ],
                          "realWorldApplication": "Used in social media for user data caching or CDNs for fast asset delivery.",
                          "expertInsights": "Use Redis for caching; version URLs for CDNs; invalidate caches event-driven.",
                          "commonMistakes": [
                            "Not invalidating caches",
                            "Caching dynamic data",
                            "Over-purging CDNs"
                          ],
                          "exercises": [
                            {
                              "title": "Add Caching to Reduce DB Load",
                              "prompt": "Implement Redis caching for an API to reduce database load and show latency improvement.",
                              "difficulty": "hard",
                              "hints": ["Use Redis client", "Cache with TTL"],
                              "solution": "const redis = require('redis');\nconst client = redis.createClient();\nconst express = require('express');\nconst app = express();\napp.get('/user/:id', async (req, res) => {\n  const { id } = req.params;\n  const cached = await client.get(`user:${id}`);\n  if (cached) {\n    res.json(JSON.parse(cached));\n    return;\n  }\n  const start = Date.now();\n  const user = await db.query('SELECT * FROM users WHERE id = $1', [id]);\n  await client.set(`user:${id}`, JSON.stringify(user), 'EX', 3600);\n  res.json({ ...user, latency: Date.now() - start });\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does caching reduce?",
                              "options": [
                                "Latency",
                                "Security",
                                "Sharding",
                                "Indexing"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What caches assets globally?",
                              "options": ["Redis", "CDN", "Database", "Worker"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks stale data?",
                              "options": [
                                "Invalidation",
                                "No invalidation",
                                "CDN",
                                "Redis"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Cloudflare CDN",
                              "url": "https://developers.cloudflare.com/cache/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439427",
                        "title": "Cost Engineering: Right-Sizing, Reserved/Savings Plans, Spot Instances",
                        "slug": "cost-engineering",
                        "description": "Learn cost engineering with right-sizing and savings plans.",
                        "order": 4,
                        "content": {
                          "explanation": "Cost engineering optimizes cloud spend. Right-sizing matches resources to load (e.g., smaller EC2 instances). Reserved instances and savings plans (e.g., AWS Savings Plans) reduce costs for predictable workloads. Spot instances use spare capacity cheaply. Caching reduces egress/compute costs. For example, use spot instances for batch jobs. Advanced learners should optimize costs. Be cautious of over-provisioning or spot interruptions, which increase costs. These ensure cost-effective web apps.",
                          "examples": [
                            "// Right-sizing EC2 (AWS SDK)\nconst AWS = require('aws-sdk');\nconst ec2 = new AWS.EC2();\nawait ec2.modifyInstanceAttribute({ InstanceId: 'i-123', InstanceType: { Value: 't3.micro' } }).promise();",
                            "// Spot instance request\nawait ec2.requestSpotInstances({ InstanceCount: 1, LaunchSpecification: { InstanceType: 't3.micro' } }).promise();"
                          ],
                          "realWorldApplication": "Used in cloud apps to reduce costs for APIs or batch processing.",
                          "expertInsights": "Right-size with metrics; use savings plans; leverage spot instances for non-critical tasks.",
                          "commonMistakes": [
                            "Over-provisioning instances",
                            "Not using savings plans",
                            "Ignoring spot interruptions"
                          ],
                          "exercises": [
                            {
                              "title": "Optimize Costs with Caching",
                              "prompt": "Use Redis caching to reduce API compute and egress costs.",
                              "difficulty": "medium",
                              "hints": [
                                "Cache API responses",
                                "Reduce database calls"
                              ],
                              "solution": "const redis = require('redis');\nconst client = redis.createClient();\nconst express = require('express');\nconst app = express();\napp.get('/data', async (req, res) => {\n  const cached = await client.get('data');\n  if (cached) {\n    res.json(JSON.parse(cached));\n    return;\n  }\n  const data = await db.query('SELECT * FROM data');\n  await client.set('data', JSON.stringify(data), 'EX', 3600);\n  res.json(data);\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does right-sizing match?",
                              "options": [
                                "Security",
                                "Resources to load",
                                "Caching",
                                "Sharding"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What reduces costs for predictable loads?",
                              "options": [
                                "Spot instances",
                                "Savings plans",
                                "Caching",
                                "Pooling"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks spot instances?",
                              "options": [
                                "High cost",
                                "Interruptions",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 100,
                          "resources": [
                            {
                              "title": "AWS Cost Optimization",
                              "url": "https://aws.amazon.com/architecture/cost-optimization/",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439428",
                        "title": "Performance Budgets, Regression Testing, Automated Perf Checks in CI",
                        "slug": "performance-budgets",
                        "description": "Learn to enforce performance budgets and automate checks in CI.",
                        "order": 5,
                        "content": {
                          "explanation": "Performance budgets set limits (e.g., LCP < 2s). Regression testing checks for performance degradation (e.g., Lighthouse). Automated CI checks (e.g., Web Vitals in GitHub Actions) enforce budgets. For example, fail CI if LCP exceeds 2s. Advanced learners should integrate checks in CI. Be cautious of ignored regressions or loose budgets, which degrade performance. These ensure consistent web app speed.",
                          "examples": [
                            "// Lighthouse CI config\nlighthouserc.js:\nmodule.exports = {\n  ci: {\n    assert: {\n      assertions: { 'largest-contentful-paint': ['error', { maxNumericValue: 2000 }] }\n    }\n  }\n};",
                            "// GitHub Action for perf\nname: Perf Check\non: [push]\njobs:\n  lighthouse:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm install -g @lhci/cli\n      - run: lhci autorun"
                          ],
                          "realWorldApplication": "Used in web apps to maintain fast load times during development.",
                          "expertInsights": "Set strict budgets; automate Lighthouse in CI; monitor regressions.",
                          "commonMistakes": [
                            "Ignoring performance regressions",
                            "Setting loose budgets",
                            "Not automating CI checks"
                          ],
                          "exercises": [
                            {
                              "title": "Set Up Performance CI Check",
                              "prompt": "Add a Lighthouse CI check for LCP in GitHub Actions.",
                              "difficulty": "medium",
                              "hints": ["Use lhci/cli", "Set LCP budget"],
                              "solution": "# .github/workflows/perf.yml\nname: Perf Check\non: [push]\njobs:\n  lighthouse:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: npm install -g @lhci/cli\n      - run: lhci autorun\n# lighthouserc.js\nmodule.exports = {\n  ci: {\n    assert: {\n      assertions: { 'largest-contentful-paint': ['error', { maxNumericValue: 2000 }] }\n    }\n  }\n};"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does a performance budget set?",
                              "options": [
                                "Security",
                                "Metric limits",
                                "Caching",
                                "Sharding"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What checks performance degradation?",
                              "options": [
                                "Regression testing",
                                "Caching",
                                "Pooling",
                                "Workers"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What does Lighthouse CI enforce?",
                              "options": [
                                "Styles",
                                "Performance budgets",
                                "Logs",
                                "Traces"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 100,
                          "resources": [
                            {
                              "title": "Lighthouse CI",
                              "url": "https://github.com/GoogleChrome/lighthouse-ci",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T21:57:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439430",
    "title": "Serverless & Edge Architectures (Advanced Use)",
    "slug": "serverless-edge-architectures",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439431",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master serverless and edge architectures for scalable, low-latency web applications while understanding their limitations.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439432",
            "title": "Serverless & Edge Architectures (Advanced Use)",
            "slug": "serverless-edge-architectures",
            "shortDescription": "An advanced course on leveraging serverless and edge computing for web applications.",
            "longDescription": "This course explores serverless patterns with stateless functions and cold start mitigations, edge computing with CDN workers, data locality and eventual consistency at the edge, observability and cost patterns for serverless, and scenarios where serverless is not suitable, such as long-running or stateful services.",
            "tags": [
              "Serverless",
              "Edge Computing",
              "Web Development",
              "Advanced"
            ],
            "thumbnail": "https://example.com/thumbnails/serverless-edge.jpg",
            "levels": [
              {
                "level": "Advanced",
                "overview": "This advanced level focuses on using serverless and edge architectures effectively while understanding their limits in web applications.",
                "goals": [
                  "Implement serverless patterns with stateless functions and cold start mitigations",
                  "Build edge computing solutions using CDN workers and middleware",
                  "Manage data locality and eventual consistency at the edge",
                  "Apply observability and cost optimization in serverless architectures",
                  "Identify when to avoid serverless for long-running or stateful services"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439433",
                    "title": "Serverless & Edge Architectures",
                    "slug": "serverless-edge-architectures",
                    "description": "Learn to use serverless and edge computing for scalable web applications while understanding their limitations.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439434",
                        "title": "Serverless Patterns: Stateless Functions, Cold Starts, Provisioned Concurrency",
                        "slug": "serverless-patterns",
                        "description": "Learn serverless patterns, managing cold starts, and provisioned concurrency tradeoffs.",
                        "order": 1,
                        "content": {
                          "explanation": "Serverless patterns use stateless functions (e.g., AWS Lambda) for scalability. Cold starts delay initial execution due to initialization. Provisioned concurrency pre-warms functions but increases costs. For example, a Lambda function handles API requests statelessly. Advanced learners should optimize for cold starts. Be cautious of over-provisioning or stateful logic, which breaks serverless. These patterns ensure scalable, event-driven web apps.",
                          "examples": [
                            "// AWS Lambda function (Node.js)\nexports.handler = async (event) => {\n  return { statusCode: 200, body: JSON.stringify({ message: 'Hello' }) };\n};",
                            "// Provisioned concurrency (AWS CLI)\naws lambda put-provisioned-concurrency-config --function-name myFunction --qualifier latest --provisioned-concurrent-executions 10"
                          ],
                          "realWorldApplication": "Used in APIs for event-driven processing, like user authentication flows.",
                          "expertInsights": "Keep functions stateless; use provisioned concurrency sparingly; optimize cold starts with lightweight runtimes.",
                          "commonMistakes": [
                            "Adding stateful logic",
                            "Over-provisioning concurrency",
                            "Ignoring cold start delays"
                          ],
                          "exercises": [
                            {
                              "title": "Create Stateless Lambda Function",
                              "prompt": "Write a stateless AWS Lambda function to handle a GET request.",
                              "difficulty": "medium",
                              "hints": [
                                "Return JSON response",
                                "Avoid stateful variables"
                              ],
                              "solution": "exports.handler = async (event) => {\n  const userId = event.queryStringParameters?.userId || 'guest';\n  return {\n    statusCode: 200,\n    body: JSON.stringify({ message: `Hello, ${userId}` })\n  };\n};"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do serverless functions require?",
                              "options": [
                                "Stateful logic",
                                "Stateless design",
                                "Persistent storage",
                                "Heavy CPU"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What causes cold starts?",
                              "options": [
                                "Function initialization",
                                "Caching",
                                "Concurrency",
                                "Encryption"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What does provisioned concurrency do?",
                              "options": [
                                "Increases cold starts",
                                "Pre-warms functions",
                                "Reduces costs",
                                "Adds state"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "AWS Lambda Best Practices",
                              "url": "https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439435",
                        "title": "Edge Computing: CDN Workers, Middleware at Edge",
                        "slug": "edge-computing",
                        "description": "Learn edge computing with CDN workers and middleware on platforms like Vercel and Cloudflare Workers.",
                        "order": 2,
                        "content": {
                          "explanation": "Edge computing runs code at CDN nodes (e.g., Cloudflare Workers) for low-latency processing. Middleware at the edge (e.g., Vercel Edge Functions) handles tasks like authentication. For example, a Cloudflare Worker prerenders content. Advanced learners should build edge functions. Be cautious of complex logic or limited runtime capabilities at the edge, which impact performance. These enable fast, distributed web apps.",
                          "examples": [
                            "// Cloudflare Worker\naddEventListener('fetch', event => {\n  event.respondWith(handleRequest(event.request));\n});\nasync function handleRequest(request) {\n  return new Response('Hello from edge', { status: 200 });\n}",
                            "// Vercel Edge Middleware\n// middleware.js\nexport function middleware(request) {\n  if (request.headers.get('authorization')) return NextResponse.next();\n  return new Response('Unauthorized', { status: 401 });\n}"
                          ],
                          "realWorldApplication": "Used in web apps for fast content delivery or edge authentication.",
                          "expertInsights": "Use Workers for lightweight tasks; prerender at edge; minimize middleware complexity.",
                          "commonMistakes": [
                            "Running heavy logic at edge",
                            "Not caching responses",
                            "Ignoring runtime limits"
                          ],
                          "exercises": [
                            {
                              "title": "Build Edge Function for Prerendered Content",
                              "prompt": "Create a Cloudflare Worker that serves prerendered content with personalized fragments.",
                              "difficulty": "hard",
                              "hints": [
                                "Use HTML template",
                                "Inject user data"
                              ],
                              "solution": "addEventListener('fetch', event => {\n  event.respondWith(handleRequest(event.request));\n});\nasync function handleRequest(request) {\n  const url = new URL(request.url);\n  const user = url.searchParams.get('user') || 'Guest';\n  const html = `<html><body><h1>Hello, ${user}</h1><div>Prerendered content</div></body></html>`;\n  return new Response(html, {\n    headers: { 'Content-Type': 'text/html' }\n  });\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "Where do edge functions run?",
                              "options": [
                                "Servers",
                                "CDN nodes",
                                "Databases",
                                "Browsers"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does edge middleware handle?",
                              "options": [
                                "Heavy CPU",
                                "Authentication",
                                "Long-running jobs",
                                "State"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks complex edge logic?",
                              "options": [
                                "Low latency",
                                "Performance issues",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does prerendering improve?",
                              "options": [
                                "Security",
                                "Load time",
                                "State",
                                "CPU"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 100,
                          "resources": [
                            {
                              "title": "Cloudflare Workers",
                              "url": "https://developers.cloudflare.com/workers/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439436",
                        "title": "Data Locality, Latency, and Eventual Consistency at Edge",
                        "slug": "data-locality-edge",
                        "description": "Learn data locality, latency, and eventual consistency in edge computing.",
                        "order": 3,
                        "content": {
                          "explanation": "Data locality places data near users (e.g., Cloudflare KV at edge). Low latency is achieved by processing at edge nodes. Eventual consistency (e.g., in edge KV stores) delays data sync. For example, cache user preferences at the edge. Advanced learners should manage edge data. Be cautious of consistency issues or stale data, which affect user experience. These ensure fast, distributed web apps.",
                          "examples": [
                            "// Cloudflare KV at edge\naddEventListener('fetch', event => {\n  event.respondWith(handleRequest(event.request));\n});\nasync function handleRequest(request) {\n  const data = await MY_KV.get('user:123');\n  return new Response(data || 'No data', { status: 200 });\n}",
                            "// Eventual consistency\nawait MY_KV.put('user:123', JSON.stringify({ name: 'Alice' }), { expirationTtl: 3600 });"
                          ],
                          "realWorldApplication": "Used in global apps for caching user data or serving localized content.",
                          "expertInsights": "Store minimal data at edge; embrace eventual consistency; use TTLs for cache expiry.",
                          "commonMistakes": [
                            "Expecting strong consistency",
                            "Not setting TTLs",
                            "Storing large data at edge"
                          ],
                          "exercises": [
                            {
                              "title": "Cache User Data at Edge",
                              "prompt": "Create a Cloudflare Worker to cache and serve user data with eventual consistency.",
                              "difficulty": "medium",
                              "hints": ["Use KV store", "Set TTL for expiry"],
                              "solution": "addEventListener('fetch', event => {\n  event.respondWith(handleRequest(event.request));\n});\nasync function handleRequest(request) {\n  const url = new URL(request.url);\n  const userId = url.searchParams.get('userId') || 'guest';\n  let data = await MY_KV.get(`user:${userId}`);\n  if (!data) {\n    data = JSON.stringify({ name: userId, lastSeen: new Date() });\n    await MY_KV.put(`user:${userId}`, data, { expirationTtl: 3600 });\n  }\n  return new Response(data, { headers: { 'Content-Type': 'application/json' } });\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does data locality improve?",
                              "options": [
                                "Security",
                                "Latency",
                                "Consistency",
                                "CPU"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does eventual consistency allow?",
                              "options": [
                                "Immediate sync",
                                "Delayed sync",
                                "Caching",
                                "Encryption"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks stale edge data?",
                              "options": [
                                "Low latency",
                                "User experience",
                                "Security",
                                "Throughput"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "Cloudflare KV",
                              "url": "https://developers.cloudflare.com/workers/runtime-apis/kv/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439437",
                        "title": "Observability/Cost Patterns for Serverless; Debugging Techniques",
                        "slug": "serverless-observability",
                        "description": "Learn observability, cost patterns, and debugging for serverless architectures.",
                        "order": 4,
                        "content": {
                          "explanation": "Serverless observability uses logs (e.g., AWS CloudWatch), metrics (e.g., Lambda execution time), and traces (e.g., AWS X-Ray). Cost patterns optimize invocations (e.g., batch requests). Debugging uses log analysis or step-through tools. For example, X-Ray traces Lambda calls. Advanced learners should implement observability. Be cautious of high log volumes or unmonitored costs, which obscure issues or inflate bills. These ensure manageable serverless systems.",
                          "examples": [
                            "// CloudWatch structured log\nconsole.log(JSON.stringify({ level: 'info', message: 'Function executed', duration: 100 }));",
                            "// X-Ray tracing\nconst AWSXRay = require('aws-xray-sdk');\nAWSXRay.captureHTTPs(require('http'));\nexports.handler = async () => {\n  return { statusCode: 200, body: 'OK' };\n};"
                          ],
                          "realWorldApplication": "Used in serverless APIs to monitor performance and control costs.",
                          "expertInsights": "Use structured logs; enable X-Ray for tracing; monitor invocation costs.",
                          "commonMistakes": [
                            "Not enabling tracing",
                            "Ignoring cost metrics",
                            "Unstructured logging"
                          ],
                          "exercises": [
                            {
                              "title": "Add Observability to Lambda",
                              "prompt": "Add CloudWatch logging and X-Ray tracing to a Lambda function.",
                              "difficulty": "medium",
                              "hints": ["Use JSON logs", "Enable X-Ray SDK"],
                              "solution": "const AWSXRay = require('aws-xray-sdk');\nAWSXRay.captureHTTPs(require('http'));\nexports.handler = async (event) => {\n  console.log(JSON.stringify({ level: 'info', message: 'Function started', event }));\n  const response = { statusCode: 200, body: JSON.stringify({ message: 'OK' }) };\n  console.log(JSON.stringify({ level: 'info', message: 'Function completed', response }));\n  return response;\n};"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What tracks serverless performance?",
                              "options": [
                                "Logs",
                                "Metrics",
                                "Traces",
                                "All of these"
                              ],
                              "correctOption": [3]
                            },
                            {
                              "question": "What optimizes serverless costs?",
                              "options": [
                                "Batching requests",
                                "Heavy CPU",
                                "Stateful logic",
                                "Cold starts"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What does X-Ray provide?",
                              "options": [
                                "Logs",
                                "Traces",
                                "Metrics",
                                "Caching"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "AWS X-Ray",
                              "url": "https://docs.aws.amazon.com/xray/latest/devguide/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439438",
                        "title": "When Not to Use Serverless: Long-Running Jobs, Heavy CPU, Stateful Services",
                        "slug": "serverless-limitations",
                        "description": "Learn when to avoid serverless for certain use cases.",
                        "order": 5,
                        "content": {
                          "explanation": "Serverless is unsuitable for long-running jobs (e.g., Lambda’s 15-minute limit), heavy CPU tasks (e.g., video encoding), or stateful services (e.g., WebSockets). Alternatives include containers or VMs. For example, use ECS for long-running tasks. Advanced learners should evaluate use cases. Be cautious of forcing serverless on incompatible workloads, which causes timeouts or inefficiencies. These ensure appropriate architecture choices.",
                          "examples": [
                            "// ECS for long-running task (AWS SDK)\nconst AWS = require('aws-sdk');\nconst ecs = new AWS.ECS();\nawait ecs.runTask({ cluster: 'my-cluster', taskDefinition: 'long-task' }).promise();",
                            "// Avoid WebSocket in Lambda\n// Use EC2 or ECS for persistent connections"
                          ],
                          "realWorldApplication": "Used in web apps to choose containers for video processing or real-time services.",
                          "expertInsights": "Use ECS for long tasks; avoid serverless for CPU-intensive or stateful apps.",
                          "commonMistakes": [
                            "Using Lambda for long jobs",
                            "Running heavy CPU in serverless",
                            "Forcing stateful logic"
                          ],
                          "exercises": [
                            {
                              "title": "Evaluate Serverless Use Case",
                              "prompt": "Design a solution for a video encoding task, avoiding serverless.",
                              "difficulty": "medium",
                              "hints": [
                                "Use ECS or EC2",
                                "Define task duration"
                              ],
                              "solution": "const AWS = require('aws-sdk');\nconst ecs = new AWS.ECS();\nasync function runVideoEncoding(file) {\n  await ecs.runTask({\n    cluster: 'video-cluster',\n    taskDefinition: 'video-encoder',\n    launchType: 'FARGATE',\n    overrides: { containerOverrides: [{ name: 'encoder', command: ['encode', file] }] }\n  }).promise();\n}\nrunVideoEncoding('video.mp4');"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is a serverless limitation?",
                              "options": [
                                "Fast startup",
                                "Long-running jobs",
                                "Low cost",
                                "Scalability"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What is unsuitable for serverless?",
                              "options": [
                                "API calls",
                                "Video encoding",
                                "Event triggers",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What requires containers?",
                              "options": [
                                "Stateless functions",
                                "WebSockets",
                                "Short tasks",
                                "Edge logic"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "AWS ECS",
                              "url": "https://docs.aws.amazon.com/ecs/",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T21:59:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439440",
    "title": "Advanced DevOps: CI/CD, GitOps & IaC (Terraform/Pulumi)",
    "slug": "advanced-devops-cicd-gitops-iac",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439441",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master advanced DevOps practices for reliable deployments and infrastructure management using CI/CD, GitOps, and IaC in web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439442",
            "title": "Advanced DevOps: CI/CD, GitOps & IaC (Terraform/Pulumi)",
            "slug": "advanced-devops-cicd-gitops-iac",
            "shortDescription": "An advanced course on CI/CD pipelines, GitOps workflows, and infrastructure as code for reliable web deployments.",
            "longDescription": "This course explores GitOps workflows with canary and blue/green deployments, advanced Terraform for modules and drift detection, secure secrets management with Vault and KMS, pipeline hardening with ephemeral runners, progressive delivery with feature flags, and disaster recovery with runbooks and backup strategies for web applications.",
            "tags": [
              "DevOps",
              "CI/CD",
              "GitOps",
              "IaC",
              "Web Development",
              "Advanced"
            ],
            "thumbnail": "https://example.com/thumbnails/advanced-devops.jpg",
            "levels": [
              {
                "level": "Advanced",
                "overview": "This advanced level focuses on reliable deployments and infrastructure management using CI/CD, GitOps, and IaC for web applications.",
                "goals": [
                  "Implement GitOps workflows with canary and blue/green deployments",
                  "Use advanced Terraform for modular IaC and drift detection",
                  "Manage secrets securely with Vault and KMS",
                  "Harden CI/CD pipelines with ephemeral runners and artifact signing",
                  "Apply progressive delivery with feature flags",
                  "Design disaster recovery strategies and runbooks"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439443",
                    "title": "Advanced DevOps: CI/CD, GitOps & IaC",
                    "slug": "advanced-devops-cicd-gitops-iac",
                    "description": "Learn to deploy reliably and manage infrastructure as code for web applications.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439444",
                        "title": "GitOps Workflows, Environment Promotion, Safe Rollouts",
                        "slug": "gitops-workflows",
                        "description": "Learn GitOps workflows, environment promotion, and safe rollout strategies like canary and blue/green.",
                        "order": 1,
                        "content": {
                          "explanation": "GitOps uses Git as the source of truth for infrastructure and deployments. Environment promotion moves changes through dev, staging, and prod. Safe rollouts include canary (gradual traffic shift) and blue/green (full switch). For example, ArgoCD applies Git manifests to Kubernetes. Advanced learners should implement GitOps with rollouts. Be cautious of misconfigured rollouts or untracked changes, which cause instability. These ensure reliable deployments.",
                          "examples": [
                            "# ArgoCD application.yaml\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: app\nspec:\n  destination:\n    namespace: prod\n  source:\n    repoURL: https://github.com/my/repo\n    path: manifests",
                            "# Canary rollout\nkubectl argo rollouts set image my-app my-app=nginx:1.19 --canary"
                          ],
                          "realWorldApplication": "Used in web apps for automated Kubernetes deployments or environment management.",
                          "expertInsights": "Use ArgoCD for GitOps; test canary rollouts; automate promotion with PRs.",
                          "commonMistakes": [
                            "Not syncing Git with cluster",
                            "Skipping canary testing",
                            "Ignoring rollback plans"
                          ],
                          "exercises": [
                            {
                              "title": "Implement GitOps Workflow",
                              "prompt": "Set up a GitOps workflow with ArgoCD for a Kubernetes app with canary rollout.",
                              "difficulty": "hard",
                              "hints": [
                                "Create Application manifest",
                                "Use canary strategy"
                              ],
                              "solution": "# application.yaml\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: my-app\nspec:\n  project: default\n  source:\n    repoURL: https://github.com/my/repo\n    path: manifests\n  destination:\n    server: https://kubernetes.default.svc\n    namespace: prod\n  syncPolicy:\n    automated: {}\n# rollout.yaml\napiVersion: argoproj.io/v1alpha1\nkind: Rollout\nmetadata:\n  name: my-app\nspec:\n  strategy:\n    canary:\n      steps:\n      - setWeight: 20\n      - pause: { duration: 10m }\n  template:\n    spec:\n      containers:\n      - name: app\n        image: nginx:1.19"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is the source of truth in GitOps?",
                              "options": ["Database", "Git", "Cluster", "CI"],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does canary rollout do?",
                              "options": [
                                "Full switch",
                                "Gradual traffic shift",
                                "Stops traffic",
                                "Caches data"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks misconfigured rollouts?",
                              "options": [
                                "Fast deploys",
                                "Instability",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "ArgoCD Documentation",
                              "url": "https://argo-cd.readthedocs.io/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439445",
                        "title": "Advanced Terraform: Modules, Remote State, Drift Detection, Testing IaC",
                        "slug": "advanced-terraform",
                        "description": "Learn advanced Terraform for modular IaC, remote state, and testing.",
                        "order": 2,
                        "content": {
                          "explanation": "Advanced Terraform uses modules for reusable code, remote state (e.g., S3 backend) for collaboration, drift detection to identify state mismatches, and testing with Terratest. For example, a module defines an EC2 instance. Advanced learners should modularize IaC and test it. Be cautious of state conflicts or untested code, which cause errors. These ensure reliable infrastructure.",
                          "examples": [
                            "# Terraform module\nmodule 'ec2' {\n  source = './modules/ec2'\n  instance_type = 't3.micro'\n}",
                            "# Remote state\nterraform {\n  backend 's3' {\n    bucket = 'my-state'\n    key = 'terraform.tfstate'\n    region = 'us-east-1'\n  }\n}"
                          ],
                          "realWorldApplication": "Used in web apps to manage cloud infrastructure like AWS ECS or RDS.",
                          "expertInsights": "Modularize with reusable code; use remote state; test with Terratest; check drift.",
                          "commonMistakes": [
                            "Not using modules",
                            "Ignoring state locking",
                            "Skipping IaC tests"
                          ],
                          "exercises": [
                            {
                              "title": "Deploy with Terraform",
                              "prompt": "Create a GitHub Action to run tests, build, and deploy a Terraform module to staging.",
                              "difficulty": "hard",
                              "hints": [
                                "Use Terraform module",
                                "Add Terratest in CI"
                              ],
                              "solution": "# .github/workflows/deploy.yml\nname: Deploy to Staging\non: [push]\njobs:\n  deploy:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - uses: hashicorp/setup-terraform@v2\n      - run: terraform init\n      - run: terraform apply -auto-approve\n      - run: go test ./tests # Terratest\n# main.tf\nmodule 'ec2' {\n  source = './modules/ec2'\n  instance_type = 't3.micro'\n}\n# tests/test.go\npackage test\nimport 'github.com/gruntwork-io/terratest/modules/terraform'\nfunc TestTerraform(t *testing.T) {\n  opts := &terraform.Options{TerraformDir: '../'}\n  defer terraform.Destroy(t, opts)\n  terraform.InitAndApply(t, opts)\n}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do Terraform modules provide?",
                              "options": [
                                "Caching",
                                "Reusable code",
                                "Secrets",
                                "Rollouts"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What stores Terraform state?",
                              "options": [
                                "Git",
                                "Remote backend",
                                "CI",
                                "Cluster"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does drift detection find?",
                              "options": [
                                "Code errors",
                                "State mismatches",
                                "Secrets",
                                "Tests"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What tests Terraform code?",
                              "options": [
                                "Terratest",
                                "ArgoCD",
                                "Vault",
                                "OPA"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Terraform Documentation",
                              "url": "https://www.terraform.io/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439446",
                        "title": "Secure Secrets Management (Vault, KMS) and Policy-as-Code (OPA)",
                        "slug": "secure-secrets-management",
                        "description": "Learn secure secrets management and policy-as-code with Vault, KMS, and OPA.",
                        "order": 3,
                        "content": {
                          "explanation": "Secure secrets management uses Vault for dynamic secrets or AWS KMS for encryption keys. Policy-as-code with OPA (Open Policy Agent) enforces rules (e.g., access control). For example, Vault generates temporary DB credentials. Advanced learners should integrate secrets and policies. Be cautious of exposed secrets or weak policies, which risk breaches. These ensure secure infrastructure.",
                          "examples": [
                            "# Vault secret\nvault kv put secret/db-creds password=secure123",
                            "# OPA policy\npackage auth\ndefault allow = false\nallow {\n  input.role == 'admin'\n}"
                          ],
                          "realWorldApplication": "Used in web apps to secure API keys or enforce access policies.",
                          "expertInsights": "Use Vault for dynamic secrets; integrate KMS for encryption; enforce OPA policies in CI.",
                          "commonMistakes": [
                            "Hardcoding secrets",
                            "Not rotating secrets",
                            "Weak OPA policies"
                          ],
                          "exercises": [
                            {
                              "title": "Manage Secrets with Vault",
                              "prompt": "Set up Vault to generate and retrieve a dynamic secret.",
                              "difficulty": "medium",
                              "hints": [
                                "Use Vault KV engine",
                                "Retrieve via API"
                              ],
                              "solution": "# Enable KV engine\nvault secrets enable -path=secret kv\n# Store secret\nvault kv put secret/my-app api-key=secure123\n# Retrieve in code\nconst vault = require('node-vault')();\nconst secret = await vault.read('secret/data/my-app');\nconsole.log(secret.data.data.api-key);"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does Vault manage?",
                              "options": [
                                "Code",
                                "Secrets",
                                "Rollouts",
                                "Tests"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does OPA enforce?",
                              "options": [
                                "Secrets",
                                "Policies",
                                "Rollouts",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks exposed secrets?",
                              "options": [
                                "Fast deploys",
                                "Breaches",
                                "Caching",
                                "Tests"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "HashiCorp Vault",
                              "url": "https://www.vaultproject.io/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439447",
                        "title": "Pipeline Hardening: Pipeline Secrets, Ephemeral Runners, Artifact Signing",
                        "slug": "pipeline-hardening",
                        "description": "Learn to harden CI/CD pipelines with secrets, ephemeral runners, and artifact signing.",
                        "order": 4,
                        "content": {
                          "explanation": "Pipeline hardening secures CI/CD with encrypted secrets (e.g., GitHub Secrets), ephemeral runners (e.g., GitHub self-hosted runners that reset), and artifact signing (e.g., GPG for Docker images). For example, sign a Docker image to verify authenticity. Advanced learners should secure pipelines. Be cautious of leaked secrets or persistent runners, which risk attacks. These ensure secure deployments.",
                          "examples": [
                            "# GitHub Action with secret\nenv:\n  API_KEY: ${{ secrets.API_KEY }}",
                            "# Sign Docker image\ncosign sign my-image:latest"
                          ],
                          "realWorldApplication": "Used in web apps to secure CI/CD pipelines for API deployments.",
                          "expertInsights": "Encrypt secrets; use ephemeral runners; sign artifacts with cosign.",
                          "commonMistakes": [
                            "Exposing secrets in logs",
                            "Using persistent runners",
                            "Not signing artifacts"
                          ],
                          "exercises": [
                            {
                              "title": "Harden CI Pipeline",
                              "prompt": "Create a GitHub Action with encrypted secrets and ephemeral runners.",
                              "difficulty": "medium",
                              "hints": [
                                "Use GitHub Secrets",
                                "Configure self-hosted runner"
                              ],
                              "solution": "# .github/workflows/secure.yml\nname: Secure CI\non: [push]\njobs:\n  build:\n    runs-on: self-hosted\n    steps:\n      - uses: actions/checkout@v3\n      - env:\n          API_KEY: ${{ secrets.API_KEY }}\n        run: echo 'Using secure key' && npm build"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What secures pipeline secrets?",
                              "options": [
                                "Encryption",
                                "Caching",
                                "Rollouts",
                                "Tests"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What do ephemeral runners do?",
                              "options": [
                                "Persist state",
                                "Reset per job",
                                "Sign artifacts",
                                "Cache builds"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What verifies artifacts?",
                              "options": [
                                "Secrets",
                                "Signing",
                                "Runners",
                                "OPA"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "GitHub Actions Security",
                              "url": "https://docs.github.com/en/actions/security-guides",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439448",
                        "title": "Progressive Delivery and Feature Flags (LaunchDarkly, Unleash)",
                        "slug": "progressive-delivery",
                        "description": "Learn progressive delivery with feature flags using LaunchDarkly or Unleash.",
                        "order": 5,
                        "content": {
                          "explanation": "Progressive delivery uses feature flags (e.g., LaunchDarkly, Unleash) to control feature releases. Flags enable toggling (e.g., enable for 10% of users). For example, Unleash flags a new UI feature. Advanced learners should implement flags. Be cautious of flag sprawl or untested rollouts, which cause errors. These ensure controlled feature releases.",
                          "examples": [
                            "// LaunchDarkly flag\nconst ldClient = require('launchdarkly-node-server-sdk').init('sdk-key');\nconst flag = await ldClient.variation('new-ui', { key: 'user123' }, false);",
                            "// Unleash flag\nconst unleash = require('unleash-client');\nconst enabled = unleash.isEnabled('new-ui');"
                          ],
                          "realWorldApplication": "Used in web apps to roll out features like new UI components gradually.",
                          "expertInsights": "Use LaunchDarkly for targeting; test flags; clean up old flags.",
                          "commonMistakes": [
                            "Not testing flag toggles",
                            "Leaving stale flags",
                            "Overusing flags"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Feature Flag",
                              "prompt": "Add a feature flag in Node.js using Unleash for a new API endpoint.",
                              "difficulty": "medium",
                              "hints": [
                                "Use unleash-client",
                                "Toggle endpoint"
                              ],
                              "solution": "const { initialize } = require('unleash-client');\nconst unleash = initialize({ url: 'http://unleash:4242/api', appName: 'my-app' });\nconst express = require('express');\nconst app = express();\napp.get('/new-feature', (req, res) => {\n  if (unleash.isEnabled('new-feature')) {\n    res.json({ message: 'New feature enabled' });\n  } else {\n    res.status(404).json({ message: 'Feature disabled' });\n  }\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do feature flags control?",
                              "options": [
                                "Secrets",
                                "Feature releases",
                                "Caching",
                                "Tests"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What enables progressive delivery?",
                              "options": [
                                "Runners",
                                "Feature flags",
                                "Secrets",
                                "OPA"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks flag sprawl?",
                              "options": [
                                "Fast rollouts",
                                "Errors",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "LaunchDarkly Documentation",
                              "url": "https://docs.launchdarkly.com/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439449",
                        "title": "Disaster Recovery and Runbooks, Backup Strategies, DR Testing",
                        "slug": "disaster-recovery",
                        "description": "Learn disaster recovery, runbooks, and backup strategies for web applications.",
                        "order": 6,
                        "content": {
                          "explanation": "Disaster recovery (DR) ensures system restoration after failures. Runbooks document recovery steps (e.g., restore DB from backup). Backup strategies include snapshots (e.g., RDS backups) and multi-region replication. DR testing validates recovery. For example, test DB restoration. Advanced learners should design DR plans. Be cautious of untested backups or vague runbooks, which delay recovery. These ensure system resilience.",
                          "examples": [
                            "# RDS snapshot (AWS CLI)\naws rds create-db-snapshot --db-instance-identifier mydb --db-snapshot-identifier mybackup",
                            "# Runbook example\n# Disaster: DB Failure\n1. Restore snapshot: aws rds restore-db-instance-from-db-snapshot\n2. Update DNS to new instance"
                          ],
                          "realWorldApplication": "Used in web apps to recover APIs or databases after outages.",
                          "expertInsights": "Automate backups; test DR regularly; keep runbooks clear and actionable.",
                          "commonMistakes": [
                            "Not testing backups",
                            "Vague runbooks",
                            "Ignoring multi-region DR"
                          ],
                          "exercises": [
                            {
                              "title": "Design DR Runbook",
                              "prompt": "Create a runbook for restoring an RDS database from a snapshot.",
                              "difficulty": "medium",
                              "hints": [
                                "Include snapshot restore",
                                "Update DNS"
                              ],
                              "solution": "# Runbook: RDS Disaster Recovery\n1. Identify latest snapshot: aws rds describe-db-snapshots --db-instance-identifier mydb\n2. Restore snapshot:\n   aws rds restore-db-instance-from-db-snapshot --db-instance-identifier mydb-new --db-snapshot-identifier mybackup\n3. Update application DNS to point to mydb-new\n4. Verify application connectivity"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What do runbooks document?",
                              "options": [
                                "Code",
                                "Recovery steps",
                                "Secrets",
                                "Tests"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What ensures DR reliability?",
                              "options": [
                                "Caching",
                                "DR testing",
                                "Rollouts",
                                "Flags"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks untested backups?",
                              "options": [
                                "Fast recovery",
                                "Failed recovery",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "AWS RDS Backups",
                              "url": "https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/USER_CreateSnapshot.html",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T22:02:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439450",
    "title": "Machine Learning Integration & Data-Driven Features",
    "slug": "machine-learning-integration",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439451",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master the integration of machine learning features into web applications with a focus on safety and reliability.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439452",
            "title": "Machine Learning Integration & Data-Driven Features",
            "slug": "machine-learning-integration",
            "shortDescription": "An advanced course on safely integrating ML features into web applications.",
            "longDescription": "This course covers ML system design for model serving and latency optimization, feature stores for reproducible data pipelines, model monitoring with drift detection and A/B testing, using embeddings for semantic search with PII considerations, and responsible AI practices for bias mitigation and explainability in web applications.",
            "tags": [
              "Machine Learning",
              "Web Development",
              "Data Pipelines",
              "Responsible AI",
              "Advanced"
            ],
            "thumbnail": "https://example.com/thumbnails/ml-integration.jpg",
            "levels": [
              {
                "level": "Advanced",
                "overview": "This advanced level focuses on safely integrating machine learning features into web applications with robust monitoring and responsible AI practices.",
                "goals": [
                  "Design ML systems for model serving with latency and throughput optimization",
                  "Build reproducible data pipelines using feature stores",
                  "Monitor models for drift and perform A/B testing",
                  "Implement semantic search with embeddings while addressing PII concerns",
                  "Apply responsible AI practices for bias mitigation and explainability"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439453",
                    "title": "Machine Learning Integration & Data-Driven Features",
                    "slug": "machine-learning-integration",
                    "description": "Learn to integrate ML features safely into web applications with robust data pipelines and responsible AI practices.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439454",
                        "title": "ML System Design: Model Serving, Latency vs Throughput, Batching",
                        "slug": "ml-system-design",
                        "description": "Learn ML system design for model serving, optimizing latency and throughput, and batching.",
                        "order": 1,
                        "content": {
                          "explanation": "ML system design involves serving models (e.g., via FastAPI or TensorFlow Serving) with optimized latency (e.g., single inference) or throughput (e.g., batch inference). Batching groups requests to reduce overhead. For example, a FastAPI endpoint serves a scikit-learn model. Advanced learners should optimize serving. Be cautious of high latency or resource overuse, which degrade performance. These ensure efficient ML in web apps.",
                          "examples": [
                            "# FastAPI model serving\nfrom fastapi import FastAPI\nfrom joblib import load\napp = FastAPI()\nmodel = load('model.joblib')\n@app.post('/predict')\nasync def predict(data: dict):\n  return {'prediction': model.predict([data['features']])[0]}",
                            "# Batching inference\nimport numpy as np\npredictions = model.predict(np.array([data1, data2]))"
                          ],
                          "realWorldApplication": "Used in recommendation systems for real-time predictions in web apps.",
                          "expertInsights": "Use lightweight models for latency; batch for throughput; consider GPU for heavy models.",
                          "commonMistakes": [
                            "Not batching high-throughput requests",
                            "Using heavy models for low-latency needs",
                            "Ignoring resource constraints"
                          ],
                          "exercises": [
                            {
                              "title": "Instrument Model Latency Metrics",
                              "prompt": "Add latency and error metrics to a FastAPI ML endpoint.",
                              "difficulty": "medium",
                              "hints": [
                                "Use Prometheus client",
                                "Track latency and errors"
                              ],
                              "solution": "from fastapi import FastAPI\nfrom prometheus_client import Histogram, Counter\nimport time\napp = FastAPI()\nmodel = load('model.joblib')\nlatency = Histogram('predict_latency_seconds', 'Prediction latency')\nerrors = Counter('predict_errors_total', 'Prediction errors')\n@app.post('/predict')\nasync def predict(data: dict):\n  start = time.time()\n  try:\n    pred = model.predict([data['features']])[0]\n    latency.observe(time.time() - start)\n    return {'prediction': pred}\n  except Exception:\n    errors.inc()\n    raise"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does batching improve?",
                              "options": [
                                "Latency",
                                "Throughput",
                                "Security",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What serves ML models in web apps?",
                              "options": [
                                "FastAPI",
                                "Database",
                                "CDN",
                                "Worker"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What risks high latency?",
                              "options": [
                                "Batching",
                                "Heavy models",
                                "Caching",
                                "Light models"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "FastAPI Documentation",
                              "url": "https://fastapi.tiangolo.com/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439455",
                        "title": "Feature Stores & Data Pipelines for Reproducibility",
                        "slug": "feature-stores-pipelines",
                        "description": "Learn feature stores and data pipelines for reproducible ML features.",
                        "order": 2,
                        "content": {
                          "explanation": "Feature stores (e.g., Feast) centralize feature engineering for reproducibility. Data pipelines (e.g., Apache Airflow) extract, transform, and load data consistently. For example, Feast stores user activity features for ML models. Advanced learners should build pipelines with feature stores. Be cautious of inconsistent data or missing features, which break reproducibility. These ensure reliable ML inputs.",
                          "examples": [
                            "# Feast feature store (Python)\nfrom feast import FeatureStore\nstore = FeatureStore(repo_path='.')\nfeatures = store.get_online_features(\n  feature_refs=['user:activity'],\n  entity_rows=[{'user_id': '123'}]\n)",
                            "# Airflow pipeline\nfrom airflow import DAG\nfrom airflow.operators.python import PythonOperator\ndef extract_features():\n  # ETL logic\n  pass\ndag = DAG('feature_pipeline', schedule_interval='@daily')\ntask = PythonOperator(task_id='extract', python_callable=extract_features, dag=dag)"
                          ],
                          "realWorldApplication": "Used in e-commerce for consistent user features in recommendation models.",
                          "expertInsights": "Use Feast for feature stores; automate pipelines with Airflow; version features.",
                          "commonMistakes": [
                            "Not versioning features",
                            "Inconsistent data pipelines",
                            "Ignoring feature store caching"
                          ],
                          "exercises": [
                            {
                              "title": "Create Feature Pipeline",
                              "prompt": "Set up a simple Airflow pipeline to extract features for a Feast store.",
                              "difficulty": "medium",
                              "hints": [
                                "Use PythonOperator",
                                "Store features in Feast"
                              ],
                              "solution": "from airflow import DAG\nfrom airflow.operators.python import PythonOperator\nfrom feast import FeatureStore\nfrom datetime import datetime\ndef extract_features():\n  store = FeatureStore(repo_path='.')\n  store.materialize(start_date=datetime(2025, 1, 1), end_date=datetime.now())\ndag = DAG('feature_extract', schedule_interval='@daily', start_date=datetime(2025, 1, 1))\ntask = PythonOperator(task_id='extract_features', python_callable=extract_features, dag=dag)"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does a feature store centralize?",
                              "options": [
                                "Models",
                                "Features",
                                "Predictions",
                                "Metrics"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What ensures pipeline reproducibility?",
                              "options": [
                                "Caching",
                                "Versioning",
                                "Latency",
                                "Batching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What automates data pipelines?",
                              "options": [
                                "Feast",
                                "Airflow",
                                "FastAPI",
                                "Prometheus"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks inconsistent pipelines?",
                              "options": [
                                "Reproducibility issues",
                                "Low latency",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Feast Documentation",
                              "url": "https://docs.feast.dev/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439456",
                        "title": "Model Monitoring and Drift Detection, A/B Testing Models",
                        "slug": "model-monitoring",
                        "description": "Learn model monitoring, drift detection, and A/B testing for ML models.",
                        "order": 3,
                        "content": {
                          "explanation": "Model monitoring tracks performance (e.g., accuracy) using tools like Prometheus. Drift detection identifies data shifts (e.g., Evidently AI for feature drift). A/B testing compares model versions (e.g., route 10% traffic to new model). For example, monitor prediction accuracy in production. Advanced learners should implement monitoring and testing. Be cautious of undetected drift or untested models, which degrade performance. These ensure reliable ML outputs.",
                          "examples": [
                            "# Prometheus monitoring\nfrom prometheus_client import Gauge\naccuracy = Gauge('model_accuracy', 'Model accuracy')\naccuracy.set(0.95)",
                            "# Evidently AI drift detection\nfrom evidently.report import Report\nreport = Report(metrics=[DataDriftMetric()])\nreport.run(reference_data=ref_df, current_data=new_df)"
                          ],
                          "realWorldApplication": "Used in web apps to monitor recommendation or fraud detection models.",
                          "expertInsights": "Monitor accuracy and latency; use Evidently for drift; A/B test with small traffic.",
                          "commonMistakes": [
                            "Not monitoring production models",
                            "Ignoring data drift",
                            "Skipping A/B tests"
                          ],
                          "exercises": [
                            {
                              "title": "Monitor Model Metrics",
                              "prompt": "Add Prometheus metrics to monitor model accuracy and latency.",
                              "difficulty": "medium",
                              "hints": [
                                "Use Gauge for accuracy",
                                "Use Histogram for latency"
                              ],
                              "solution": "from prometheus_client import Gauge, Histogram\nimport time\naccuracy = Gauge('model_accuracy', 'Model accuracy')\nlatency = Histogram('predict_latency_seconds', 'Prediction latency')\ndef predict(data):\n  start = time.time()\n  try:\n    pred = model.predict([data])[0]\n    accuracy.set(0.95)  # Example accuracy\n    latency.observe(time.time() - start)\n    return pred\n  except Exception:\n    latency.observe(time.time() - start)\n    raise"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does drift detection identify?",
                              "options": [
                                "Model accuracy",
                                "Data shifts",
                                "Latency",
                                "Predictions"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What compares model versions?",
                              "options": [
                                "Drift detection",
                                "A/B testing",
                                "Monitoring",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks undetected drift?",
                              "options": [
                                "Low latency",
                                "Performance degradation",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Evidently AI",
                              "url": "https://docs.evidentlyai.com/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439457",
                        "title": "Using Embeddings & Semantic Search, Privacy-Preserving ML",
                        "slug": "embeddings-semantic-search",
                        "description": "Learn to use embeddings for semantic search and address PII concerns.",
                        "order": 4,
                        "content": {
                          "explanation": "Embeddings (e.g., from SentenceTransformers) enable semantic search by comparing vector similarity. Privacy-preserving ML anonymizes PII (e.g., hashing user IDs). For example, a FastAPI endpoint serves semantic search with embeddings. Advanced learners should implement search with PII protection. Be cautious of exposed PII or high-dimensional embeddings, which impact privacy or performance. These enable intelligent, secure web apps.",
                          "examples": [
                            "# Semantic search with SentenceTransformers\nfrom sentence_transformers import SentenceTransformer, util\nmodel = SentenceTransformer('all-MiniLM-L6-v2')\nembeddings = model.encode(['query', 'doc'])\nsimilarity = util.cos_sim(embeddings[0], embeddings[1])",
                            "# PII hashing\nimport hashlib\ndef anonymize_pii(data):\n  return hashlib.sha256(data.encode()).hexdigest()"
                          ],
                          "realWorldApplication": "Used in search engines or chatbots for semantic queries with privacy.",
                          "expertInsights": "Use lightweight embeddings; anonymize PII; cache vectors for performance.",
                          "commonMistakes": [
                            "Exposing PII in embeddings",
                            "Using high-dimensional vectors",
                            "Not caching embeddings"
                          ],
                          "exercises": [
                            {
                              "title": "Add Semantic Search Endpoint",
                              "prompt": "Create a FastAPI endpoint for semantic search using embeddings with PII anonymization.",
                              "difficulty": "hard",
                              "hints": [
                                "Use SentenceTransformers",
                                "Hash user IDs"
                              ],
                              "solution": "from fastapi import FastAPI\nfrom sentence_transformers import SentenceTransformer, util\nimport hashlib\napp = FastAPI()\nmodel = SentenceTransformer('all-MiniLM-L6-v2')\n@app.post('/search')\nasync def search(data: dict):\n  user_id = hashlib.sha256(data['user_id'].encode()).hexdigest()\n  query_emb = model.encode(data['query'])\n  doc_emb = model.encode(data['doc'])\n  score = util.cos_sim(query_emb, doc_emb)[0][0]\n  return {'user_id': user_id, 'similarity': float(score)}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What enables semantic search?",
                              "options": [
                                "SQL",
                                "Embeddings",
                                "Caching",
                                "Metrics"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What protects PII in ML?",
                              "options": [
                                "Hashing",
                                "Batching",
                                "Drift detection",
                                "A/B testing"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What risks high-dimensional embeddings?",
                              "options": [
                                "Low latency",
                                "Performance issues",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "SentenceTransformers",
                              "url": "https://www.sbert.net/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439458",
                        "title": "Responsible AI: Bias Mitigation, Explainability Basics, Privacy",
                        "slug": "responsible-ai",
                        "description": "Learn responsible AI practices for bias mitigation, explainability, and privacy.",
                        "order": 5,
                        "content": {
                          "explanation": "Responsible AI mitigates bias (e.g., reweighting datasets), ensures explainability (e.g., SHAP values for model decisions), and protects privacy (e.g., differential privacy). For example, SHAP explains feature importance in predictions. Advanced learners should implement responsible AI practices. Be cautious of biased models or unclear outputs, which erode trust. These ensure ethical ML in web apps.",
                          "examples": [
                            "# SHAP explainability\nimport shap\nexplainer = shap.TreeExplainer(model)\nshap_values = explainer.shap_values(X)",
                            "# Bias mitigation (reweighting)\nweights = compute_sample_weights(y, sensitive_feature)\nmodel.fit(X, y, sample_weight=weights)"
                          ],
                          "realWorldApplication": "Used in hiring tools or loan systems to ensure fair, transparent decisions.",
                          "expertInsights": "Use SHAP for explainability; reweight for bias; apply differential privacy.",
                          "commonMistakes": [
                            "Ignoring model bias",
                            "Not explaining predictions",
                            "Skipping privacy measures"
                          ],
                          "exercises": [
                            {
                              "title": "Add Explainability to Model",
                              "prompt": "Use SHAP to explain predictions in a scikit-learn model.",
                              "difficulty": "medium",
                              "hints": [
                                "Use TreeExplainer",
                                "Compute SHAP values"
                              ],
                              "solution": "import shap\nfrom sklearn.ensemble import RandomForestClassifier\nmodel = RandomForestClassifier().fit(X_train, y_train)\nexplainer = shap.TreeExplainer(model)\nshap_values = explainer.shap_values(X_test)\nshap.summary_plot(shap_values, X_test)"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does SHAP provide?",
                              "options": [
                                "Predictions",
                                "Explainability",
                                "Caching",
                                "Batching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What mitigates model bias?",
                              "options": [
                                "Reweighting",
                                "Drift detection",
                                "A/B testing",
                                "Embeddings"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What protects privacy in AI?",
                              "options": [
                                "Differential privacy",
                                "Latency",
                                "Throughput",
                                "Caching"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "SHAP Documentation",
                              "url": "https://shap.readthedocs.io/",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T22:04:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439460",
    "title": "Enterprise Patterns: Multi-Tenant & Observability at Scale",
    "slug": "enterprise-patterns-multitenant-observability",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439461",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master enterprise-grade multi-tenant SaaS patterns and observability for scalable web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439462",
            "title": "Enterprise Patterns: Multi-Tenant & Observability at Scale",
            "slug": "enterprise-patterns-multitenant-observability",
            "shortDescription": "An advanced course on designing multi-tenant SaaS systems with robust observability.",
            "longDescription": "This course explores multi-tenant isolation strategies, billing and metering patterns, tenant-aware observability with logs and metrics isolation, data residency and compliance, and tenant onboarding with migration strategies for scalable web applications.",
            "tags": [
              "Multi-Tenant",
              "Observability",
              "SaaS",
              "Web Development",
              "Advanced"
            ],
            "thumbnail": "https://example.com/thumbnails/multitenant-observability.jpg",
            "levels": [
              {
                "level": "Advanced",
                "overview": "This advanced level focuses on designing multi-tenant SaaS systems with robust observability and operational controls.",
                "goals": [
                  "Implement multi-tenant isolation strategies for data and compute",
                  "Design billing, metering, and quota enforcement per tenant",
                  "Build tenant-aware observability with isolated logs and metrics",
                  "Ensure data residency and compliance with per-tenant backups",
                  "Manage tenant onboarding and independent scaling"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439463",
                    "title": "Enterprise Patterns: Multi-Tenant & Observability",
                    "slug": "enterprise-patterns-multitenant-observability",
                    "description": "Learn to design SaaS patterns and operational controls for multiple tenants in web applications.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439464",
                        "title": "Multi-Tenant Isolation Strategies: Schema-per-Tenant vs Shared Schema vs DB-per-Tenant",
                        "slug": "multi-tenant-isolation",
                        "description": "Learn multi-tenant isolation strategies for data and compute.",
                        "order": 1,
                        "content": {
                          "explanation": "Multi-tenant isolation ensures tenant data and compute separation. Schema-per-tenant uses separate DB schemas, shared schema uses a tenant_id column, and DB-per-tenant allocates separate databases. For example, a shared schema queries with `WHERE tenant_id = '123'`. Advanced learners should design a multi-tenant model. Be cautious of cross-tenant leaks or performance issues, which compromise isolation. These ensure secure, scalable SaaS.",
                          "examples": [
                            "-- Shared schema (PostgreSQL)\nCREATE TABLE users (id SERIAL, tenant_id UUID, name TEXT);\nSELECT * FROM users WHERE tenant_id = '123';",
                            "-- Schema-per-tenant\nCREATE SCHEMA tenant_123;\nCREATE TABLE tenant_123.users (id SERIAL, name TEXT);"
                          ],
                          "realWorldApplication": "Used in SaaS apps like CRMs to isolate tenant data securely.",
                          "expertInsights": "Use shared schema for simplicity; DB-per-tenant for strict isolation; test performance.",
                          "commonMistakes": [
                            "Not indexing tenant_id",
                            "Mixing tenant data",
                            "Overusing DB-per-tenant"
                          ],
                          "exercises": [
                            {
                              "title": "Design Multi-Tenant Data Model",
                              "prompt": "Create a shared schema data model for a multi-tenant SaaS app.",
                              "difficulty": "medium",
                              "hints": [
                                "Add tenant_id column",
                                "Index tenant_id"
                              ],
                              "solution": "-- schema.sql\nCREATE TABLE tenants (tenant_id UUID PRIMARY KEY, name TEXT);\nCREATE TABLE users (id SERIAL PRIMARY KEY, tenant_id UUID REFERENCES tenants(tenant_id), name TEXT);\nCREATE INDEX idx_users_tenant_id ON users(tenant_id);\n-- Query example\nSELECT * FROM users WHERE tenant_id = '123e4567-e89b-12d3-a456-426614174000';"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does shared schema use to isolate tenants?",
                              "options": [
                                "Separate DBs",
                                "Tenant_id column",
                                "Separate schemas",
                                "Caching"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What provides strictest isolation?",
                              "options": [
                                "Shared schema",
                                "Schema-per-tenant",
                                "DB-per-tenant",
                                "Tenant_id index"
                              ],
                              "correctOption": [2]
                            },
                            {
                              "question": "What risks cross-tenant leaks?",
                              "options": [
                                "Indexing",
                                "Missing tenant_id filter",
                                "Separate DBs",
                                "Caching"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 100,
                          "resources": [
                            {
                              "title": "Multi-Tenancy Patterns",
                              "url": "https://www.postgresql.org/docs/current/ddl-partitioning.html",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439465",
                        "title": "Billing & Metering Patterns, Rate Limiting Per-Tenant, Quota Enforcement",
                        "slug": "billing-metering",
                        "description": "Learn billing, metering, and quota enforcement for multi-tenant systems.",
                        "order": 2,
                        "content": {
                          "explanation": "Billing tracks tenant usage (e.g., API calls via Stripe). Metering measures resources (e.g., request count). Rate limiting (e.g., Redis-based) and quota enforcement cap usage per tenant. For example, limit 1000 requests/day per tenant. Advanced learners should implement metering and limits. Be cautious of inaccurate metering or unlimited quotas, which affect revenue or performance. These ensure fair SaaS billing.",
                          "examples": [
                            "# Redis rate limiting\nconst redis = require('redis');\nconst client = redis.createClient();\nasync function rateLimit(tenantId, limit = 1000) {\n  const key = `rate:${tenantId}`;\n  const count = await client.incr(key);\n  if (count === 1) await client.expire(key, 86400);\n  return count <= limit;\n}",
                            "# Stripe billing\nconst stripe = require('stripe')('sk_key');\nawait stripe.usageRecords.create('sub_123', { quantity: 100, timestamp: Date.now() });"
                          ],
                          "realWorldApplication": "Used in SaaS for billing API usage or enforcing tenant quotas.",
                          "expertInsights": "Meter with precision; use Redis for rate limiting; enforce quotas in middleware.",
                          "commonMistakes": [
                            "Inaccurate usage tracking",
                            "Not enforcing quotas",
                            "Ignoring rate limits"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Tenant Rate Limiting",
                              "prompt": "Create a Node.js middleware for per-tenant rate limiting using Redis.",
                              "difficulty": "medium",
                              "hints": [
                                "Use Redis INCR",
                                "Set expiry for daily limit"
                              ],
                              "solution": "const redis = require('redis');\nconst client = redis.createClient();\nasync function rateLimitMiddleware(req, res, next) {\n  const tenantId = req.headers['x-tenant-id'];\n  const key = `rate:${tenantId}`;\n  const count = await client.incr(key);\n  if (count === 1) await client.expire(key, 86400);\n  if (count > 1000) return res.status(429).json({ error: 'Rate limit exceeded' });\n  next();\n}\nmodule.exports = rateLimitMiddleware;"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does metering track?",
                              "options": [
                                "Security",
                                "Resource usage",
                                "Latency",
                                "Logs"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What enforces tenant limits?",
                              "options": [
                                "Billing",
                                "Rate limiting",
                                "Metering",
                                "Quotas"
                              ],
                              "correctOption": [1, 3]
                            },
                            {
                              "question": "What risks inaccurate metering?",
                              "options": [
                                "Performance",
                                "Revenue loss",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What tool is used for rate limiting?",
                              "options": [
                                "Stripe",
                                "Redis",
                                "PostgreSQL",
                                "Prometheus"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Stripe Metered Billing",
                              "url": "https://stripe.com/docs/billing/subscriptions/metered-billing",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439466",
                        "title": "Tenant-Aware Observability, Logs & Metrics Isolation, Blast Radius Controls",
                        "slug": "tenant-observability",
                        "description": "Learn tenant-aware observability with isolated logs and metrics.",
                        "order": 3,
                        "content": {
                          "explanation": "Tenant-aware observability isolates logs and metrics by tenant_id (e.g., in Prometheus or ELK). Logs include tenant context (e.g., JSON with tenant_id). Blast radius controls limit failures (e.g., circuit breakers). For example, tag Prometheus metrics with tenant_id. Advanced learners should implement isolated observability. Be cautious of cross-tenant logs or unlimited failures, which obscure issues or spread outages. These ensure reliable SaaS monitoring.",
                          "examples": [
                            "# Tenant-aware Prometheus metrics\nconst { Counter } = require('prom-client');\nconst requests = new Counter({\n  name: 'requests_total',\n  help: 'Total requests',\n  labelNames: ['tenant_id']\n});\nrequests.inc({ tenant_id: '123' });",
                            "# Circuit breaker\nconst { CircuitBreaker } = require('opossum');\nconst breaker = new CircuitBreaker(async () => apiCall(), { maxFailures: 5 });"
                          ],
                          "realWorldApplication": "Used in SaaS to monitor tenant-specific performance or isolate failures.",
                          "expertInsights": "Tag metrics with tenant_id; isolate logs in ELK; use circuit breakers for resilience.",
                          "commonMistakes": [
                            "Not tagging metrics by tenant",
                            "Mixing tenant logs",
                            "Ignoring blast radius"
                          ],
                          "exercises": [
                            {
                              "title": "Add Tenant-Aware Metrics",
                              "prompt": "Create a Prometheus metric tagged by tenant_id for API requests.",
                              "difficulty": "medium",
                              "hints": [
                                "Use prom-client",
                                "Add tenant_id label"
                              ],
                              "solution": "const { Counter } = require('prom-client');\nconst express = require('express');\nconst app = express();\nconst requests = new Counter({\n  name: 'api_requests_total',\n  help: 'Total API requests',\n  labelNames: ['tenant_id']\n});\napp.get('/api', (req, res) => {\n  const tenantId = req.headers['x-tenant-id'] || 'default';\n  requests.inc({ tenant_id: tenantId });\n  res.json({ status: 'ok' });\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What isolates tenant metrics?",
                              "options": [
                                "Tenant_id tags",
                                "Separate DBs",
                                "Caching",
                                "Rate limiting"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What limits failure spread?",
                              "options": [
                                "Logs",
                                "Circuit breakers",
                                "Metrics",
                                "Billing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks mixed tenant logs?",
                              "options": [
                                "Performance",
                                "Obscured issues",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Prometheus Multi-Tenancy",
                              "url": "https://prometheus.io/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439467",
                        "title": "Data Residency, Regional Compliance, Backups & Restore Per Tenant",
                        "slug": "data-residency",
                        "description": "Learn data residency, compliance, and per-tenant backups.",
                        "order": 4,
                        "content": {
                          "explanation": "Data residency ensures tenant data stays in specific regions (e.g., AWS regions for GDPR). Regional compliance follows laws (e.g., encrypt data for CCPA). Per-tenant backups (e.g., tenant-specific RDS snapshots) enable isolated restores. For example, store EU tenant data in eu-west-1. Advanced learners should implement residency and backups. Be cautious of non-compliant storage or untested restores, which risk fines or data loss. These ensure legal, reliable SaaS.",
                          "examples": [
                            "# Tenant-specific RDS backup\naws rds create-db-snapshot --db-instance-identifier tenant-123-db --db-snapshot-identifier tenant-123-backup",
                            "# Region-specific storage (AWS S3)\naws s3api create-bucket --bucket tenant-123-data --region eu-west-1 --create-bucket-configuration LocationConstraint=eu-west-1"
                          ],
                          "realWorldApplication": "Used in SaaS for GDPR-compliant data storage or tenant-specific recovery.",
                          "expertInsights": "Enforce region with IAM; automate tenant backups; test restores regularly.",
                          "commonMistakes": [
                            "Storing data in wrong regions",
                            "Not isolating backups",
                            "Skipping restore tests"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Tenant Backup",
                              "prompt": "Create a script for tenant-specific RDS snapshots.",
                              "difficulty": "medium",
                              "hints": ["Use AWS CLI", "Tag with tenant_id"],
                              "solution": "# backup.sh\n#!/bin/bash\ntenant_id=$1\naws rds create-db-snapshot --db-instance-identifier tenant-${tenant_id}-db --db-snapshot-identifier tenant-${tenant_id}-backup-$(date +%F) --tags Key=tenant_id,Value=${tenant_id}"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What ensures GDPR-compliant storage?",
                              "options": [
                                "Caching",
                                "Data residency",
                                "Rate limiting",
                                "Metrics"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What enables tenant-specific recovery?",
                              "options": [
                                "Shared backups",
                                "Per-tenant backups",
                                "Logs",
                                "Metrics"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks untested restores?",
                              "options": [
                                "Fast recovery",
                                "Data loss",
                                "Caching",
                                "Performance"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 100,
                          "resources": [
                            {
                              "title": "AWS GDPR Compliance",
                              "url": "https://aws.amazon.com/compliance/gdpr-center/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439468",
                        "title": "Tenant Onboarding, Migration Strategies, Scaling Tenants Independently",
                        "slug": "tenant-onboarding",
                        "description": "Learn tenant onboarding, migration, and independent scaling.",
                        "order": 5,
                        "content": {
                          "explanation": "Tenant onboarding automates setup (e.g., create schema via API). Migration strategies move tenant data (e.g., ETL scripts for schema-per-tenant). Independent scaling allocates resources per tenant (e.g., Kubernetes namespaces). For example, onboard a tenant with a new schema. Advanced learners should automate onboarding. Be cautious of manual setups or data migration errors, which delay or break tenants. These ensure scalable SaaS growth.",
                          "examples": [
                            "# Onboarding script (PostgreSQL)\nCREATE SCHEMA tenant_123;\nCREATE TABLE tenant_123.users (id SERIAL, name TEXT);",
                            "# Migration ETL (Python)\nimport pandas as pd\ndef migrate_tenant(tenant_id):\n  data = pd.read_sql(f'SELECT * FROM old_users WHERE tenant_id = \\'{tenant_id}\\'', old_db)\n  data.to_sql('users', new_db, schema=f'tenant_{tenant_id}')"
                          ],
                          "realWorldApplication": "Used in SaaS to onboard new customers or scale tenant workloads.",
                          "expertInsights": "Automate onboarding with APIs; validate migrations; use namespaces for scaling.",
                          "commonMistakes": [
                            "Manual onboarding",
                            "Not validating migrations",
                            "Overloading shared resources"
                          ],
                          "exercises": [
                            {
                              "title": "Simulate Tenant Onboarding",
                              "prompt": "Create a script to onboard a tenant with a new schema and migrate data.",
                              "difficulty": "hard",
                              "hints": [
                                "Use PostgreSQL schema",
                                "Write migration script"
                              ],
                              "solution": "import psycopg2\ndef onboard_tenant(tenant_id):\n  conn = psycopg2.connect(dbname='saas', user='user', password='pass')\n  cur = conn.cursor()\n  cur.execute(f'CREATE SCHEMA tenant_{tenant_id}')\n  cur.execute(f'CREATE TABLE tenant_{tenant_id}.users (id SERIAL PRIMARY KEY, name TEXT)')\n  cur.execute(f'INSERT INTO tenant_{tenant_id}.users (name) SELECT name FROM old_users WHERE tenant_id = %s', (tenant_id,))\n  conn.commit()\n  cur.close()\n  conn.close()\nonboard_tenant('123e4567-e89b-12d3-a456-426614174000')"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What automates tenant setup?",
                              "options": [
                                "Manual scripts",
                                "Onboarding APIs",
                                "Metrics",
                                "Logs"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What moves tenant data?",
                              "options": [
                                "Rate limiting",
                                "Migration scripts",
                                "Caching",
                                "Backups"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What enables independent scaling?",
                              "options": [
                                "Shared schema",
                                "Namespaces",
                                "Logs",
                                "Billing"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 120,
                          "resources": [
                            {
                              "title": "Kubernetes Namespaces",
                              "url": "https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T22:07:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439470",
    "title": "Advanced Testing: Property, Fuzzing & Contract Testing",
    "slug": "advanced-testing-property-fuzzing-contract",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439471",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master advanced testing techniques to reduce production incidents in web applications.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439472",
            "title": "Advanced Testing: Property, Fuzzing & Contract Testing",
            "slug": "advanced-testing-property-fuzzing-contract",
            "shortDescription": "An advanced course on property-based testing, fuzzing, and contract testing for reliable web systems.",
            "longDescription": "This course explores property-based testing with fast-check, contract testing with Pact for microservices, scalable E2E testing with Playwright, chaos testing in CI, and test observability with flakiness detection and retry strategies for web applications.",
            "tags": [
              "Testing",
              "Property-Based Testing",
              "Fuzzing",
              "Contract Testing",
              "Web Development",
              "Advanced"
            ],
            "thumbnail": "https://example.com/thumbnails/advanced-testing.jpg",
            "levels": [
              {
                "level": "Advanced",
                "overview": "This advanced level focuses on reducing production incidents through advanced testing approaches for web applications.",
                "goals": [
                  "Implement property-based testing and fuzzing to catch edge cases",
                  "Use contract testing to ensure microservices compatibility",
                  "Scale E2E tests with Playwright and manage test data",
                  "Incorporate chaos testing into CI pipelines",
                  "Enhance test observability with flakiness detection and retries"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439473",
                    "title": "Advanced Testing: Property, Fuzzing & Contract Testing",
                    "slug": "advanced-testing-property-fuzzing-contract",
                    "description": "Learn advanced testing techniques to reduce production incidents in web applications.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439474",
                        "title": "Property-Based Testing (fast-check) and Fuzzing Strategies",
                        "slug": "property-based-testing",
                        "description": "Learn property-based testing with fast-check and fuzzing strategies.",
                        "order": 1,
                        "content": {
                          "explanation": "Property-based testing (e.g., fast-check) tests invariants with random inputs (e.g., 'sum is always positive'). Fuzzing generates random data to find edge cases. For example, test a function with fast-check to ensure it handles varied inputs. Advanced learners should write property tests. Be cautious of weak properties or unhandled edge cases, which miss bugs. These ensure robust web app logic.",
                          "examples": [
                            "// fast-check property test\nimport fc from 'fast-check';\ntest('sum is positive', () => {\n  fc.assert(\n    fc.property(fc.integer(), fc.integer(), (a, b) => {\n      return a + b >= 0 || a + b < 0; // Example property\n    })\n  );\n});",
                            "// Fuzzing example\nconst fuzz = require('jsfuzz');\nconst input = fuzz.generateRandomInput();\nmyFunction(input);"
                          ],
                          "realWorldApplication": "Used in web apps to test form validation or API input handling.",
                          "expertInsights": "Define clear properties; use fast-check for complex inputs; fuzz for security.",
                          "commonMistakes": [
                            "Writing vague properties",
                            "Not covering edge cases",
                            "Ignoring fuzzing results"
                          ],
                          "exercises": [
                            {
                              "title": "Build Property-Based Test",
                              "prompt": "Write a fast-check test to verify a string concatenation function.",
                              "difficulty": "medium",
                              "hints": [
                                "Use fc.string()",
                                "Check concatenation length"
                              ],
                              "solution": "import fc from 'fast-check';\nfunction concat(a, b) { return a + b; }\ntest('concat length', () => {\n  fc.assert(\n    fc.property(fc.string(), fc.string(), (a, b) => {\n      expect(concat(a, b).length).toBe(a.length + b.length);\n    })\n  );\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does property-based testing check?",
                              "options": [
                                "Specific inputs",
                                "Invariants",
                                "UI",
                                "Logs"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What generates random inputs?",
                              "options": [
                                "Fuzzing",
                                "E2E testing",
                                "Contract testing",
                                "Chaos testing"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What risks weak properties?",
                              "options": [
                                "Missing bugs",
                                "Fast tests",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "fast-check Documentation",
                              "url": "https://fast-check.dev/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439475",
                        "title": "Contract Testing at Scale (Pact) for Microservices Compatibility",
                        "slug": "contract-testing",
                        "description": "Learn contract testing with Pact for microservices compatibility.",
                        "order": 2,
                        "content": {
                          "explanation": "Contract testing (e.g., Pact) verifies microservices interactions by defining consumer-provider contracts. It ensures compatibility at scale without full integration tests. For example, a frontend tests an API’s response shape. Advanced learners should write contract tests. Be cautious of outdated contracts or missing interactions, which cause integration failures. These ensure reliable microservices in web apps.",
                          "examples": [
                            "// Pact consumer test (frontend)\nconst { Pact } = require('@pact-foundation/pact');\nconst provider = new Pact({ consumer: 'Frontend', provider: 'API' });\ntest('fetches user', async () => {\n  await provider.addInteraction({\n    state: 'user exists',\n    uponReceiving: 'GET user',\n    withRequest: { method: 'GET', path: '/user/123' },\n    willRespondWith: { status: 200, body: { id: '123', name: 'Alice' } }\n  });\n  const response = await fetch(provider.mockService.baseUrl + '/user/123');\n  expect(await response.json()).toEqual({ id: '123', name: 'Alice' });\n});",
                            "// Pact provider verification\npact-verifier --provider-base-url=http://api:8080 --pact-urls=./pacts/frontend-api.json"
                          ],
                          "realWorldApplication": "Used in microservices to verify frontend-API or API-DB interactions.",
                          "expertInsights": "Use Pact for contracts; verify both consumer and provider; update contracts regularly.",
                          "commonMistakes": [
                            "Not verifying providers",
                            "Outdated contracts",
                            "Skipping edge cases"
                          ],
                          "exercises": [
                            {
                              "title": "Add Contract Tests",
                              "prompt": "Create a Pact test between a frontend and API for a user endpoint.",
                              "difficulty": "hard",
                              "hints": [
                                "Define interaction",
                                "Mock API response"
                              ],
                              "solution": "const { Pact } = require('@pact-foundation/pact');\nconst provider = new Pact({ consumer: 'Frontend', provider: 'API', port: 1234 });\ntest('fetches user', async () => {\n  await provider.setup();\n  await provider.addInteraction({\n    state: 'user exists',\n    uponReceiving: 'GET user',\n    withRequest: { method: 'GET', path: '/user/123' },\n    willRespondWith: { status: 200, body: { id: '123', name: 'Alice' } }\n  });\n  const response = await fetch(provider.mockService.baseUrl + '/user/123');\n  expect(await response.json()).toEqual({ id: '123', name: 'Alice' });\n  await provider.finalize();\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does contract testing verify?",
                              "options": [
                                "UI",
                                "Microservices compatibility",
                                "Performance",
                                "Logs"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What tool is used for contract testing?",
                              "options": [
                                "Playwright",
                                "Pact",
                                "fast-check",
                                "Opossum"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks outdated contracts?",
                              "options": [
                                "Fast tests",
                                "Integration failures",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does Pact define?",
                              "options": [
                                "Consumer-provider contracts",
                                "E2E flows",
                                "Fuzzing inputs",
                                "Chaos tests"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 100,
                          "resources": [
                            {
                              "title": "Pact Documentation",
                              "url": "https://docs.pact.io/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439476",
                        "title": "E2E at Scale with Playwright + Parallelization, Test Data Management",
                        "slug": "e2e-testing",
                        "description": "Learn scalable E2E testing with Playwright and test data management.",
                        "order": 3,
                        "content": {
                          "explanation": "End-to-end (E2E) testing with Playwright automates browser flows. Parallelization (e.g., Playwright workers) speeds up tests. Test data management creates isolated datasets (e.g., DB seeding). For example, test a login flow with Playwright. Advanced learners should scale E2E tests. Be cautious of flaky tests or shared data, which cause failures. These ensure reliable web app flows.",
                          "examples": [
                            "// Playwright test\nimport { test } from '@playwright/test';\ntest('login flow', async ({ page }) => {\n  await page.goto('/login');\n  await page.fill('#username', 'user');\n  await page.fill('#password', 'pass');\n  await page.click('button');\n  await expect(page.locator('#dashboard')).toBeVisible();\n});",
                            "// Test data seeding\nconst db = require('db');\nawait db.query('INSERT INTO users (id, username) VALUES (1, \\'testuser\\')');"
                          ],
                          "realWorldApplication": "Used in web apps to test user journeys like checkout or signup.",
                          "expertInsights": "Parallelize with Playwright workers; isolate test data; retry flaky tests.",
                          "commonMistakes": [
                            "Using shared test data",
                            "Not parallelizing tests",
                            "Ignoring flakiness"
                          ],
                          "exercises": [
                            {
                              "title": "Create E2E Test with Playwright",
                              "prompt": "Write a Playwright test for a login flow with seeded test data.",
                              "difficulty": "medium",
                              "hints": [
                                "Use page.fill()",
                                "Seed DB before test"
                              ],
                              "solution": "import { test, expect } from '@playwright/test';\nimport { db } from './db';\ntest.beforeEach(async () => {\n  await db.query('INSERT INTO users (id, username, password) VALUES (1, \\'testuser\\', \\'testpass\\')');\n});\ntest('login flow', async ({ page }) => {\n  await page.goto('/login');\n  await page.fill('#username', 'testuser');\n  await page.fill('#password', 'testpass');\n  await page.click('button');\n  await expect(page.locator('#dashboard')).toBeVisible();\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does Playwright automate?",
                              "options": [
                                "API calls",
                                "Browser flows",
                                "Unit tests",
                                "Fuzzing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What speeds up E2E tests?",
                              "options": [
                                "Fuzzing",
                                "Parallelization",
                                "Contracts",
                                "Chaos"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks shared test data?",
                              "options": [
                                "Fast tests",
                                "Test failures",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "Playwright Documentation",
                              "url": "https://playwright.dev/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439477",
                        "title": "Chaos/Failure Injection Tests as Part of CI",
                        "slug": "chaos-testing",
                        "description": "Learn chaos testing and failure injection in CI pipelines.",
                        "order": 4,
                        "content": {
                          "explanation": "Chaos testing injects failures (e.g., Chaos Mesh kills pods) to test resilience. CI integration automates chaos (e.g., GitHub Actions runs Chaos Mesh). For example, simulate a pod failure to test failover. Advanced learners should add chaos to CI. Be cautious of uncontrolled failures or untested recovery, which risk outages. These ensure robust web systems.",
                          "examples": [
                            "# Chaos Mesh pod failure\napiVersion: chaos-mesh.org/v1alpha1\nkind: PodChaos\nmetadata:\n  name: pod-failure\nspec:\n  selector:\n    namespaces: ['default']\n  action: pod-kill\n  mode: one",
                            "# GitHub Action for chaos\nname: Chaos Test\non: [push]\njobs:\n  chaos:\n    runs-on: ubuntu-latest\n    steps:\n      - run: kubectl apply -f chaos.yaml"
                          ],
                          "realWorldApplication": "Used in web apps to test failover for APIs or databases.",
                          "expertInsights": "Start with small failures; integrate chaos in CI; verify recovery.",
                          "commonMistakes": [
                            "Injecting uncontrolled failures",
                            "Not testing recovery",
                            "Ignoring chaos results"
                          ],
                          "exercises": [
                            {
                              "title": "Add Chaos Test to CI",
                              "prompt": "Create a GitHub Action to run a Chaos Mesh pod failure test.",
                              "difficulty": "hard",
                              "hints": [
                                "Use Chaos Mesh YAML",
                                "Run kubectl in CI"
                              ],
                              "solution": "# .github/workflows/chaos.yml\nname: Chaos Test\non: [push]\njobs:\n  chaos:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v3\n      - run: kubectl apply -f chaos.yaml\n# chaos.yaml\napiVersion: chaos-mesh.org/v1alpha1\nkind: PodChaos\nmetadata:\n  name: pod-failure-test\nspec:\n  selector:\n    namespaces: ['default']\n    labelSelectors:\n      app: my-app\n  action: pod-kill\n  mode: one"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does chaos testing verify?",
                              "options": [
                                "UI",
                                "Resilience",
                                "Contracts",
                                "Fuzzing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What automates chaos in CI?",
                              "options": [
                                "Playwright",
                                "Chaos Mesh",
                                "Pact",
                                "fast-check"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks uncontrolled chaos?",
                              "options": [
                                "Fast recovery",
                                "Outages",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "Chaos Mesh Documentation",
                              "url": "https://chaos-mesh.org/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439478",
                        "title": "Test Observability: Flakiness Detection, Automatic Retry/Backoff",
                        "slug": "test-observability",
                        "description": "Learn test observability with flakiness detection and retry strategies.",
                        "order": 5,
                        "content": {
                          "explanation": "Test observability monitors test reliability (e.g., track flaky tests with metrics). Flakiness detection identifies inconsistent tests. Automatic retries with backoff (e.g., exponential backoff) handle transient failures. For example, log flaky tests in CI. Advanced learners should implement observability. Be cautious of undetected flakes or infinite retries, which hide issues or slow CI. These ensure reliable testing.",
                          "examples": [
                            "// Flaky test detection\nconst { Gauge } = require('prom-client');\nconst flakyTests = new Gauge({ name: 'flaky_tests', help: 'Flaky test count' });\nif (testFailed) flakyTests.inc();",
                            "// Retry with backoff\nconst retry = async (fn, retries = 3, delay = 1000) => {\n  try { return await fn(); } catch (e) {\n    if (retries === 0) throw e;\n    await new Promise(res => setTimeout(res, delay));\n    return retry(fn, retries - 1, delay * 2);\n};"
                          ],
                          "realWorldApplication": "Used in CI to monitor test suites for web apps and reduce flaky failures.",
                          "expertInsights": "Track flakes with metrics; use exponential backoff; limit retries.",
                          "commonMistakes": [
                            "Not tracking flakiness",
                            "Infinite retries",
                            "Ignoring transient failures"
                          ],
                          "exercises": [
                            {
                              "title": "Add Test Retry Strategy",
                              "prompt": "Create a test with retry and flakiness metrics using Jest and Prometheus.",
                              "difficulty": "medium",
                              "hints": [
                                "Use exponential backoff",
                                "Track flakes with Gauge"
                              ],
                              "solution": "const { Gauge } = require('prom-client');\nconst flakyTests = new Gauge({ name: 'flaky_tests_total', help: 'Flaky test count' });\nasync function retry(fn, retries = 3, delay = 1000) {\n  try { return await fn(); } catch (e) {\n    if (retries === 0) throw e;\n    flakyTests.inc();\n    await new Promise(res => setTimeout(res, delay));\n    return retry(fn, retries - 1, delay * 2);\n}\n}\ntest('flaky API call', async () => {\n  await retry(async () => {\n    const res = await fetch('/api');\n    expect(res.status).toBe(200);\n  });\n});"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does test observability monitor?",
                              "options": [
                                "UI",
                                "Test reliability",
                                "Contracts",
                                "Fuzzing"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What handles transient failures?",
                              "options": [
                                "Fuzzing",
                                "Retries with backoff",
                                "Contracts",
                                "Chaos"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks infinite retries?",
                              "options": [
                                "Fast CI",
                                "Slow CI",
                                "Caching",
                                "Security"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 90,
                          "resources": [
                            {
                              "title": "Jest Retry Patterns",
                              "url": "https://jestjs.io/docs/",
                              "type": "doc"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T22:09:00Z",
      "version": "1.0"
    }
  },
  {
    "learningModuleId": "507f1f77bcf86cd799439480",
    "title": "Final Capstone: Real-World, Production-Grade System",
    "slug": "final-capstone-real-world-system",
    "domains": [
      {
        "domainId": "507f1f77bcf86cd799439481",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Integrate all learned concepts to build, deploy, monitor, and operate a production-grade full-stack web system.",
        "courses": [
          {
            "courseId": "507f1f77bcf86cd799439482",
            "title": "Final Capstone: Real-World, Production-Grade System",
            "slug": "final-capstone-real-world-system",
            "shortDescription": "An advanced capstone course to build, deploy, and operate a real-world production-grade system combining all learnings.",
            "longDescription": "This capstone course guides you through building a complete production-grade system, such as a SaaS task platform or e-commerce microservices, incorporating authentication, multi-tenancy, realtime features, billing, monitoring, IaC, CI/CD, and more, with assessment based on architecture, tests, performance, security, and deployment.",
            "tags": [
              "Capstone",
              "Full-Stack",
              "SaaS",
              "Microservices",
              "Web Development",
              "Advanced"
            ],
            "thumbnail": "https://example.com/thumbnails/final-capstone.jpg",
            "levels": [
              {
                "level": "Advanced",
                "overview": "This advanced capstone level focuses on combining all course concepts to build and operate a production-grade full-stack system.",
                "goals": [
                  "Design and build a SaaS task platform or e-commerce microservices project",
                  "Implement features like auth, multi-tenancy, realtime notifications, billing, monitoring, and SLOs",
                  "Use Terraform for IaC, CI/CD with canaries, and chaos tests",
                  "Meet deliverables including architecture doc, threat model, tests, performance, security, and deployment"
                ],
                "modules": [
                  {
                    "moduleId": "507f1f77bcf86cd799439483",
                    "title": "Final Capstone: Real-World, Production-Grade System",
                    "slug": "final-capstone-real-world-system",
                    "description": "Build, deploy, monitor, and operate a real product combining all learnings in a production-grade system.",
                    "order": 1,
                    "lessons": [
                      {
                        "lessonId": "507f1f77bcf86cd799439484",
                        "title": "Project Overview and Goal",
                        "slug": "project-overview-goal",
                        "description": "Understand the capstone project goal and options for a production-grade system.",
                        "order": 1,
                        "content": {
                          "explanation": "The capstone project integrates all concepts to build a production-grade system, such as a SaaS task platform with auth, multi-tenancy, realtime notifications, billing (Stripe sandbox), monitoring & SLOs, Terraform infra, and CI/CD with canaries, or an e-commerce microservices system with inventory, event-sourced orders, payment integration, search, analytics pipeline, horizontal scaling, and chaos tests. The goal is to apply learnings in a real-world context, demonstrating proficiency in full-stack development. Advanced learners should choose a project, plan architecture, and align with the rubric. Be cautious of scope creep or neglecting key areas like security. This overview sets the foundation for a successful capstone.",
                          "examples": [
                            "// Project planning\n- Select option: SaaS Task Platform\n- Features: Auth, multi-tenant, realtime (Socket.IO), billing (Stripe), monitoring (Prometheus), IaC (Terraform), CI/CD (GitHub Actions)\n- Architecture: React frontend, Node.js backend, Postgres DB"
                          ],
                          "realWorldApplication": "Applies to building scalable SaaS products or e-commerce platforms in production environments.",
                          "expertInsights": "Choose a project aligning with your interests; document architecture and threat model; focus on rubric categories.",
                          "commonMistakes": [
                            "Over-scoping the project beyond time limits",
                            "Neglecting integration of advanced concepts like realtime or chaos testing",
                            "Not planning for deployment and monitoring early"
                          ],
                          "exercises": [
                            {
                              "title": "Plan Capstone Project",
                              "prompt": "Outline the architecture, features, and tech stack for your chosen capstone project option.",
                              "difficulty": "hard",
                              "hints": [
                                "Include auth, realtime, billing, monitoring",
                                "Use Terraform for IaC, CI/CD with canaries"
                              ],
                              "solution": "// Outline for SaaS Task Platform\nTech Stack:\n- Frontend: React, Next.js\n- Backend: Node.js, Express\n- Database: Postgres with multi-tenant schema\n- Auth: NextAuth with OIDC\n- Realtime: Socket.IO\n- Billing: Stripe sandbox\n- Monitoring: Prometheus, Grafana, SLOs\n- IaC: Terraform for RDS, ECS\n- CI/CD: GitHub Actions with canary rollouts\n- Chaos: Chaos Mesh for testing\nFeatures:\n- Multi-tenant task creation\n- Realtime notifications\n- Billing subscriptions\n- Monitoring dashboards"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What is the capstone's primary goal?",
                              "options": [
                                "Theory review",
                                "Integrate learnings",
                                "Basic project",
                                "Deployment only"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does the SaaS project include?",
                              "options": [
                                "Auth and realtime",
                                "Single-tenant only",
                                "No billing",
                                "Manual deployment"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What does e-commerce microservices use?",
                              "options": [
                                "Event-sourcing",
                                "Monolith",
                                "No scaling",
                                "Manual tests"
                              ],
                              "correctOption": [0]
                            },
                            {
                              "question": "What is a rubric category?",
                              "options": [
                                "Architecture doc",
                                "Colors",
                                "Fonts",
                                "Logs"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 360,
                          "resources": [
                            {
                              "title": "SaaS Architecture Guide",
                              "url": "https://www.example.com/saas-guide",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439475",
                        "title": "SaaS Task Platform Project",
                        "slug": "saas-task-platform",
                        "description": "Build a multi-tenant SaaS task platform with auth, realtime, billing, and more.",
                        "order": 2,
                        "content": {
                          "explanation": "The SaaS task platform is a multi-tenant app with auth (OIDC), realtime notifications (Socket.IO), persistence (Postgres), offline support (CRDTs), billing (Stripe sandbox), monitoring & SLOs, Terraform infra, and CI/CD with canaries. Advanced learners should implement all features, focusing on multi-tenancy and realtime. Be cautious of data isolation or billing errors. This project demonstrates full-stack mastery.",
                          "examples": [
                            "// Multi-tenant auth with NextAuth\nNextAuth({\n  providers: [GoogleProvider(...)],\n  callbacks: { jwt: ({ token, user }) => ({ ...token, tenantId: user.tenantId }) }\n});",
                            "// Realtime with Socket.IO\nio.on('connection', (socket) => {\n  socket.on('taskUpdate', (task) => io.to(task.tenantId).emit('taskUpdated', task));\n});"
                          ],
                          "realWorldApplication": "Similar to Asana or Trello for collaborative task management in SaaS.",
                          "expertInsights": "Isolate tenants with schema-per-tenant; use CRDTs for offline; monitor SLOs.",
                          "commonMistakes": [
                            "Not isolating tenant data",
                            "Forgetting offline sync",
                            "Ignoring SLO monitoring"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Multi-Tenant Feature",
                              "prompt": "Add tenant isolation to a task creation endpoint.",
                              "difficulty": "hard",
                              "hints": [
                                "Use tenant_id in DB",
                                "Filter by tenant in queries"
                              ],
                              "solution": "app.post('/tasks', async (req, res) => {\n  const { tenantId } = req.user;\n  const task = req.body;\n  await db.query('INSERT INTO tasks (tenant_id, task) VALUES ($1, $2)', [tenantId, task]);\n  res.json({ success: true });\n});\n// Query\nawait db.query('SELECT * FROM tasks WHERE tenant_id = $1', [tenantId]);"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What provides offline support?",
                              "options": ["CRDTs", "Billing", "SLOs", "CI/CD"],
                              "correctOption": [0]
                            },
                            {
                              "question": "What handles billing?",
                              "options": [
                                "Socket.IO",
                                "Stripe",
                                "Postgres",
                                "Terraform"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What ensures tenant isolation?",
                              "options": [
                                "Tenant_id",
                                "Realtime",
                                "Billing",
                                "SLOs"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 720,
                          "resources": [
                            {
                              "title": "Stripe Integration Guide",
                              "url": "https://stripe.com/docs/development",
                              "type": "doc"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439476",
                        "title": "E-commerce Microservices Project",
                        "slug": "ecommerce-microservices",
                        "description": "Build e-commerce microservices with inventory, orders, payment, search, and more.",
                        "order": 3,
                        "content": {
                          "explanation": "The e-commerce microservices project includes inventory (stock management), orders (event-sourced), payment integration (Stripe sandbox), search (Elasticsearch), analytics pipeline, horizontal scaling, and chaos tests. Advanced learners should implement all features, focusing on event-sourcing and scaling. Be cautious of data consistency or untested chaos. This project demonstrates distributed systems mastery.",
                          "examples": [
                            "// Event-sourced order\nconst events = [{ type: 'OrderPlaced', data: { id: 1, item: 'book' } }];\nconst state = events.reduce((state, e) => ({ ...state, ...e.data }), {});",
                            "// Stripe payment\nawait stripe.charges.create({ amount: 1000, currency: 'usd', source: 'tok_visa' });"
                          ],
                          "realWorldApplication": "Similar to Shopify or Amazon for product inventory and order processing.",
                          "expertInsights": "Use event-sourcing for orders; integrate Stripe sandbox; scale with Kubernetes.",
                          "commonMistakes": [
                            "Not handling event replay",
                            "Forcing real payments",
                            "Ignoring chaos test results"
                          ],
                          "exercises": [
                            {
                              "title": "Implement Event-Sourced Order",
                              "prompt": "Create an event-sourced order system with events for placing and shipping.",
                              "difficulty": "hard",
                              "hints": [
                                "Store events in array",
                                "Rebuild state with reduce"
                              ],
                              "solution": "let events = [];\nfunction placeOrder(id, item) {\n  events.push({ type: 'OrderPlaced', data: { id, item, timestamp: Date.now() } });\n}\nfunction shipOrder(id, date) {\n  events.push({ type: 'OrderShipped', data: { id, date, timestamp: Date.now() } });\n}\nfunction getOrderState(id) {\n  return events\n    .filter(e => e.data.id === id)\n    .reduce((state, e) => ({ ...state, ...e.data }), {});\n}\nplaceOrder(1, 'book');\nshipOrder(1, '2025-09-15');\nconsole.log(getOrderState(1));"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What does event-sourcing store?",
                              "options": [
                                "State",
                                "Events",
                                "Payments",
                                "Search"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What handles payments?",
                              "options": [
                                "Elasticsearch",
                                "Stripe",
                                "Chaos Mesh",
                                "Terraform"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What tests system resilience?",
                              "options": [
                                "Chaos tests",
                                "Billing",
                                "Realtime",
                                "SLOs"
                              ],
                              "correctOption": [0]
                            }
                          ],
                          "estimatedTime": 720,
                          "resources": [
                            {
                              "title": "Event Sourcing Guide",
                              "url": "https://martinfowler.com/eaaDev/EventSourcing.html",
                              "type": "article"
                            }
                          ]
                        }
                      },
                      {
                        "lessonId": "507f1f77bcf86cd799439477",
                        "title": "Deliverables & Rubric",
                        "slug": "deliverables-rubric",
                        "description": "Understand the capstone deliverables and assessment rubric.",
                        "order": 4,
                        "content": {
                          "explanation": "The capstone deliverables include architecture doc + threat model (20%), tests & CI (20%), performance & SLOs (15%), security hardening (15%), infra-as-code + deploy (15%), and working demo + README (15%). The rubric assesses completeness and quality in each category. Advanced learners should align their project with the rubric, documenting thoroughly. Be cautious of unbalanced focus or missing deliverables, which lower scores. This rubric ensures comprehensive evaluation.",
                          "examples": [
                            "// Rubric breakdown\nArchitecture Doc & Threat Model: 20% - Detailed design with STRIDE analysis\nTests & CI: 20% - Unit, integration, E2E tests with CI pipeline\nPerformance & SLOs: 15% - Optimized latency with defined SLOs\nSecurity Hardening: 15% - Auth, encryption, secure headers\nIaC + Deploy: 15% - Terraform for infra, CI/CD deployment\nDemo + README: 15% - Working app with setup guide"
                          ],
                          "realWorldApplication": "Similar to professional project reviews or portfolio assessments.",
                          "expertInsights": "Document everything; test against rubric; prioritize high-weight categories.",
                          "commonMistakes": [
                            "Incomplete architecture doc",
                            "Skipping tests or CI",
                            "Not addressing rubric fully"
                          ],
                          "exercises": [
                            {
                              "title": "Self-Assess Capstone",
                              "prompt": "Self-assess your capstone project against the rubric, assigning scores.",
                              "difficulty": "medium",
                              "hints": [
                                "Review each category",
                                "Note strengths/weaknesses"
                              ],
                              "solution": "// Self-Assessment\nArchitecture Doc & Threat Model: 18/20 - Detailed but missing some threats\nTests & CI: 19/20 - Comprehensive tests with CI\nPerformance & SLOs: 14/15 - Optimized with SLOs\nSecurity Hardening: 13/15 - Secure but missing some headers\nIaC + Deploy: 15/15 - Full Terraform and CI/CD\nDemo + README: 14/15 - Working demo with README\nTotal: 93/100"
                            }
                          ],
                          "quiz": [
                            {
                              "question": "What has the highest rubric weight?",
                              "options": [
                                "Architecture",
                                "Tests & CI",
                                "Performance",
                                "Demo"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What does the rubric assess?",
                              "options": [
                                "Colors",
                                "Completeness/quality",
                                "Fonts",
                                "Logs"
                              ],
                              "correctOption": [1]
                            },
                            {
                              "question": "What risks low scores?",
                              "options": [
                                "Balanced focus",
                                "Missing deliverables",
                                "Documentation",
                                "Testing"
                              ],
                              "correctOption": [1]
                            }
                          ],
                          "estimatedTime": 180,
                          "resources": [
                            {
                              "title": "Project Rubric Example",
                              "url": "https://www.example.com/project-rubric",
                              "type": "article"
                            }
                          ]
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ],
    "meta": {
      "generatedAt": "2025-09-15T22:12:00Z",
      "version": "1.0"
    }
  }
]
