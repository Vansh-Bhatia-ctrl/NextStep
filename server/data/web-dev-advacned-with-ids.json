[
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master advanced JavaScript concepts, runtime behavior, and performance optimizations for building robust, high-performance systems.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b1b"
      }
    ],
    "courses": [
      {
        "title": "Advanced JavaScript & Runtime Mastery",
        "slug": "advanced-js-runtime",
        "shortDescription": "An advanced course on mastering JavaScript internals, runtime behavior, and performance optimizations for robust systems.",
        "level": "Advanced",
        "longDescription": "This course dives deep into JavaScript internals and runtime behavior, covering V8 engine mechanics, async programming patterns, memory management, performance optimizations, and advanced coding techniques. Through hands-on exercises, real-world examples, and quizzes, you’ll profile and fix memory leaks, implement cancellable async operations, and apply metaprogramming patterns. The course prepares you to build high-performance, scalable JavaScript applications.",
        "tags": [
          "javascript",
          "v8",
          "async",
          "memory",
          "performance",
          "metaprogramming"
        ],
        "thumbnail": "https://example.com/thumbnails/advanced-js-runtime.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Master JavaScript internals, runtime behavior, and performance optimizations for robust systems.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b1c",
        "domainId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b1b"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Advanced JavaScript & Runtime Mastery",
        "slug": "advanced-js-runtime",
        "description": "Master JavaScript engine internals, advanced async patterns, memory management, performance optimizations, and metaprogramming techniques.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b1d",
        "courseId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b1c",
        "lessonIds": [
          "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b1e",
          "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b1f",
          "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b20",
          "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b21",
          "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b22"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "JavaScript Engine Internals",
        "slug": "js-engine-internals",
        "description": "Explore V8 engine mechanics, event loop, and microtasks vs. macrotasks.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b1e",
        "moduleId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b1d",
        "contentId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b23"
      },
      {
        "level": "Advanced",
        "title": "Advanced Async Programming",
        "slug": "advanced-async",
        "description": "Master cancellation, AbortController, observable patterns, and stream APIs.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b1f",
        "moduleId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b1d",
        "contentId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b24"
      },
      {
        "level": "Advanced",
        "title": "Memory Model & GC Tuning",
        "slug": "memory-gc-tuning",
        "description": "Understand JavaScript memory model, garbage collection, memory leaks, and profiling.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b20",
        "moduleId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b1d",
        "contentId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b25"
      },
      {
        "level": "Advanced",
        "title": "Performance Patterns & Optimizations",
        "slug": "performance-patterns",
        "description": "Apply TypedArrays, structured cloning, and low-level optimizations for performance.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b21",
        "moduleId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b1d",
        "contentId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b26"
      },
      {
        "level": "Advanced",
        "title": "Advanced Patterns: Proxies & Metaprogramming",
        "slug": "proxies-metaprogramming",
        "description": "Implement proxies, metaprogramming, and code generation for advanced JavaScript patterns.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b22",
        "moduleId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b1d",
        "contentId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b27"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "The V8 engine powers JavaScript execution in browsers and Node.js. Understanding the event loop, microtasks (Promises), and macrotasks (setTimeout) is key to predicting runtime behavior. This lesson explores V8’s compilation pipeline, call stack, and task queues for writing robust code.",
        "examples": [
          "setTimeout(() => console.log('macrotask'), 0); Promise.resolve().then(() => console.log('microtask'));",
          "V8 JIT: Compiles JS to machine code for faster execution."
        ],
        "realWorldApplication": "Event loop knowledge prevents UI freezes in browsers and optimizes server-side Node.js apps like real-time APIs.",
        "expertInsights": "Microtasks run before macrotasks; use this to prioritize critical async code. Profile V8 performance with Chrome DevTools.",
        "commonMistakes": [
          "Assuming setTimeout(..., 0) runs instantly.",
          "Overloading microtask queue, blocking rendering."
        ],
        "exercises": [
          {
            "title": "Analyze Event Loop",
            "prompt": "Write code with setTimeout and Promises, then predict the output order.",
            "difficulty": "medium",
            "hints": [
              "Microtasks run before macrotasks",
              "Use console.log to trace"
            ],
            "solution": "code.js: console.log('start'); setTimeout(() => console.log('timeout'), 0); Promise.resolve().then(() => console.log('promise')); console.log('end');\n// Output: start, end, promise, timeout"
          }
        ],
        "quiz": [
          {
            "question": "Which runs first in the event loop?",
            "options": [
              "Macrotasks",
              "Microtasks",
              "setInterval",
              "setTimeout"
            ],
            "correctOption": [1]
          },
          {
            "question": "What powers JavaScript in Chrome?",
            "options": ["V8", "SpiderMonkey", "Chakra", "Rhino"],
            "correctOption": [0]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "JavaScript Event Loop — MDN",
            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b23",
        "lessonId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b1e"
      },
      {
        "level": "Advanced",
        "explanation": "Advanced async programming includes cancellation with AbortController, observable patterns for reactive data, and stream APIs for processing large datasets. These tools enable robust, interruptible, and efficient async workflows in JavaScript.",
        "examples": [
          "AbortController: const controller = new AbortController(); fetch(url, { signal: controller.signal });",
          "Observable: RxJS Observable.subscribe(data => console.log(data));"
        ],
        "realWorldApplication": "Used in real-time dashboards (e.g., stock trading apps) and cancellable API calls in SPAs like Gmail.",
        "expertInsights": "Use AbortController for all fetch requests. Observables are powerful for event streams but add complexity; evaluate vs. Promises.",
        "commonMistakes": [
          "Not cleaning up async resources, causing leaks.",
          "Mixing Promise and Observable patterns unnecessarily."
        ],
        "exercises": [
          {
            "title": "Implement Cancellable Fetch",
            "prompt": "Create a cancellable fetch wrapper using AbortController.",
            "difficulty": "medium",
            "hints": ["Use AbortController.signal", "Handle abort errors"],
            "solution": "fetchWrapper.js: async function fetchWithCancel(url) { const controller = new AbortController(); setTimeout(() => controller.abort(), 5000); try { const response = await fetch(url, { signal: controller.signal }); return await response.json(); } catch (e) { if (e.name === 'AbortError') throw new Error('Request cancelled'); throw e; } }"
          }
        ],
        "quiz": [
          {
            "question": "What cancels a fetch request?",
            "options": [
              "setTimeout",
              "AbortController",
              "Promise.reject",
              "Observable"
            ],
            "correctOption": [1]
          },
          {
            "question": "What is best for reactive event streams?",
            "options": [
              "Promises",
              "Observables",
              "setInterval",
              "async/await"
            ],
            "correctOption": [1]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "AbortController — MDN",
            "url": "https://developer.mozilla.org/en-US/docs/Web/API/AbortController",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b24",
        "lessonId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b1f"
      },
      {
        "level": "Advanced",
        "explanation": "JavaScript’s memory model uses heap and stack; garbage collection (GC) reclaims unused memory. Memory leaks occur from lingering references. Profiling with DevTools helps identify and fix leaks. This lesson covers heap snapshots, GC tuning, and memory-efficient coding.",
        "examples": [
          "Leak: let arr = []; setInterval(() => arr.push({}), 1000);",
          "Fix: Clear array or stop interval."
        ],
        "realWorldApplication": "Memory management is critical in Node.js servers (e.g., API backends) and browser apps with long sessions like editors.",
        "expertInsights": "Take heap snapshots regularly. Avoid global variables and ensure event listeners are removed.",
        "commonMistakes": [
          "Not removing event listeners, causing leaks.",
          "Ignoring large object allocations in loops."
        ],
        "exercises": [
          {
            "title": "Profile and Fix Memory Leak",
            "prompt": "Identify and fix a memory leak in a sample app using Chrome DevTools.",
            "difficulty": "hard",
            "hints": [
              "Use Heap Snapshot in DevTools",
              "Check for growing arrays or listeners"
            ],
            "solution": "leak.js: let listeners = []; function addListener() { const obj = {}; listeners.push(obj); document.addEventListener('click', () => console.log(obj)); } // Fix: document.removeEventListener('click', handler); listeners = [];"
          }
        ],
        "quiz": [
          {
            "question": "What causes memory leaks?",
            "options": [
              "Small arrays",
              "Lingering references",
              "Fast GC",
              "Promises"
            ],
            "correctOption": [1]
          },
          {
            "question": "What tool profiles memory in Chrome?",
            "options": [
              "Network panel",
              "Heap Snapshot",
              "Console",
              "Elements"
            ],
            "correctOption": [1]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "JavaScript Memory Management — MDN",
            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b25",
        "lessonId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b20"
      },
      {
        "level": "Advanced",
        "explanation": "Performance patterns like TypedArrays and structured cloning optimize data handling for speed. TypedArrays (e.g., Int32Array) provide low-level memory access, while structured cloning ensures efficient data copying. This lesson covers their use for high-performance apps.",
        "examples": [
          "TypedArray: const buffer = new Int32Array([1, 2, 3]);",
          "Structured Clone: structuredClone({ data: complexObj });"
        ],
        "realWorldApplication": "Used in WebGL apps (games) and Node.js for processing large datasets efficiently.",
        "expertInsights": "Use TypedArrays for numerical data. Structured cloning is faster than JSON for complex objects.",
        "commonMistakes": [
          "Using regular arrays for large datasets, slowing performance.",
          "Not testing cloning performance with large objects."
        ],
        "exercises": [
          {
            "title": "Optimize with TypedArrays",
            "prompt": "Convert an array-based computation to use TypedArrays for better performance.",
            "difficulty": "medium",
            "hints": [
              "Use Int32Array for integers",
              "Measure performance with console.time"
            ],
            "solution": "optimize.js: const arr = new Array(1000000).fill(1); console.time('array'); arr.map(x => x * 2); console.timeEnd('array'); const typed = new Int32Array(1000000).fill(1); console.time('typed'); typed.map(x => x * 2); console.timeEnd('typed');"
          }
        ],
        "quiz": [
          {
            "question": "What optimizes numerical data handling?",
            "options": ["Regular arrays", "TypedArrays", "Promises", "Objects"],
            "correctOption": [1]
          },
          {
            "question": "What is faster than JSON for copying complex objects?",
            "options": [
              "JSON.parse",
              "Structured cloning",
              "Stringify",
              "eval"
            ],
            "correctOption": [1]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Typed Arrays — MDN",
            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b26",
        "lessonId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b21"
      },
      {
        "level": "Advanced",
        "explanation": "Proxies and metaprogramming enable dynamic behavior, like intercepting property access or generating code. Proxies wrap objects to customize operations, while code generation builds dynamic logic. This lesson covers proxies, Reflect API, and code generation techniques.",
        "examples": [
          "Proxy: const handler = { get: (target, prop) => target[prop] || 'default' }; const obj = new Proxy({}, handler);",
          "Codegen: eval('function generated() { return 42; }');"
        ],
        "realWorldApplication": "Proxies are used in Vue.js reactivity; code generation powers tools like Babel or Webpack.",
        "expertInsights": "Use proxies for reactive systems. Avoid eval for codegen due to security; prefer safer alternatives like Function constructor.",
        "commonMistakes": [
          "Overusing proxies, slowing performance.",
          "Using eval unsafely, risking injection."
        ],
        "exercises": [
          {
            "title": "Implement a Proxy",
            "prompt": "Create a proxy to log property access and handle missing properties.",
            "difficulty": "hard",
            "hints": ["Use get trap", "Return default for undefined props"],
            "solution": "proxy.js: const handler = { get: (target, prop) => { console.log(`Accessed: ${prop}`); return target[prop] ?? 'default'; } }; const obj = new Proxy({ a: 1 }, handler); console.log(obj.a); console.log(obj.b);"
          }
        ],
        "quiz": [
          {
            "question": "What do proxies intercept?",
            "options": [
              "UI events",
              "Property access",
              "Database queries",
              "Network requests"
            ],
            "correctOption": [1]
          },
          {
            "question": "What is a safer alternative to eval?",
            "options": [
              "JSON.parse",
              "Function constructor",
              "setTimeout",
              "Promise"
            ],
            "correctOption": [1]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Proxy API — MDN",
            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b27",
        "lessonId": "7f9c8b2a4b7e4c8fa6d39e8d2f5c6b22"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master advanced TypeScript and type systems to architect large, type-safe codebases for client and server applications.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e6f"
      }
    ],
    "courses": [
      {
        "title": "Advanced TypeScript & Type Systems",
        "slug": "advanced-typescript-types",
        "shortDescription": "An advanced course on architecting large, type-safe TypeScript codebases with strict configurations, advanced types, generics, type-safe APIs, and migrations.",
        "level": "Advanced",
        "longDescription": "This course dives deep into TypeScript’s advanced features and type systems, covering strict configurations, advanced types, generics at scale, type-safe API contracts with zod/io-ts, and strategies for migrating large codebases. Through hands-on exercises, real-world examples, and quizzes, you’ll design shared types, create zod schemas, and generate OpenAPI types. The course equips you to build robust, type-safe applications for both client and server environments.",
        "tags": [
          "typescript",
          "type-systems",
          "generics",
          "api-contracts",
          "zod",
          "codegen",
          "migrations"
        ],
        "thumbnail": "https://example.com/thumbnails/advanced-typescript.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Architect large, type-safe TypeScript codebases with advanced types, generics, API contracts, and migrations.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e70",
        "domainId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e6f"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Advanced TypeScript & Type Systems",
        "slug": "advanced-typescript-types",
        "description": "Master strict TypeScript configurations, advanced types, generics, type-safe APIs, and codebase migrations for scalable applications.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e71",
        "courseId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e70",
        "lessonIds": [
          "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e72",
          "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e73",
          "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e74",
          "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e75",
          "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e76"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "Strict Configurations and Project References",
        "slug": "strict-configs-project-references",
        "description": "Configure strict TypeScript settings, project references, and composite builds for large codebases.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e72",
        "moduleId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e71",
        "contentId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e77"
      },
      {
        "level": "Advanced",
        "title": "Advanced Types",
        "slug": "advanced-types",
        "description": "Master mapped types, conditional types, infer, and template literal types for robust type systems.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e73",
        "moduleId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e71",
        "contentId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e78"
      },
      {
        "level": "Advanced",
        "title": "Generics at Scale",
        "slug": "generics-at-scale",
        "description": "Implement generics for polymorphic components and conditional props in large applications.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e74",
        "moduleId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e71",
        "contentId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e79"
      },
      {
        "level": "Advanced",
        "title": "Type-Safe API Contracts",
        "slug": "type-safe-api-contracts",
        "description": "Build type-safe APIs with zod/io-ts and generate OpenAPI/GraphQL schemas.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e75",
        "moduleId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e71",
        "contentId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e7a"
      },
      {
        "level": "Advanced",
        "title": "Migrating Large Codebases & Runtime Type Checks",
        "slug": "codebase-migration-runtime-checks",
        "description": "Migrate JavaScript codebases to TypeScript and implement runtime type checks.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e76",
        "moduleId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e71",
        "contentId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e7b"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "TypeScript’s strict configurations and project references enable scalable, maintainable codebases. Strict settings enforce type safety, while project references and composite builds optimize large monorepos. This lesson covers configuring tsconfig.json and structuring projects for efficiency.",
        "examples": [
          "tsconfig.json: { \"strict\": true, \"noImplicitAny\": true }",
          "Project Reference: { \"references\": [{ \"path\": \"../shared\" }] }"
        ],
        "realWorldApplication": "Used in large-scale apps like VS Code and Angular to manage complex TypeScript projects.",
        "expertInsights": "Enable strict mode for safety. Use project references for faster builds in monorepos.",
        "commonMistakes": [
          "Disabling strict checks, reducing type safety.",
          "Not splitting large projects, slowing compiles."
        ],
        "exercises": [
          {
            "title": "Configure a Monorepo",
            "prompt": "Set up a TypeScript monorepo with strict configs and project references.",
            "difficulty": "medium",
            "hints": [
              "Enable strict in tsconfig",
              "Add references for shared code"
            ],
            "solution": "tsconfig.json: { \"compilerOptions\": { \"strict\": true, \"noImplicitAny\": true, \"composite\": true }, \"references\": [{ \"path\": \"../shared\" }] }\nshared/tsconfig.json: { \"compilerOptions\": { \"composite\": true, \"outDir\": \"dist\" } }"
          }
        ],
        "quiz": [
          {
            "question": "What enforces type safety in TypeScript?",
            "options": ["Loose configs", "Strict mode", "JavaScript", "CSS"],
            "correctOption": [1]
          },
          {
            "question": "What optimizes monorepo builds?",
            "options": [
              "Project references",
              "Inline types",
              "Dynamic imports",
              "eval"
            ],
            "correctOption": [0]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "TypeScript Handbook — Project References",
            "url": "https://www.typescriptlang.org/docs/handbook/project-references.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e77",
        "lessonId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e72"
      },
      {
        "level": "Advanced",
        "explanation": "Advanced TypeScript types like mapped, conditional, infer, and template literal types enable expressive, reusable type systems. This lesson covers creating flexible types for complex scenarios, ensuring type safety without excessive boilerplate.",
        "examples": [
          "Mapped: type Keys = { [K in keyof T]: string };",
          "Conditional: type NonNullable<T> = T extends null | undefined ? never : T;"
        ],
        "realWorldApplication": "Used in libraries like React and Apollo Client for type-safe component props and queries.",
        "expertInsights": "Use infer for dynamic type extraction. Template literal types are great for string-based APIs.",
        "commonMistakes": [
          "Overusing any, losing type safety.",
          "Writing complex types without utility types."
        ],
        "exercises": [
          {
            "title": "Create a Mapped Type",
            "prompt": "Define a mapped type to convert object values to strings.",
            "difficulty": "medium",
            "hints": ["Use keyof and in", "Map to string type"],
            "solution": "types.ts: type Stringify<T> = { [K in keyof T]: string }; const example: Stringify<{ a: number, b: boolean }> = { a: '1', b: 'true' };"
          }
        ],
        "quiz": [
          {
            "question": "What creates dynamic types from keys?",
            "options": ["Conditional types", "Mapped types", "Generics", "Any"],
            "correctOption": [1]
          },
          {
            "question": "What extracts types dynamically?",
            "options": ["infer", "keyof", "extends", "typeof"],
            "correctOption": [0]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "TypeScript Advanced Types",
            "url": "https://www.typescriptlang.org/docs/handbook/2/types-from-types.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e78",
        "lessonId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e73"
      },
      {
        "level": "Advanced",
        "explanation": "Generics enable reusable, type-safe code for polymorphic components and conditional props. This lesson covers designing generics for large-scale apps, ensuring flexibility and type safety in React components or server-side logic.",
        "examples": [
          "Generic Component: function Component<T>(props: { data: T }) {}",
          "Conditional Props: type Props<T> = T extends string ? { text: T } : { value: T };"
        ],
        "realWorldApplication": "Used in React libraries like Material-UI and server-side frameworks like NestJS for type-safe APIs.",
        "expertInsights": "Keep generics constrained for clarity. Use conditional props for dynamic component APIs.",
        "commonMistakes": [
          "Overcomplicating generics, reducing readability.",
          "Not constraining generics, causing type errors."
        ],
        "exercises": [
          {
            "title": "Design a Generic Component",
            "prompt": "Create a generic React component with conditional props based on input type.",
            "difficulty": "hard",
            "hints": [
              "Use extends for constraints",
              "Define conditional props"
            ],
            "solution": "component.tsx: type Props<T> = T extends string ? { text: T } : { value: T }; function GenericComponent<T>(props: Props<T>) { return <div>{'text' in props ? props.text : String(props.value)}</div>; } const App = () => <GenericComponent text=\"hello\" />;"
          }
        ],
        "quiz": [
          {
            "question": "What enables reusable type-safe code?",
            "options": ["Any", "Generics", "Interfaces", "Enums"],
            "correctOption": [1]
          },
          {
            "question": "What constrains generic types?",
            "options": ["extends", "implements", "keyof", "typeof"],
            "correctOption": [0]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "TypeScript Generics",
            "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e79",
        "lessonId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e74"
      },
      {
        "level": "Advanced",
        "explanation": "Type-safe API contracts with zod or io-ts ensure runtime validation and type safety. Codegen from OpenAPI or GraphQL schemas automates type generation. This lesson covers defining schemas, validating APIs, and generating types for client/server consistency.",
        "examples": [
          "Zod: const UserSchema = z.object({ id: z.string(), name: z.string() });",
          "OpenAPI Codegen: npx openapi-typescript openapi.json -o types.ts"
        ],
        "realWorldApplication": "Used in APIs for Stripe and Shopify to ensure type-safe client-server communication.",
        "expertInsights": "Use zod for simplicity, io-ts for functional programming. Generate types from schemas to avoid duplication.",
        "commonMistakes": [
          "Not validating inputs, causing runtime errors.",
          "Manually writing types instead of using codegen."
        ],
        "exercises": [
          {
            "title": "Design a Type-Safe API",
            "prompt": "Create a zod schema for a user API and generate OpenAPI types.",
            "difficulty": "hard",
            "hints": ["Define zod schema", "Use openapi-typescript"],
            "solution": "schema.ts: import { z } from 'zod'; const UserSchema = z.object({ id: z.string(), name: z.string() }); export type User = z.infer<typeof UserSchema>;\nopenapi.yaml: paths:\n  /users:\n    get:\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/User'\ncomponents:\n  schemas:\n    User:\n      type: object\n      properties:\n        id: { type: string }\n        name: { type: string }"
          }
        ],
        "quiz": [
          {
            "question": "What validates API inputs?",
            "options": ["CSS", "Zod", "GraphQL", "React"],
            "correctOption": [1]
          },
          {
            "question": "What automates type generation?",
            "options": ["Codegen", "eval", "Promises", "JSON"],
            "correctOption": [0]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Zod Documentation",
            "url": "https://zod.dev/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e7a",
        "lessonId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e75"
      },
      {
        "level": "Advanced",
        "explanation": "Migrating large JavaScript codebases to TypeScript requires incremental adoption and runtime type checks. This lesson covers strategies for gradual migration, adding types to existing code, and using runtime validation to catch errors in legacy systems.",
        "examples": [
          "Migration: Add .ts extension and basic types incrementally.",
          "Runtime: const validated = UserSchema.parse(data);"
        ],
        "realWorldApplication": "Used by companies like Airbnb and Dropbox to migrate legacy JavaScript to TypeScript.",
        "expertInsights": "Migrate one module at a time. Use any sparingly and refine types iteratively.",
        "commonMistakes": [
          "Overusing any, delaying type safety.",
          "Not testing runtime validation, missing errors."
        ],
        "exercises": [
          {
            "title": "Migrate JavaScript to TypeScript",
            "prompt": "Convert a JavaScript function to TypeScript with zod runtime validation.",
            "difficulty": "hard",
            "hints": [
              "Add type annotations",
              "Use zod.parse for runtime checks"
            ],
            "solution": "user.ts: import { z } from 'zod'; const UserSchema = z.object({ id: z.string(), name: z.string() }); type User = z.infer<typeof UserSchema>; function processUser(data: unknown): User { return UserSchema.parse(data); } // Original JS: function processUser(data) { return data; }"
          }
        ],
        "quiz": [
          {
            "question": "What enables gradual TypeScript adoption?",
            "options": ["eval", "Incremental migration", "CSS", "Promises"],
            "correctOption": [1]
          },
          {
            "question": "What catches runtime errors in migrations?",
            "options": [
              "Type annotations",
              "Zod parsing",
              "Generics",
              "Interfaces"
            ],
            "correctOption": [1]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "TypeScript Migration Guide",
            "url": "https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e7b",
        "lessonId": "9e4d7b2c1a3f4e9ab8c67f3a2d9c8e76"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  }
]
