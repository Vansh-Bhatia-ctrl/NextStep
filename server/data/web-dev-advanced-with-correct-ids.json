[
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master advanced JavaScript concepts, runtime behavior, and performance optimizations for building robust, high-performance systems.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf508"
      }
    ],
    "courses": [
      {
        "title": "Advanced JavaScript & Runtime Mastery",
        "slug": "advanced-js-runtime",
        "shortDescription": "An advanced course on mastering JavaScript internals, runtime behavior, and performance optimizations for robust systems.",
        "level": "Advanced",
        "longDescription": "This course dives deep into JavaScript internals and runtime behavior, covering V8 engine mechanics, async programming patterns, memory management, performance optimizations, and advanced coding techniques. Through hands-on exercises, real-world examples, and quizzes, you’ll profile and fix memory leaks, implement cancellable async operations, and apply metaprogramming patterns. The course prepares you to build high-performance, scalable JavaScript applications.",
        "tags": [
          "javascript",
          "v8",
          "async",
          "memory",
          "performance",
          "metaprogramming"
        ],
        "thumbnail": "https://example.com/thumbnails/advanced-js-runtime.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Master JavaScript internals, runtime behavior, and performance optimizations for robust systems.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf509",
        "domainId": "68d1a7a6cd394e8cc4daf508"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Advanced JavaScript & Runtime Mastery",
        "slug": "advanced-js-runtime",
        "description": "Master JavaScript engine internals, advanced async patterns, memory management, performance optimizations, and metaprogramming techniques.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf50a",
        "courseId": "68d1a7a6cd394e8cc4daf509",
        "lessonIds": [
          "68d1a7a6cd394e8cc4daf50b",
          "68d1a7a6cd394e8cc4daf50c",
          "68d1a7a6cd394e8cc4daf50d",
          "68d1a7a6cd394e8cc4daf50e",
          "68d1a7a6cd394e8cc4daf50f"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "JavaScript Engine Internals",
        "slug": "js-engine-internals",
        "description": "Explore V8 engine mechanics, event loop, and microtasks vs. macrotasks.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf50b",
        "moduleId": "68d1a7a6cd394e8cc4daf50a",
        "contentId": "68d1a7a6cd394e8cc4daf510"
      },
      {
        "level": "Advanced",
        "title": "Advanced Async Programming",
        "slug": "advanced-async",
        "description": "Master cancellation, AbortController, observable patterns, and stream APIs.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf50c",
        "moduleId": "68d1a7a6cd394e8cc4daf50a",
        "contentId": "68d1a7a6cd394e8cc4daf511"
      },
      {
        "level": "Advanced",
        "title": "Memory Model & GC Tuning",
        "slug": "memory-gc-tuning",
        "description": "Understand JavaScript memory model, garbage collection, memory leaks, and profiling.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf50d",
        "moduleId": "68d1a7a6cd394e8cc4daf50a",
        "contentId": "68d1a7a6cd394e8cc4daf512"
      },
      {
        "level": "Advanced",
        "title": "Performance Patterns & Optimizations",
        "slug": "performance-patterns",
        "description": "Apply TypedArrays, structured cloning, and low-level optimizations for performance.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf50e",
        "moduleId": "68d1a7a6cd394e8cc4daf50a",
        "contentId": "68d1a7a6cd394e8cc4daf513"
      },
      {
        "level": "Advanced",
        "title": "Advanced Patterns: Proxies & Metaprogramming",
        "slug": "proxies-metaprogramming",
        "description": "Implement proxies, metaprogramming, and code generation for advanced JavaScript patterns.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf50f",
        "moduleId": "68d1a7a6cd394e8cc4daf50a",
        "contentId": "68d1a7a6cd394e8cc4daf514"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "The V8 engine powers JavaScript execution in browsers and Node.js. Understanding the event loop, microtasks (Promises), and macrotasks (setTimeout) is key to predicting runtime behavior. This lesson explores V8’s compilation pipeline, call stack, and task queues for writing robust code.",
        "examples": [
          "setTimeout(() => console.log('macrotask'), 0); Promise.resolve().then(() => console.log('microtask'));",
          "V8 JIT: Compiles JS to machine code for faster execution."
        ],
        "realWorldApplication": "Event loop knowledge prevents UI freezes in browsers and optimizes server-side Node.js apps like real-time APIs.",
        "expertInsights": "Microtasks run before macrotasks; use this to prioritize critical async code. Profile V8 performance with Chrome DevTools.",
        "commonMistakes": [
          "Assuming setTimeout(..., 0) runs instantly.",
          "Overloading microtask queue, blocking rendering."
        ],
        "exercises": [
          {
            "title": "Analyze Event Loop",
            "prompt": "Write code with setTimeout and Promises, then predict the output order.",
            "difficulty": "medium",
            "hints": [
              "Microtasks run before macrotasks",
              "Use console.log to trace"
            ],
            "solution": "code.js: console.log('start'); setTimeout(() => console.log('timeout'), 0); Promise.resolve().then(() => console.log('promise')); console.log('end');\n// Output: start, end, promise, timeout"
          }
        ],
        "quiz": [
          {
            "question": "Which runs first in the event loop?",
            "options": [
              "Macrotasks",
              "Microtasks",
              "setInterval",
              "setTimeout"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What powers JavaScript in Chrome?",
            "options": [
              "V8",
              "SpiderMonkey",
              "Chakra",
              "Rhino"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "JavaScript Event Loop — MDN",
            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf510",
        "lessonId": "68d1a7a6cd394e8cc4daf50b"
      },
      {
        "level": "Advanced",
        "explanation": "Advanced async programming includes cancellation with AbortController, observable patterns for reactive data, and stream APIs for processing large datasets. These tools enable robust, interruptible, and efficient async workflows in JavaScript.",
        "examples": [
          "AbortController: const controller = new AbortController(); fetch(url, { signal: controller.signal });",
          "Observable: RxJS Observable.subscribe(data => console.log(data));"
        ],
        "realWorldApplication": "Used in real-time dashboards (e.g., stock trading apps) and cancellable API calls in SPAs like Gmail.",
        "expertInsights": "Use AbortController for all fetch requests. Observables are powerful for event streams but add complexity; evaluate vs. Promises.",
        "commonMistakes": [
          "Not cleaning up async resources, causing leaks.",
          "Mixing Promise and Observable patterns unnecessarily."
        ],
        "exercises": [
          {
            "title": "Implement Cancellable Fetch",
            "prompt": "Create a cancellable fetch wrapper using AbortController.",
            "difficulty": "medium",
            "hints": [
              "Use AbortController.signal",
              "Handle abort errors"
            ],
            "solution": "fetchWrapper.js: async function fetchWithCancel(url) { const controller = new AbortController(); setTimeout(() => controller.abort(), 5000); try { const response = await fetch(url, { signal: controller.signal }); return await response.json(); } catch (e) { if (e.name === 'AbortError') throw new Error('Request cancelled'); throw e; } }"
          }
        ],
        "quiz": [
          {
            "question": "What cancels a fetch request?",
            "options": [
              "setTimeout",
              "AbortController",
              "Promise.reject",
              "Observable"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What is best for reactive event streams?",
            "options": [
              "Promises",
              "Observables",
              "setInterval",
              "async/await"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "AbortController — MDN",
            "url": "https://developer.mozilla.org/en-US/docs/Web/API/AbortController",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf511",
        "lessonId": "68d1a7a6cd394e8cc4daf50c"
      },
      {
        "level": "Advanced",
        "explanation": "JavaScript’s memory model uses heap and stack; garbage collection (GC) reclaims unused memory. Memory leaks occur from lingering references. Profiling with DevTools helps identify and fix leaks. This lesson covers heap snapshots, GC tuning, and memory-efficient coding.",
        "examples": [
          "Leak: let arr = []; setInterval(() => arr.push({}), 1000);",
          "Fix: Clear array or stop interval."
        ],
        "realWorldApplication": "Memory management is critical in Node.js servers (e.g., API backends) and browser apps with long sessions like editors.",
        "expertInsights": "Take heap snapshots regularly. Avoid global variables and ensure event listeners are removed.",
        "commonMistakes": [
          "Not removing event listeners, causing leaks.",
          "Ignoring large object allocations in loops."
        ],
        "exercises": [
          {
            "title": "Profile and Fix Memory Leak",
            "prompt": "Identify and fix a memory leak in a sample app using Chrome DevTools.",
            "difficulty": "hard",
            "hints": [
              "Use Heap Snapshot in DevTools",
              "Check for growing arrays or listeners"
            ],
            "solution": "leak.js: let listeners = []; function addListener() { const obj = {}; listeners.push(obj); document.addEventListener('click', () => console.log(obj)); } // Fix: document.removeEventListener('click', handler); listeners = [];"
          }
        ],
        "quiz": [
          {
            "question": "What causes memory leaks?",
            "options": [
              "Small arrays",
              "Lingering references",
              "Fast GC",
              "Promises"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What tool profiles memory in Chrome?",
            "options": [
              "Network panel",
              "Heap Snapshot",
              "Console",
              "Elements"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "JavaScript Memory Management — MDN",
            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf512",
        "lessonId": "68d1a7a6cd394e8cc4daf50d"
      },
      {
        "level": "Advanced",
        "explanation": "Performance patterns like TypedArrays and structured cloning optimize data handling for speed. TypedArrays (e.g., Int32Array) provide low-level memory access, while structured cloning ensures efficient data copying. This lesson covers their use for high-performance apps.",
        "examples": [
          "TypedArray: const buffer = new Int32Array([1, 2, 3]);",
          "Structured Clone: structuredClone({ data: complexObj });"
        ],
        "realWorldApplication": "Used in WebGL apps (games) and Node.js for processing large datasets efficiently.",
        "expertInsights": "Use TypedArrays for numerical data. Structured cloning is faster than JSON for complex objects.",
        "commonMistakes": [
          "Using regular arrays for large datasets, slowing performance.",
          "Not testing cloning performance with large objects."
        ],
        "exercises": [
          {
            "title": "Optimize with TypedArrays",
            "prompt": "Convert an array-based computation to use TypedArrays for better performance.",
            "difficulty": "medium",
            "hints": [
              "Use Int32Array for integers",
              "Measure performance with console.time"
            ],
            "solution": "optimize.js: const arr = new Array(1000000).fill(1); console.time('array'); arr.map(x => x * 2); console.timeEnd('array'); const typed = new Int32Array(1000000).fill(1); console.time('typed'); typed.map(x => x * 2); console.timeEnd('typed');"
          }
        ],
        "quiz": [
          {
            "question": "What optimizes numerical data handling?",
            "options": [
              "Regular arrays",
              "TypedArrays",
              "Promises",
              "Objects"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What is faster than JSON for copying complex objects?",
            "options": [
              "JSON.parse",
              "Structured cloning",
              "Stringify",
              "eval"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Typed Arrays — MDN",
            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf513",
        "lessonId": "68d1a7a6cd394e8cc4daf50e"
      },
      {
        "level": "Advanced",
        "explanation": "Proxies and metaprogramming enable dynamic behavior, like intercepting property access or generating code. Proxies wrap objects to customize operations, while code generation builds dynamic logic. This lesson covers proxies, Reflect API, and code generation techniques.",
        "examples": [
          "Proxy: const handler = { get: (target, prop) => target[prop] || 'default' }; const obj = new Proxy({}, handler);",
          "Codegen: eval('function generated() { return 42; }');"
        ],
        "realWorldApplication": "Proxies are used in Vue.js reactivity; code generation powers tools like Babel or Webpack.",
        "expertInsights": "Use proxies for reactive systems. Avoid eval for codegen due to security; prefer safer alternatives like Function constructor.",
        "commonMistakes": [
          "Overusing proxies, slowing performance.",
          "Using eval unsafely, risking injection."
        ],
        "exercises": [
          {
            "title": "Implement a Proxy",
            "prompt": "Create a proxy to log property access and handle missing properties.",
            "difficulty": "hard",
            "hints": [
              "Use get trap",
              "Return default for undefined props"
            ],
            "solution": "proxy.js: const handler = { get: (target, prop) => { console.log(`Accessed: ${prop}`); return target[prop] ?? 'default'; } }; const obj = new Proxy({ a: 1 }, handler); console.log(obj.a); console.log(obj.b);"
          }
        ],
        "quiz": [
          {
            "question": "What do proxies intercept?",
            "options": [
              "UI events",
              "Property access",
              "Database queries",
              "Network requests"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What is a safer alternative to eval?",
            "options": [
              "JSON.parse",
              "Function constructor",
              "setTimeout",
              "Promise"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Proxy API — MDN",
            "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf514",
        "lessonId": "68d1a7a6cd394e8cc4daf50f"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master advanced TypeScript and type systems to architect large, type-safe codebases for client and server applications.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf515"
      }
    ],
    "courses": [
      {
        "title": "Advanced TypeScript & Type Systems",
        "slug": "advanced-typescript-types",
        "shortDescription": "An advanced course on architecting large, type-safe TypeScript codebases with strict configurations, advanced types, generics, type-safe APIs, and migrations.",
        "level": "Advanced",
        "longDescription": "This course dives deep into TypeScript’s advanced features and type systems, covering strict configurations, advanced types, generics at scale, type-safe API contracts with zod/io-ts, and strategies for migrating large codebases. Through hands-on exercises, real-world examples, and quizzes, you’ll design shared types, create zod schemas, and generate OpenAPI types. The course equips you to build robust, type-safe applications for both client and server environments.",
        "tags": [
          "typescript",
          "type-systems",
          "generics",
          "api-contracts",
          "zod",
          "codegen",
          "migrations"
        ],
        "thumbnail": "https://example.com/thumbnails/advanced-typescript.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Architect large, type-safe TypeScript codebases with advanced types, generics, API contracts, and migrations.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf516",
        "domainId": "68d1a7a6cd394e8cc4daf515"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Advanced TypeScript & Type Systems",
        "slug": "advanced-typescript-types",
        "description": "Master strict TypeScript configurations, advanced types, generics, type-safe APIs, and codebase migrations for scalable applications.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf517",
        "courseId": "68d1a7a6cd394e8cc4daf516",
        "lessonIds": [
          "68d1a7a6cd394e8cc4daf518",
          "68d1a7a6cd394e8cc4daf519",
          "68d1a7a6cd394e8cc4daf51a",
          "68d1a7a6cd394e8cc4daf51b",
          "68d1a7a6cd394e8cc4daf51c"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "Strict Configurations and Project References",
        "slug": "strict-configs-project-references",
        "description": "Configure strict TypeScript settings, project references, and composite builds for large codebases.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf518",
        "moduleId": "68d1a7a6cd394e8cc4daf517",
        "contentId": "68d1a7a6cd394e8cc4daf51d"
      },
      {
        "level": "Advanced",
        "title": "Advanced Types",
        "slug": "advanced-types",
        "description": "Master mapped types, conditional types, infer, and template literal types for robust type systems.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf519",
        "moduleId": "68d1a7a6cd394e8cc4daf517",
        "contentId": "68d1a7a6cd394e8cc4daf51e"
      },
      {
        "level": "Advanced",
        "title": "Generics at Scale",
        "slug": "generics-at-scale",
        "description": "Implement generics for polymorphic components and conditional props in large applications.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf51a",
        "moduleId": "68d1a7a6cd394e8cc4daf517",
        "contentId": "68d1a7a6cd394e8cc4daf51f"
      },
      {
        "level": "Advanced",
        "title": "Type-Safe API Contracts",
        "slug": "type-safe-api-contracts",
        "description": "Build type-safe APIs with zod/io-ts and generate OpenAPI/GraphQL schemas.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf51b",
        "moduleId": "68d1a7a6cd394e8cc4daf517",
        "contentId": "68d1a7a6cd394e8cc4daf520"
      },
      {
        "level": "Advanced",
        "title": "Migrating Large Codebases & Runtime Type Checks",
        "slug": "codebase-migration-runtime-checks",
        "description": "Migrate JavaScript codebases to TypeScript and implement runtime type checks.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf51c",
        "moduleId": "68d1a7a6cd394e8cc4daf517",
        "contentId": "68d1a7a6cd394e8cc4daf521"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "TypeScript’s strict configurations and project references enable scalable, maintainable codebases. Strict settings enforce type safety, while project references and composite builds optimize large monorepos. This lesson covers configuring tsconfig.json and structuring projects for efficiency.",
        "examples": [
          "tsconfig.json: { \"strict\": true, \"noImplicitAny\": true }",
          "Project Reference: { \"references\": [{ \"path\": \"../shared\" }] }"
        ],
        "realWorldApplication": "Used in large-scale apps like VS Code and Angular to manage complex TypeScript projects.",
        "expertInsights": "Enable strict mode for safety. Use project references for faster builds in monorepos.",
        "commonMistakes": [
          "Disabling strict checks, reducing type safety.",
          "Not splitting large projects, slowing compiles."
        ],
        "exercises": [
          {
            "title": "Configure a Monorepo",
            "prompt": "Set up a TypeScript monorepo with strict configs and project references.",
            "difficulty": "medium",
            "hints": [
              "Enable strict in tsconfig",
              "Add references for shared code"
            ],
            "solution": "tsconfig.json: { \"compilerOptions\": { \"strict\": true, \"noImplicitAny\": true, \"composite\": true }, \"references\": [{ \"path\": \"../shared\" }] }\nshared/tsconfig.json: { \"compilerOptions\": { \"composite\": true, \"outDir\": \"dist\" } }"
          }
        ],
        "quiz": [
          {
            "question": "What enforces type safety in TypeScript?",
            "options": [
              "Loose configs",
              "Strict mode",
              "JavaScript",
              "CSS"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What optimizes monorepo builds?",
            "options": [
              "Project references",
              "Inline types",
              "Dynamic imports",
              "eval"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "TypeScript Handbook — Project References",
            "url": "https://www.typescriptlang.org/docs/handbook/project-references.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf51d",
        "lessonId": "68d1a7a6cd394e8cc4daf518"
      },
      {
        "level": "Advanced",
        "explanation": "Advanced TypeScript types like mapped, conditional, infer, and template literal types enable expressive, reusable type systems. This lesson covers creating flexible types for complex scenarios, ensuring type safety without excessive boilerplate.",
        "examples": [
          "Mapped: type Keys = { [K in keyof T]: string };",
          "Conditional: type NonNullable<T> = T extends null | undefined ? never : T;"
        ],
        "realWorldApplication": "Used in libraries like React and Apollo Client for type-safe component props and queries.",
        "expertInsights": "Use infer for dynamic type extraction. Template literal types are great for string-based APIs.",
        "commonMistakes": [
          "Overusing any, losing type safety.",
          "Writing complex types without utility types."
        ],
        "exercises": [
          {
            "title": "Create a Mapped Type",
            "prompt": "Define a mapped type to convert object values to strings.",
            "difficulty": "medium",
            "hints": [
              "Use keyof and in",
              "Map to string type"
            ],
            "solution": "types.ts: type Stringify<T> = { [K in keyof T]: string }; const example: Stringify<{ a: number, b: boolean }> = { a: '1', b: 'true' };"
          }
        ],
        "quiz": [
          {
            "question": "What creates dynamic types from keys?",
            "options": [
              "Conditional types",
              "Mapped types",
              "Generics",
              "Any"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What extracts types dynamically?",
            "options": [
              "infer",
              "keyof",
              "extends",
              "typeof"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "TypeScript Advanced Types",
            "url": "https://www.typescriptlang.org/docs/handbook/2/types-from-types.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf51e",
        "lessonId": "68d1a7a6cd394e8cc4daf519"
      },
      {
        "level": "Advanced",
        "explanation": "Generics enable reusable, type-safe code for polymorphic components and conditional props. This lesson covers designing generics for large-scale apps, ensuring flexibility and type safety in React components or server-side logic.",
        "examples": [
          "Generic Component: function Component<T>(props: { data: T }) {}",
          "Conditional Props: type Props<T> = T extends string ? { text: T } : { value: T };"
        ],
        "realWorldApplication": "Used in React libraries like Material-UI and server-side frameworks like NestJS for type-safe APIs.",
        "expertInsights": "Keep generics constrained for clarity. Use conditional props for dynamic component APIs.",
        "commonMistakes": [
          "Overcomplicating generics, reducing readability.",
          "Not constraining generics, causing type errors."
        ],
        "exercises": [
          {
            "title": "Design a Generic Component",
            "prompt": "Create a generic React component with conditional props based on input type.",
            "difficulty": "hard",
            "hints": [
              "Use extends for constraints",
              "Define conditional props"
            ],
            "solution": "component.tsx: type Props<T> = T extends string ? { text: T } : { value: T }; function GenericComponent<T>(props: Props<T>) { return <div>{'text' in props ? props.text : String(props.value)}</div>; } const App = () => <GenericComponent text=\"hello\" />;"
          }
        ],
        "quiz": [
          {
            "question": "What enables reusable type-safe code?",
            "options": [
              "Any",
              "Generics",
              "Interfaces",
              "Enums"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What constrains generic types?",
            "options": [
              "extends",
              "implements",
              "keyof",
              "typeof"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "TypeScript Generics",
            "url": "https://www.typescriptlang.org/docs/handbook/2/generics.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf51f",
        "lessonId": "68d1a7a6cd394e8cc4daf51a"
      },
      {
        "level": "Advanced",
        "explanation": "Type-safe API contracts with zod or io-ts ensure runtime validation and type safety. Codegen from OpenAPI or GraphQL schemas automates type generation. This lesson covers defining schemas, validating APIs, and generating types for client/server consistency.",
        "examples": [
          "Zod: const UserSchema = z.object({ id: z.string(), name: z.string() });",
          "OpenAPI Codegen: npx openapi-typescript openapi.json -o types.ts"
        ],
        "realWorldApplication": "Used in APIs for Stripe and Shopify to ensure type-safe client-server communication.",
        "expertInsights": "Use zod for simplicity, io-ts for functional programming. Generate types from schemas to avoid duplication.",
        "commonMistakes": [
          "Not validating inputs, causing runtime errors.",
          "Manually writing types instead of using codegen."
        ],
        "exercises": [
          {
            "title": "Design a Type-Safe API",
            "prompt": "Create a zod schema for a user API and generate OpenAPI types.",
            "difficulty": "hard",
            "hints": [
              "Define zod schema",
              "Use openapi-typescript"
            ],
            "solution": "schema.ts: import { z } from 'zod'; const UserSchema = z.object({ id: z.string(), name: z.string() }); export type User = z.infer<typeof UserSchema>;\nopenapi.yaml: paths:\n  /users:\n    get:\n      responses:\n        '200':\n          content:\n            application/json:\n              schema:\n                $ref: '#/components/schemas/User'\ncomponents:\n  schemas:\n    User:\n      type: object\n      properties:\n        id: { type: string }\n        name: { type: string }"
          }
        ],
        "quiz": [
          {
            "question": "What validates API inputs?",
            "options": [
              "CSS",
              "Zod",
              "GraphQL",
              "React"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What automates type generation?",
            "options": [
              "Codegen",
              "eval",
              "Promises",
              "JSON"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Zod Documentation",
            "url": "https://zod.dev/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf520",
        "lessonId": "68d1a7a6cd394e8cc4daf51b"
      },
      {
        "level": "Advanced",
        "explanation": "Migrating large JavaScript codebases to TypeScript requires incremental adoption and runtime type checks. This lesson covers strategies for gradual migration, adding types to existing code, and using runtime validation to catch errors in legacy systems.",
        "examples": [
          "Migration: Add .ts extension and basic types incrementally.",
          "Runtime: const validated = UserSchema.parse(data);"
        ],
        "realWorldApplication": "Used by companies like Airbnb and Dropbox to migrate legacy JavaScript to TypeScript.",
        "expertInsights": "Migrate one module at a time. Use any sparingly and refine types iteratively.",
        "commonMistakes": [
          "Overusing any, delaying type safety.",
          "Not testing runtime validation, missing errors."
        ],
        "exercises": [
          {
            "title": "Migrate JavaScript to TypeScript",
            "prompt": "Convert a JavaScript function to TypeScript with zod runtime validation.",
            "difficulty": "hard",
            "hints": [
              "Add type annotations",
              "Use zod.parse for runtime checks"
            ],
            "solution": "user.ts: import { z } from 'zod'; const UserSchema = z.object({ id: z.string(), name: z.string() }); type User = z.infer<typeof UserSchema>; function processUser(data: unknown): User { return UserSchema.parse(data); } // Original JS: function processUser(data) { return data; }"
          }
        ],
        "quiz": [
          {
            "question": "What enables gradual TypeScript adoption?",
            "options": [
              "eval",
              "Incremental migration",
              "CSS",
              "Promises"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What catches runtime errors in migrations?",
            "options": [
              "Type annotations",
              "Zod parsing",
              "Generics",
              "Interfaces"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "TypeScript Migration Guide",
            "url": "https://www.typescriptlang.org/docs/handbook/migrating-from-javascript.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf521",
        "lessonId": "68d1a7a6cd394e8cc4daf51c"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Design scalable, maintainable, and high-performance frontend architectures optimized for large teams and complex applications.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf522"
      }
    ],
    "courses": [
      {
        "title": "Scalable Frontend Architectures",
        "slug": "scalable-frontend-arch",
        "shortDescription": "An advanced course on designing scalable frontend architectures with microfrontends, advanced rendering strategies, performance budgets, design systems, and accessibility.",
        "level": "Advanced",
        "longDescription": "This course focuses on building scalable frontend architectures for maintainability, performance, and team collaboration. It covers microfrontends, module federation, advanced server-side rendering (SSR), incremental static regeneration (ISR), and static site generation (SSG) with Next.js, as well as performance budgets, design systems, accessibility, and internationalization (i18n). Through hands-on exercises, real-world examples, and quizzes, you’ll convert a monolithic UI into a composable microfrontend demo. The course equips you to architect robust frontend systems for large-scale applications.",
        "tags": [
          "microfrontends",
          "module-federation",
          "ssr",
          "isr",
          "ssg",
          "performance",
          "design-systems",
          "accessibility",
          "i18n"
        ],
        "thumbnail": "https://example.com/thumbnails/scalable-frontend.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Design scalable frontend architectures for maintainability, performance, and team scale with microfrontends, rendering strategies, and accessibility.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf523",
        "domainId": "68d1a7a6cd394e8cc4daf522"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Scalable Frontend Architectures",
        "slug": "scalable-frontend-arch",
        "description": "Master microfrontends, advanced rendering strategies, performance budgets, design systems, and accessibility for scalable frontend applications.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf524",
        "courseId": "68d1a7a6cd394e8cc4daf523",
        "lessonIds": [
          "68d1a7a6cd394e8cc4daf525",
          "68d1a7a6cd394e8cc4daf526",
          "68d1a7a6cd394e8cc4daf527",
          "68d1a7a6cd394e8cc4daf528",
          "68d1a7a6cd394e8cc4daf529"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "Microfrontends and Module Federation",
        "slug": "microfrontends-module-federation",
        "description": "Explore microfrontends, module federation, and composition patterns for modular frontends.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf525",
        "moduleId": "68d1a7a6cd394e8cc4daf524",
        "contentId": "68d1a7a6cd394e8cc4daf52a"
      },
      {
        "level": "Advanced",
        "title": "Advanced SSR, ISR, and SSG Strategies",
        "slug": "advanced-ssr-isr-ssg",
        "description": "Implement server-side rendering, incremental static regeneration, and static site generation with hydration trade-offs.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf526",
        "moduleId": "68d1a7a6cd394e8cc4daf524",
        "contentId": "68d1a7a6cd394e8cc4daf52b"
      },
      {
        "level": "Advanced",
        "title": "Frontend Performance Budgets",
        "slug": "frontend-performance-budgets",
        "description": "Set performance budgets and optimize resource loading with critical CSS and font strategies.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf527",
        "moduleId": "68d1a7a6cd394e8cc4daf524",
        "contentId": "68d1a7a6cd394e8cc4daf52c"
      },
      {
        "level": "Advanced",
        "title": "Component Libraries and Design Systems",
        "slug": "component-libraries-design-systems",
        "description": "Build scalable component libraries and design systems with tokens and theming.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf528",
        "moduleId": "68d1a7a6cd394e8cc4daf524",
        "contentId": "68d1a7a6cd394e8cc4daf52d"
      },
      {
        "level": "Advanced",
        "title": "Accessibility and Internationalization at Scale",
        "slug": "accessibility-i18n",
        "description": "Implement scalable accessibility and internationalization (i18n) for global applications.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf529",
        "moduleId": "68d1a7a6cd394e8cc4daf524",
        "contentId": "68d1a7a6cd394e8cc4daf52e"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "Microfrontends and module federation enable modular, independently deployable frontends, while composition patterns improve maintainability. This lesson covers setting up microfrontends with Webpack Module Federation and composing UIs for team scalability.",
        "examples": [
          "Module Federation: import('remoteApp/Button');",
          "Microfrontend: Separate React apps for dashboard and settings."
        ],
        "realWorldApplication": "Used by companies like Netflix and AWS for modular frontend development across teams.",
        "expertInsights": "Use module federation for dynamic imports. Keep microfrontends small to avoid complexity.",
        "commonMistakes": [
          "Over-splitting microfrontends, increasing overhead.",
          "Not defining clear module boundaries, causing coupling."
        ],
        "exercises": [
          {
            "title": "Set Up Module Federation",
            "prompt": "Configure Webpack Module Federation to share a component between two apps.",
            "difficulty": "hard",
            "hints": [
              "Use ModuleFederationPlugin",
              "Expose and consume components"
            ],
            "solution": "webpack.config.js: const { ModuleFederationPlugin } = require('webpack'); module.exports = { plugins: [ new ModuleFederationPlugin({ name: 'host', remotes: { remote: 'remote@http://localhost:3001/remoteEntry.js' }, shared: ['react', 'react-dom'] }) ] };"
          }
        ],
        "quiz": [
          {
            "question": "What enables modular frontends?",
            "options": [
              "Monoliths",
              "Microfrontends",
              "CSS",
              "SQL"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What shares modules dynamically?",
            "options": [
              "Module Federation",
              "Static imports",
              "eval",
              "Promises"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Webpack Module Federation",
            "url": "https://webpack.js.org/concepts/module-federation/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf52a",
        "lessonId": "68d1a7a6cd394e8cc4daf525"
      },
      {
        "level": "Advanced",
        "explanation": "Server-side rendering (SSR), incremental static regeneration (ISR), and static site generation (SSG) optimize performance and SEO. This lesson covers implementing these strategies in Next.js, analyzing hydration trade-offs, and optimizing rendering pipelines.",
        "examples": [
          "SSR: export async function getServerSideProps() { return { props: {} } }",
          "ISR: export async function getStaticProps() { return { props: {}, revalidate: 10 } }"
        ],
        "realWorldApplication": "Used by Vercel-powered apps like The Washington Post for fast, SEO-friendly pages.",
        "expertInsights": "Use ISR for dynamic content with static benefits. Minimize hydration for faster client loads.",
        "commonMistakes": [
          "Overusing SSR, increasing server load.",
          "Not optimizing hydration, slowing interactivity."
        ],
        "exercises": [
          {
            "title": "Implement ISR in Next.js",
            "prompt": "Create a Next.js page with ISR and analyze hydration performance.",
            "difficulty": "medium",
            "hints": [
              "Use getStaticProps with revalidate",
              "Check hydration in DevTools"
            ],
            "solution": "pages/index.tsx: export async function getStaticProps() { const data = await fetchData(); return { props: { data }, revalidate: 10 }; } export default function Page({ data }) { return <div>{data}</div>; }"
          }
        ],
        "quiz": [
          {
            "question": "What balances dynamic and static content?",
            "options": [
              "SSR",
              "ISR",
              "SSG",
              "Client-side rendering"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What improves SEO in Next.js?",
            "options": [
              "Client-side rendering",
              "SSR",
              "CSS",
              "JavaScript"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Next.js Data Fetching",
            "url": "https://nextjs.org/docs/basic-features/data-fetching",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf52b",
        "lessonId": "68d1a7a6cd394e8cc4daf526"
      },
      {
        "level": "Advanced",
        "explanation": "Performance budgets define acceptable limits for metrics like load time and bundle size. Critical CSS and font strategies optimize resource loading. This lesson covers setting budgets, extracting critical CSS, and optimizing fonts for faster rendering.",
        "examples": [
          "Critical CSS: <style>body { font-size: 16px; }</style>",
          "Font: <link rel=\"preload\" href=\"font.woff2\" as=\"font\">"
        ],
        "realWorldApplication": "Used by Google and Shopify to ensure fast, performant web apps.",
        "expertInsights": "Set strict budgets for critical paths. Preload fonts and defer non-critical CSS.",
        "commonMistakes": [
          "Not setting budgets, leading to slow apps.",
          "Loading large fonts without optimization."
        ],
        "exercises": [
          {
            "title": "Optimize Resource Loading",
            "prompt": "Set a performance budget and extract critical CSS for a page.",
            "difficulty": "medium",
            "hints": [
              "Use Lighthouse for budgets",
              "Extract critical CSS with tools"
            ],
            "solution": "budget.json: { \"timings\": { \"firstContentfulPaint\": 1000 } }\nstyles.css: /* Critical */ body { font-size: 16px; } /* Non-critical deferred */"
          }
        ],
        "quiz": [
          {
            "question": "What defines acceptable performance metrics?",
            "options": [
              "Critical CSS",
              "Performance budgets",
              "Fonts",
              "JavaScript"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What optimizes initial rendering?",
            "options": [
              "Critical CSS",
              "Deferred JS",
              "Large fonts",
              "Images"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Web Vitals",
            "url": "https://web.dev/vitals/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf52c",
        "lessonId": "68d1a7a6cd394e8cc4daf527"
      },
      {
        "level": "Advanced",
        "explanation": "Component libraries and design systems ensure consistency and scalability with reusable components, design tokens, and theming. This lesson covers building a component library, defining tokens, and implementing theming for large teams.",
        "examples": [
          "Token: --color-primary: #007bff;",
          "Theming: .theme-dark { --color-primary: #1a1a1a; }"
        ],
        "realWorldApplication": "Used by Material-UI and Atlassian’s design system for consistent, scalable UIs.",
        "expertInsights": "Use tokens for maintainability. Implement theming with CSS variables or styled-components.",
        "commonMistakes": [
          "Hardcoding styles, reducing flexibility.",
          "Not documenting components, slowing adoption."
        ],
        "exercises": [
          {
            "title": "Build a Component Library",
            "prompt": "Create a reusable button component with design tokens and theming.",
            "difficulty": "hard",
            "hints": [
              "Use CSS variables",
              "Support light/dark themes"
            ],
            "solution": "Button.tsx: import styled from 'styled-components'; const Button = styled.button` --color-primary: ${props => props.theme.primary}; background: var(--color-primary); `; export default Button;\ntheme.ts: export const lightTheme = { primary: '#007bff' }; export const darkTheme = { primary: '#1a1a1a' };"
          }
        ],
        "quiz": [
          {
            "question": "What ensures UI consistency?",
            "options": [
              "Hardcoded styles",
              "Design systems",
              "Images",
              "JavaScript"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What enables flexible theming?",
            "options": [
              "CSS variables",
              "Inline styles",
              "Fonts",
              "eval"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Design Systems Handbook",
            "url": "https://www.designsystems.com/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf52d",
        "lessonId": "68d1a7a6cd394e8cc4daf528"
      },
      {
        "level": "Advanced",
        "explanation": "Accessibility (a11y) and internationalization (i18n) ensure apps are usable globally and inclusively. This lesson covers implementing ARIA attributes, keyboard navigation, and i18n libraries like i18next for scalable, accessible applications.",
        "examples": [
          "ARIA: <button aria-label=\"Close\">X</button>",
          "i18n: i18next.t('welcome', { lng: 'es' })"
        ],
        "realWorldApplication": "Used by Airbnb and Google for accessible, multilingual web apps.",
        "expertInsights": "Test a11y with screen readers. Use i18n from the start to avoid refactoring.",
        "commonMistakes": [
          "Skipping ARIA labels, breaking accessibility.",
          "Hardcoding strings, complicating i18n."
        ],
        "exercises": [
          {
            "title": "Add Accessibility and i18n",
            "prompt": "Add ARIA attributes and i18n to a React component.",
            "difficulty": "hard",
            "hints": [
              "Use aria-label",
              "Integrate i18next"
            ],
            "solution": "Component.tsx: import { useTranslation } from 'react-i18next'; function Component() { const { t } = useTranslation(); return <button aria-label={t('close')}>{t('close')}</button>; }\ni18n.ts: import i18next from 'i18next'; i18next.init({ lng: 'en', resources: { en: { translation: { close: 'Close' } }, es: { translation: { close: 'Cerrar' } } } });"
          }
        ],
        "quiz": [
          {
            "question": "What improves accessibility?",
            "options": [
              "Inline styles",
              "ARIA attributes",
              "Fonts",
              "JavaScript"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What enables multilingual apps?",
            "options": [
              "i18n",
              "CSS",
              "eval",
              "Promises"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Web Accessibility — WAI",
            "url": "https://www.w3.org/WAI/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf52e",
        "lessonId": "68d1a7a6cd394e8cc4daf529"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Master advanced client and server caching strategies, state management, and data synchronization for robust, high-performance applications.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf52f"
      }
    ],
    "courses": [
      {
        "title": "Advanced State & Data Caching",
        "slug": "advanced-state-caching",
        "shortDescription": "An advanced course on robust client and server caching, state management, and data synchronization with React Query, CRDTs, and cache invalidation.",
        "level": "Advanced",
        "longDescription": "This course dives into advanced caching and state management techniques, covering CDN and edge caching, server-state management with React Query, conflict resolution with CRDTs, and cache invalidation strategies. Through hands-on exercises, real-world examples, and quizzes, you’ll implement stale-while-revalidate caching and optimistic updates with React Query. The course equips you to build performant, synchronized web applications for complex use cases.",
        "tags": [
          "caching",
          "react-query",
          "crdts",
          "cache-invalidation",
          "state-management",
          "offline-first"
        ],
        "thumbnail": "https://example.com/thumbnails/advanced-state-caching.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Master client and server caching, state management, and data synchronization for robust applications.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf530",
        "domainId": "68d1a7a6cd394e8cc4daf52f"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Advanced State & Data Caching",
        "slug": "advanced-state-caching",
        "description": "Learn advanced caching layers, server-state management, conflict resolution, and cache invalidation for scalable applications.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf531",
        "courseId": "68d1a7a6cd394e8cc4daf530",
        "lessonIds": [
          "68d1a7a6cd394e8cc4daf532",
          "68d1a7a6cd394e8cc4daf533",
          "68d1a7a6cd394e8cc4daf534",
          "68d1a7a6cd394e8cc4daf535"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "Advanced Caching Layers",
        "slug": "advanced-caching-layers",
        "description": "Implement CDN, edge caching, stale-while-revalidate, and cache-control strategies.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf532",
        "moduleId": "68d1a7a6cd394e8cc4daf531",
        "contentId": "68d1a7a6cd394e8cc4daf536"
      },
      {
        "level": "Advanced",
        "title": "Server-State Clients with React Query",
        "slug": "react-query-advanced",
        "description": "Master pagination, infinite queries, and background refetching with React Query.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf533",
        "moduleId": "68d1a7a6cd394e8cc4daf531",
        "contentId": "68d1a7a6cd394e8cc4daf537"
      },
      {
        "level": "Advanced",
        "title": "Conflict Resolution and Offline-First Sync",
        "slug": "conflict-resolution-offline",
        "description": "Implement CRDTs and offline-first synchronization for robust data syncing.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf534",
        "moduleId": "68d1a7a6cd394e8cc4daf531",
        "contentId": "68d1a7a6cd394e8cc4daf538"
      },
      {
        "level": "Advanced",
        "title": "Cache Invalidation Patterns",
        "slug": "cache-invalidation-patterns",
        "description": "Apply cache invalidation strategies and measure cache effectiveness with metrics.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf535",
        "moduleId": "68d1a7a6cd394e8cc4daf531",
        "contentId": "68d1a7a6cd394e8cc4daf539"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "Advanced caching layers like CDN, edge caching, and stale-while-revalidate optimize performance by reducing latency and server load. Cache-control headers define caching behavior. This lesson covers configuring these strategies for scalable applications.",
        "examples": [
          "Cache-Control: max-age=3600, stale-while-revalidate=86400",
          "CDN: Cloudflare configuration for edge caching."
        ],
        "realWorldApplication": "Used by Netflix and Shopify to deliver fast, cached content globally.",
        "expertInsights": "Use stale-while-revalidate for dynamic content. Set granular cache-control headers.",
        "commonMistakes": [
          "Not setting cache-control, causing over-fetching.",
          "Over-caching dynamic data, serving stale content."
        ],
        "exercises": [
          {
            "title": "Configure Edge Caching",
            "prompt": "Set up cache-control headers for a REST API with stale-while-revalidate.",
            "difficulty": "medium",
            "hints": [
              "Use max-age and stale-while-revalidate",
              "Test with curl"
            ],
            "solution": "server.ts: import express from 'express'; const app = express(); app.get('/data', (req, res) => { res.set('Cache-Control', 'public, max-age=3600, stale-while-revalidate=86400'); res.json({ data: 'example' }); }); app.listen(3000);"
          }
        ],
        "quiz": [
          {
            "question": "What reduces latency in caching?",
            "options": [
              "CDN",
              "Local storage",
              "JavaScript",
              "CSS"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What allows serving stale content during revalidation?",
            "options": [
              "max-age",
              "stale-while-revalidate",
              "no-cache",
              "private"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "HTTP Caching — MDN",
            "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf536",
        "lessonId": "68d1a7a6cd394e8cc4daf532"
      },
      {
        "level": "Advanced",
        "explanation": "React Query simplifies server-state management with features like pagination, infinite queries, and background refetching. This lesson covers advanced React Query techniques to optimize data fetching and synchronization in client applications.",
        "examples": [
          "Infinite Query: useInfiniteQuery('posts', fetchPosts, { getNextPageParam })",
          "Background Refetch: useQuery('data', fetchData, { refetchInterval: 5000 })"
        ],
        "realWorldApplication": "Used in apps like GitHub and Notion for efficient data fetching and UI updates.",
        "expertInsights": "Use infinite queries for paginated lists. Enable background refetching for real-time data.",
        "commonMistakes": [
          "Not handling loading states, breaking UI.",
          "Over-fetching with aggressive refetching."
        ],
        "exercises": [
          {
            "title": "Implement Infinite Query",
            "prompt": "Create a paginated list with React Query’s useInfiniteQuery.",
            "difficulty": "medium",
            "hints": [
              "Use getNextPageParam",
              "Handle loading states"
            ],
            "solution": "List.tsx: import { useInfiniteQuery } from 'react-query'; function List() { const { data, fetchNextPage, isLoading } = useInfiniteQuery('posts', ({ pageParam = 1 }) => fetch(`/api/posts?page=${pageParam}`).then(res => res.json()), { getNextPageParam: (lastPage) => lastPage.nextPage }); return <div>{isLoading ? 'Loading...' : data.pages.map(page => page.posts.map(post => <div>{post.title}</div>))}<button onClick={() => fetchNextPage()}>Load More</button></div>; }"
          }
        ],
        "quiz": [
          {
            "question": "What manages server-state in React?",
            "options": [
              "Redux",
              "React Query",
              "Context",
              "useState"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What enables paginated data fetching?",
            "options": [
              "useQuery",
              "useInfiniteQuery",
              "useEffect",
              "useState"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "React Query Documentation",
            "url": "https://tanstack.com/query/v4/docs/overview",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf537",
        "lessonId": "68d1a7a6cd394e8cc4daf533"
      },
      {
        "level": "Advanced",
        "explanation": "Conflict-free Replicated Data Types (CRDTs) and offline-first sync enable robust data synchronization, especially for offline scenarios. This lesson covers implementing CRDTs and offline-first strategies using libraries like Y.js for real-time collaboration.",
        "examples": [
          "CRDT: Y.Text for collaborative text editing.",
          "Offline Sync: Store mutations in IndexedDB, sync on reconnect."
        ],
        "realWorldApplication": "Used by apps like Notion and Figma for real-time collaboration and offline support.",
        "expertInsights": "Use CRDTs for collaborative features. Test offline sync with network throttling.",
        "commonMistakes": [
          "Not handling merge conflicts, causing data loss.",
          "Ignoring offline storage, breaking UX."
        ],
        "exercises": [
          {
            "title": "Implement Offline-First Sync",
            "prompt": "Create an offline-first todo app with CRDT-based sync using Y.js.",
            "difficulty": "hard",
            "hints": [
              "Use Y.Text for todos",
              "Store in IndexedDB"
            ],
            "solution": "Todo.tsx: import * as Y from 'yjs'; const ydoc = new Y.Doc(); const todos = ydoc.getArray('todos'); function TodoApp() { useEffect(() => { todos.observe(() => console.log(todos.toJSON())); todos.push([{ text: 'New todo' }]); }, []); return <div>{todos.toJSON().map(todo => <div>{todo.text}</div>)}</div>; }"
          }
        ],
        "quiz": [
          {
            "question": "What enables conflict-free data sync?",
            "options": [
              "CRDTs",
              "Promises",
              "Redux",
              "CSS"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What supports offline-first apps?",
            "options": [
              "IndexedDB",
              "LocalStorage",
              "Cookies",
              "SessionStorage"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "CRDTs Explained",
            "url": "https://crdt.tech/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf538",
        "lessonId": "68d1a7a6cd394e8cc4daf534"
      },
      {
        "level": "Advanced",
        "explanation": "Cache invalidation ensures fresh data while maintaining performance. Metrics like cache hit rate measure effectiveness. This lesson covers invalidation patterns (e.g., time-based, event-based) and tracking cache performance with tools like Prometheus.",
        "examples": [
          "Invalidation: Invalidate cache on POST /data.",
          "Metric: Cache hit rate via Prometheus counter."
        ],
        "realWorldApplication": "Used by AWS and Google Cloud to manage cache consistency in large-scale systems.",
        "expertInsights": "Use event-based invalidation for dynamic data. Monitor hit rates to optimize caching.",
        "commonMistakes": [
          "Not invalidating cache, serving stale data.",
          "Ignoring metrics, missing inefficiencies."
        ],
        "exercises": [
          {
            "title": "Implement Cache Invalidation",
            "prompt": "Create a React Query setup with optimistic updates and cache invalidation.",
            "difficulty": "hard",
            "hints": [
              "Use queryClient.invalidateQueries",
              "Implement optimistic updates"
            ],
            "solution": "App.tsx: import { useMutation, useQuery, useQueryClient } from 'react-query'; function App() { const queryClient = useQueryClient(); const { data } = useQuery('todos', fetchTodos); const mutation = useMutation(newTodo => postTodo(newTodo), { onMutate: async newTodo => { await queryClient.cancelQueries('todos'); queryClient.setQueryData('todos', old => [...old, newTodo]); }, onSuccess: () => queryClient.invalidateQueries('todos') }); return <button onClick={() => mutation.mutate({ text: 'New' })}>Add</button>; }"
          }
        ],
        "quiz": [
          {
            "question": "What ensures fresh cache data?",
            "options": [
              "Invalidation",
              "Stale-while-revalidate",
              "max-age",
              "CDN"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What measures cache effectiveness?",
            "options": [
              "Hit rate",
              "CSS",
              "JavaScript",
              "Promises"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Cache Invalidation Strategies",
            "url": "https://aws.amazon.com/caching/best-practices/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf539",
        "lessonId": "68d1a7a6cd394e8cc4daf535"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Web Development",
        "slug": "web-development",
        "description": "Design composable, observable, and scalable APIs using GraphQL federation, RPC, and governance practices for large teams.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf53a"
      }
    ],
    "courses": [
      {
        "title": "API Design at Scale (GraphQL Federation & RPC)",
        "slug": "api-design-scale",
        "shortDescription": "An advanced course on designing scalable APIs with GraphQL federation, RPC, gateways, and governance for team collaboration.",
        "level": "Advanced",
        "longDescription": "This course focuses on designing scalable, composable APIs for large teams, covering API design principles, GraphQL schema federation, RPC/gRPC for internal services, API gateways, and governance with contract testing. Through hands-on exercises, real-world examples, and quizzes, you’ll design a federated GraphQL schema, set up a gateway, and write contract tests. The course equips you to architect robust APIs for complex, multi-team environments.",
        "tags": [
          "graphql",
          "federation",
          "rpc",
          "grpc",
          "api-gateway",
          "contract-testing",
          "governance"
        ],
        "thumbnail": "https://example.com/thumbnails/api-design-scale.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Design scalable, composable APIs with GraphQL federation, RPC, gateways, and governance practices.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf53b",
        "domainId": "68d1a7a6cd394e8cc4daf53a"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — API Design at Scale",
        "slug": "api-design-scale",
        "description": "Master API design principles, GraphQL federation, RPC/gRPC, gateways, and governance for scalable, team-oriented APIs.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf53c",
        "courseId": "68d1a7a6cd394e8cc4daf53b",
        "lessonIds": [
          "68d1a7a6cd394e8cc4daf53d",
          "68d1a7a6cd394e8cc4daf53e",
          "68d1a7a6cd394e8cc4daf53f",
          "68d1a7a6cd394e8cc4daf540",
          "68d1a7a6cd394e8cc4daf541"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "API Design Principles for Scale",
        "slug": "api-design-principles",
        "description": "Learn backward compatibility, versioning, pagination, and idempotency for scalable APIs.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf53d",
        "moduleId": "68d1a7a6cd394e8cc4daf53c",
        "contentId": "68d1a7a6cd394e8cc4daf542"
      },
      {
        "level": "Advanced",
        "title": "Advanced GraphQL: Schema Federation",
        "slug": "graphql-federation",
        "description": "Implement schema federation, persisted queries, and subscriptions in GraphQL.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf53e",
        "moduleId": "68d1a7a6cd394e8cc4daf53c",
        "contentId": "68d1a7a6cd394e8cc4daf543"
      },
      {
        "level": "Advanced",
        "title": "RPC and gRPC for Internal Services",
        "slug": "rpc-grpc",
        "description": "Explore RPC and gRPC for internal services, comparing pros and cons with REST/GraphQL.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf53f",
        "moduleId": "68d1a7a6cd394e8cc4daf53c",
        "contentId": "68d1a7a6cd394e8cc4daf544"
      },
      {
        "level": "Advanced",
        "title": "API Gateways and Request Management",
        "slug": "api-gateways",
        "description": "Set up API gateways with throttling and request shaping for scalability.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf540",
        "moduleId": "68d1a7a6cd394e8cc4daf53c",
        "contentId": "68d1a7a6cd394e8cc4daf545"
      },
      {
        "level": "Advanced",
        "title": "Contract Testing and API Governance",
        "slug": "contract-testing-governance",
        "description": "Implement contract testing and API governance with OpenAPI and schema registries.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf541",
        "moduleId": "68d1a7a6cd394e8cc4daf53c",
        "contentId": "68d1a7a6cd394e8cc4daf546"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "Scalable API design requires principles like backward compatibility, versioning, pagination, and idempotency to ensure reliability across teams. This lesson covers designing APIs that scale without breaking clients, using techniques like cursor-based pagination and idempotent operations.",
        "examples": [
          "Versioning: /api/v1/users",
          "Pagination: GET /users?cursor=abc&limit=20"
        ],
        "realWorldApplication": "Used by Stripe and GitHub for stable, scalable APIs.",
        "expertInsights": "Always plan for backward compatibility. Use cursor-based pagination for large datasets.",
        "commonMistakes": [
          "Breaking changes without versioning.",
          "Using offset-based pagination for large datasets."
        ],
        "exercises": [
          {
            "title": "Design a Paginated API",
            "prompt": "Create an API endpoint with cursor-based pagination and idempotency.",
            "difficulty": "medium",
            "hints": [
              "Use cursor query param",
              "Return idempotency key"
            ],
            "solution": "server.ts: import express from 'express'; const app = express(); app.get('/users', (req, res) => { const { cursor, limit = 20 } = req.query; const idempotencyKey = req.headers['idempotency-key'] || uuid(); const data = fetchUsers(cursor, limit); res.json({ data, nextCursor: 'xyz', idempotencyKey }); }); app.listen(3000);"
          }
        ],
        "quiz": [
          {
            "question": "What ensures API stability?",
            "options": [
              "Breaking changes",
              "Backward compatibility",
              "CSS",
              "JavaScript"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What’s best for large dataset pagination?",
            "options": [
              "Offset-based",
              "Cursor-based",
              "Page-based",
              "Limitless"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "API Design Best Practices",
            "url": "https://docs.microsoft.com/en-us/azure/architecture/best-practices/api-design",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf542",
        "lessonId": "68d1a7a6cd394e8cc4daf53d"
      },
      {
        "level": "Advanced",
        "explanation": "GraphQL schema federation enables modular, team-owned schemas, while persisted queries and subscriptions optimize performance and real-time updates. This lesson covers setting up a federated GraphQL architecture with Apollo Federation.",
        "examples": [
          "Federation: extend type User @key(fields: \"id\") { id: ID! }",
          "Subscription: subscription { messageAdded(channelId: \"1\") }"
        ],
        "realWorldApplication": "Used by Netflix and Airbnb for modular GraphQL APIs.",
        "expertInsights": "Use federation for team scalability. Persisted queries reduce client payload size.",
        "commonMistakes": [
          "Overcomplicating schemas, slowing queries.",
          "Not securing subscriptions, causing leaks."
        ],
        "exercises": [
          {
            "title": "Design a Federated Schema",
            "prompt": "Create a federated GraphQL schema with two services.",
            "difficulty": "hard",
            "hints": [
              "Use @key directive",
              "Combine in gateway"
            ],
            "solution": "user-service.graphql: extend type Query { user(id: ID!): User } type User @key(fields: \"id\") { id: ID! name: String } \ngateway.ts: import { ApolloGateway } from '@apollo/gateway'; const gateway = new ApolloGateway({ serviceList: [{ name: 'user', url: 'http://localhost:4001' }] });"
          }
        ],
        "quiz": [
          {
            "question": "What enables modular GraphQL schemas?",
            "options": [
              "REST",
              "Federation",
              "RPC",
              "CSS"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What optimizes GraphQL performance?",
            "options": [
              "Persisted queries",
              "Inline queries",
              "JavaScript",
              "SQL"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 100,
        "resources": [
          {
            "title": "Apollo Federation",
            "url": "https://www.apollographql.com/docs/federation/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf543",
        "lessonId": "68d1a7a6cd394e8cc4daf53e"
      },
      {
        "level": "Advanced",
        "explanation": "RPC and gRPC offer efficient, strongly-typed communication for internal services, contrasting with REST and GraphQL. This lesson compares their pros and cons and guides you through implementing a gRPC service for internal APIs.",
        "examples": [
          "gRPC: service UserService { rpc GetUser (UserRequest) returns (UserResponse); }",
          "RPC vs REST: RPC for internal, REST for public APIs."
        ],
        "realWorldApplication": "Used by Google and Uber for high-performance internal services.",
        "expertInsights": "Use gRPC for low-latency internal APIs. Avoid for public APIs due to complexity.",
        "commonMistakes": [
          "Using gRPC for client-facing APIs, complicating integration.",
          "Not handling errors in RPC, causing failures."
        ],
        "exercises": [
          {
            "title": "Implement a gRPC Service",
            "prompt": "Create a gRPC service for fetching user data.",
            "difficulty": "hard",
            "hints": [
              "Define .proto file",
              "Use grpc-js"
            ],
            "solution": "user.proto: syntax = \"proto3\"; service UserService { rpc GetUser (UserRequest) returns (UserResponse); } message UserRequest { string id = 1; } message UserResponse { string name = 1; }\nserver.ts: import * as grpc from '@grpc/grpc-js'; const server = new grpc.Server(); server.addService(UserService, { GetUser: (call, callback) => callback(null, { name: 'Test' }) }); server.bindAsync('0.0.0.0:50051', grpc.ServerCredentials.createInsecure(), () => server.start());"
          }
        ],
        "quiz": [
          {
            "question": "What is best for internal services?",
            "options": [
              "REST",
              "gRPC",
              "GraphQL",
              "CSS"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What defines gRPC contracts?",
            "options": [
              "JSON",
              ".proto files",
              "YAML",
              "XML"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 100,
        "resources": [
          {
            "title": "gRPC Documentation",
            "url": "https://grpc.io/docs/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf544",
        "lessonId": "68d1a7a6cd394e8cc4daf53f"
      },
      {
        "level": "Advanced",
        "explanation": "API gateways manage traffic, enforce throttling, and shape requests for scalability. This lesson covers setting up a gateway with tools like Kong or AWS API Gateway, configuring rate limiting, and optimizing request flows.",
        "examples": [
          "Kong: rate-limiting plugin for /api/users",
          "AWS API Gateway: Throttle at 1000 req/s."
        ],
        "realWorldApplication": "Used by Amazon and Shopify for scalable API management.",
        "expertInsights": "Use gateways for centralized auth and throttling. Monitor request patterns to adjust limits.",
        "commonMistakes": [
          "Not throttling, risking overloads.",
          "Overcomplicating gateway logic, slowing requests."
        ],
        "exercises": [
          {
            "title": "Set Up an API Gateway",
            "prompt": "Configure a gateway with rate limiting for an API endpoint.",
            "difficulty": "medium",
            "hints": [
              "Use Kong or AWS API Gateway",
              "Set rate-limit to 100 req/min"
            ],
            "solution": "kong.yaml: services:\n- name: user-service\n  url: http://user-service:8080\n  plugins:\n  - name: rate-limiting\n    config:\n      minute: 100\n  routes:\n  - name: users\n    paths:\n    - /api/users"
          }
        ],
        "quiz": [
          {
            "question": "What manages API traffic?",
            "options": [
              "CSS",
              "API Gateway",
              "JavaScript",
              "SQL"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What prevents API overload?",
            "options": [
              "Throttling",
              "Caching",
              "Pagination",
              "Subscriptions"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Kong Gateway Documentation",
            "url": "https://docs.konghq.com/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf545",
        "lessonId": "68d1a7a6cd394e8cc4daf540"
      },
      {
        "level": "Advanced",
        "explanation": "Contract testing ensures API compatibility across services, while governance with OpenAPI and schema registries enforces consistency. This lesson covers writing contract tests with Pact and managing schemas for team alignment.",
        "examples": [
          "Pact: contract.test.js for /users endpoint.",
          "OpenAPI: components: { schemas: { User: ... } }"
        ],
        "realWorldApplication": "Used by Atlassian and Spotify for consistent, reliable APIs across teams.",
        "expertInsights": "Use contract tests for microservices. Maintain a schema registry for governance.",
        "commonMistakes": [
          "Skipping contract tests, causing integration failures.",
          "Not versioning schemas, breaking consumers."
        ],
        "exercises": [
          {
            "title": "Write Contract Tests",
            "prompt": "Create a Pact contract test for a user API endpoint.",
            "difficulty": "hard",
            "hints": [
              "Define provider/consumer",
              "Test GET /users"
            ],
            "solution": "user.test.js: import { Pact } from '@pact-foundation/pact'; const provider = new Pact({ consumer: 'Client', provider: 'UserService' }); describe('User API', () => { it('returns user data', async () => { await provider.addInteraction({ state: 'user exists', uponReceiving: 'GET /users', withRequest: { method: 'GET', path: '/users' }, willRespondWith: { status: 200, body: { id: '1', name: 'Test' } } }); const response = await fetch('http://localhost:8080/users'); expect(response.status).toBe(200); }); });"
          }
        ],
        "quiz": [
          {
            "question": "What ensures API compatibility?",
            "options": [
              "Contract testing",
              "Unit testing",
              "CSS",
              "JavaScript"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What enforces API consistency?",
            "options": [
              "Schema registry",
              "Pagination",
              "Throttling",
              "Subscriptions"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Pact Contract Testing",
            "url": "https://docs.pact.io/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf546",
        "lessonId": "68d1a7a6cd394e8cc4daf541"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Distributed Systems",
        "slug": "distributed-systems",
        "description": "Design reliable, scalable distributed systems with strong consistency, event-driven architectures, and resilience patterns for large-scale applications.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf547"
      }
    ],
    "courses": [
      {
        "title": "Distributed Systems & Architecture Patterns",
        "slug": "distributed-systems-architecture",
        "shortDescription": "An advanced course on designing reliable, scalable distributed systems using CAP theorem, event-driven architectures, sagas, and resilience patterns.",
        "level": "Advanced",
        "longDescription": "This course dives deep into designing distributed systems, covering CAP theorem, event-driven architectures (event-sourcing, CQRS), saga patterns, message brokers (Kafka, RabbitMQ), service discovery, resilience strategies, and data sharding for multi-region systems. Through hands-on exercises, real-world examples, and quizzes, you’ll model an event-sourced order flow and implement retry/backoff strategies for unreliable services. The course equips you to architect robust distributed systems for enterprise-grade applications.",
        "tags": [
          "distributed-systems",
          "cap-theorem",
          "event-sourcing",
          "cqrs",
          "sagas",
          "message-brokers",
          "resilience",
          "sharding"
        ],
        "thumbnail": "https://example.com/thumbnails/distributed-systems.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Design reliable, scalable distributed systems with event-driven architectures, resilience patterns, and multi-region strategies.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf548",
        "domainId": "68d1a7a6cd394e8cc4daf547"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Distributed Systems & Architecture Patterns",
        "slug": "distributed-systems-architecture",
        "description": "Master CAP theorem, event-driven architectures, sagas, message brokers, resilience patterns, and data sharding for scalable distributed systems.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf549",
        "courseId": "68d1a7a6cd394e8cc4daf548",
        "lessonIds": [
          "68d1a7a6cd394e8cc4daf54a",
          "68d1a7a6cd394e8cc4daf54b",
          "68d1a7a6cd394e8cc4daf54c",
          "68d1a7a6cd394e8cc4daf54d",
          "68d1a7a6cd394e8cc4daf54e",
          "68d1a7a6cd394e8cc4daf54f"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "CAP Theorem and Consistency Models",
        "slug": "cap-consistency-models",
        "description": "Understand CAP theorem, consistency models, partitions, and leader election basics.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf54a",
        "moduleId": "68d1a7a6cd394e8cc4daf549",
        "contentId": "68d1a7a6cd394e8cc4daf550"
      },
      {
        "level": "Advanced",
        "title": "Event-Driven Architectures",
        "slug": "event-driven-architectures",
        "description": "Implement event-sourcing, CQRS, and idempotence patterns for scalable systems.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf54b",
        "moduleId": "68d1a7a6cd394e8cc4daf549",
        "contentId": "68d1a7a6cd394e8cc4daf551"
      },
      {
        "level": "Advanced",
        "title": "Sagas and Eventual Consistency",
        "slug": "sagas-eventual-consistency",
        "description": "Design sagas, compensation patterns, and eventual consistency for distributed workflows.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf54c",
        "moduleId": "68d1a7a6cd394e8cc4daf549",
        "contentId": "68d1a7a6cd394e8cc4daf552"
      },
      {
        "level": "Advanced",
        "title": "Message Brokers and Patterns",
        "slug": "message-brokers-patterns",
        "description": "Use Kafka and RabbitMQ with partitioning and retention strategies for messaging.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf54d",
        "moduleId": "68d1a7a6cd394e8cc4daf549",
        "contentId": "68d1a7a6cd394e8cc4daf553"
      },
      {
        "level": "Advanced",
        "title": "Service Discovery and Resilience",
        "slug": "service-discovery-resilience",
        "description": "Implement service discovery, circuit breakers, bulkheads, and retries for robust systems.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf54e",
        "moduleId": "68d1a7a6cd394e8cc4daf549",
        "contentId": "68d1a7a6cd394e8cc4daf554"
      },
      {
        "level": "Advanced",
        "title": "Data Sharding and Multi-Region Design",
        "slug": "data-sharding-multi-region",
        "description": "Apply data sharding and multi-region design for global scalability.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf54f",
        "moduleId": "68d1a7a6cd394e8cc4daf549",
        "contentId": "68d1a7a6cd394e8cc4daf555"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "CAP theorem defines trade-offs between consistency, availability, and partition tolerance in distributed systems. Consistency models (strong, eventual) and leader election ensure system reliability. This lesson covers applying CAP and leader election in system design.",
        "examples": [
          "Eventual Consistency: DynamoDB with eventual reads.",
          "Leader Election: Raft algorithm in etcd."
        ],
        "realWorldApplication": "Used by AWS DynamoDB and MongoDB for scalable, reliable data stores.",
        "expertInsights": "Choose eventual consistency for high availability. Use leader election for strong consistency needs.",
        "commonMistakes": [
          "Ignoring partition tolerance, causing outages.",
          "Assuming strong consistency is always needed."
        ],
        "exercises": [
          {
            "title": "Design a Consistent System",
            "prompt": "Model a system choosing between strong and eventual consistency under CAP constraints.",
            "difficulty": "medium",
            "hints": [
              "Consider availability needs",
              "Use Raft for leader election"
            ],
            "solution": "design.md: System: Key-value store. Choice: Eventual consistency (AP) for high availability. Leader election via Raft for write coordination. Example: GET /key may return stale data during partitions."
          }
        ],
        "quiz": [
          {
            "question": "What does CAP theorem balance?",
            "options": [
              "Consistency, Availability, Partition Tolerance",
              "Cost, Availability, Performance",
              "Consistency, Authentication, Partitioning",
              "Caching, Availability, Processing"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What ensures single leader in a cluster?",
            "options": [
              "Eventual consistency",
              "Leader election",
              "Sharding",
              "CQRS"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "CAP Theorem Explained",
            "url": "https://www.ibm.com/cloud/learn/cap-theorem",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf550",
        "lessonId": "68d1a7a6cd394e8cc4daf54a"
      },
      {
        "level": "Advanced",
        "explanation": "Event-driven architectures with event-sourcing and CQRS (Command Query Responsibility Segregation) enable scalable, decoupled systems. Idempotence ensures safe retries. This lesson covers implementing event-sourcing and CQRS for an order system.",
        "examples": [
          "Event-Sourcing: Store OrderCreated, OrderUpdated events.",
          "CQRS: Separate OrderCommand and OrderQuery services."
        ],
        "realWorldApplication": "Used by Uber and Netflix for scalable, event-driven systems.",
        "expertInsights": "Use event-sourcing for auditability. CQRS simplifies complex read/write logic.",
        "commonMistakes": [
          "Not ensuring idempotence, causing duplicate events.",
          "Mixing read/write logic without CQRS."
        ],
        "exercises": [
          {
            "title": "Model Event-Sourced Order Flow",
            "prompt": "Design an event-sourced order system with CQRS.",
            "difficulty": "hard",
            "hints": [
              "Store events like OrderCreated",
              "Separate command/query models"
            ],
            "solution": "order-system.ts: interface Event { type: string; data: any; } const events: Event[] = []; function createOrder(id: string) { events.push({ type: 'OrderCreated', data: { id, status: 'pending' } }); } function getOrder(id: string) { return events.reduce((state, event) => event.data.id === id ? event.data : state, {}); }"
          }
        ],
        "quiz": [
          {
            "question": "What stores state as events?",
            "options": [
              "CQRS",
              "Event-Sourcing",
              "Sharding",
              "Retries"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What separates read/write logic?",
            "options": [
              "Event-Sourcing",
              "CQRS",
              "Sagas",
              "Kafka"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Event Sourcing and CQRS",
            "url": "https://martinfowler.com/eaaDev/EventSourcing.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf551",
        "lessonId": "68d1a7a6cd394e8cc4daf54b"
      },
      {
        "level": "Advanced",
        "explanation": "Sagas orchestrate distributed transactions with compensation patterns to achieve eventual consistency. This lesson covers designing sagas to handle failures and ensure consistency in distributed workflows like order processing.",
        "examples": [
          "Saga: Order -> Payment -> Shipping, rollback on failure.",
          "Compensation: Refund payment if shipping fails."
        ],
        "realWorldApplication": "Used by Amazon and eBay for reliable e-commerce workflows.",
        "expertInsights": "Use sagas for long-running processes. Ensure compensations are idempotent.",
        "commonMistakes": [
          "Not implementing compensations, causing inconsistency.",
          "Overcomplicating sagas, slowing execution."
        ],
        "exercises": [
          {
            "title": "Design a Saga Workflow",
            "prompt": "Create a saga for an order process with compensation logic.",
            "difficulty": "hard",
            "hints": [
              "Define steps and compensations",
              "Ensure idempotence"
            ],
            "solution": "saga.ts: async function orderSaga(orderId: string) { try { await createOrder(orderId); await processPayment(orderId); await shipOrder(orderId); } catch (error) { if (error.step === 'shipping') await refundPayment(orderId); if (error.step === 'payment') await cancelOrder(orderId); throw error; } }"
          }
        ],
        "quiz": [
          {
            "question": "What orchestrates distributed transactions?",
            "options": [
              "Sagas",
              "CQRS",
              "Sharding",
              "Retries"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What ensures saga rollback?",
            "options": [
              "Event-Sourcing",
              "Compensation patterns",
              "Leader election",
              "Kafka"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Saga Pattern",
            "url": "https://microservices.io/patterns/data/saga.html",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf552",
        "lessonId": "68d1a7a6cd394e8cc4daf54c"
      },
      {
        "level": "Advanced",
        "explanation": "Message brokers like Kafka and RabbitMQ enable asynchronous communication with partitioning and retention strategies. This lesson covers configuring brokers for scalability and reliability in distributed systems.",
        "examples": [
          "Kafka: Topic with 3 partitions, retention 7 days.",
          "RabbitMQ: Queue with durable messages."
        ],
        "realWorldApplication": "Used by LinkedIn and Twitter for high-throughput messaging.",
        "expertInsights": "Use partitioning for scalability. Set retention based on data needs.",
        "commonMistakes": [
          "Not partitioning, limiting throughput.",
          "Setting infinite retention, causing storage issues."
        ],
        "exercises": [
          {
            "title": "Configure Kafka Topic",
            "prompt": "Set up a Kafka topic with partitioning and retention.",
            "difficulty": "medium",
            "hints": [
              "Use 3 partitions",
              "Set retention to 7 days"
            ],
            "solution": "kafka-config.sh: kafka-topics.sh --create --topic orders --partitions 3 --retention-ms 604800000 --bootstrap-server localhost:9092"
          }
        ],
        "quiz": [
          {
            "question": "What enables async communication?",
            "options": [
              "Message brokers",
              "REST APIs",
              "GraphQL",
              "CSS"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What improves Kafka scalability?",
            "options": [
              "Retention",
              "Partitioning",
              "CQRS",
              "Sagas"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Kafka Documentation",
            "url": "https://kafka.apache.org/documentation/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf553",
        "lessonId": "68d1a7a6cd394e8cc4daf54d"
      },
      {
        "level": "Advanced",
        "explanation": "Service discovery and resilience patterns like circuit breakers, bulkheads, and retries ensure robust systems. This lesson covers implementing service discovery with Consul and resilience with libraries like Polly or Resilience4j.",
        "examples": [
          "Consul: Register service with health checks.",
          "Circuit Breaker: Polly’s CircuitBreakerPolicy for retries."
        ],
        "realWorldApplication": "Used by Netflix and Google for resilient microservices.",
        "expertInsights": "Use circuit breakers for unreliable services. Implement retries with exponential backoff.",
        "commonMistakes": [
          "Not using circuit breakers, causing cascading failures.",
          "Aggressive retries, overloading services."
        ],
        "exercises": [
          {
            "title": "Implement Retry Strategy",
            "prompt": "Create a retry/backoff strategy for an unreliable service.",
            "difficulty": "hard",
            "hints": [
              "Use exponential backoff",
              "Limit retry attempts"
            ],
            "solution": "retry.ts: import { setTimeout } from 'timers/promises'; async function fetchWithRetry(url: string, retries = 3, backoff = 1000) { for (let i = 0; i < retries; i++) { try { return await fetch(url).then(res => res.json()); } catch (error) { if (i === retries - 1) throw error; await setTimeout(backoff * Math.pow(2, i)); } } }"
          }
        ],
        "quiz": [
          {
            "question": "What prevents cascading failures?",
            "options": [
              "Circuit breakers",
              "Event-Sourcing",
              "CQRS",
              "Sharding"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What enables dynamic service lookup?",
            "options": [
              "Service discovery",
              "Sagas",
              "Kafka",
              "Retries"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Consul Service Discovery",
            "url": "https://www.consul.io/docs/discovery",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf554",
        "lessonId": "68d1a7a6cd394e8cc4daf54e"
      },
      {
        "level": "Advanced",
        "explanation": "Data sharding and multi-region design distribute data for scalability and low latency. This lesson covers sharding strategies (hash-based, range-based) and designing systems for multi-region deployments with tools like CockroachDB.",
        "examples": [
          "Sharding: Hash user IDs to assign shards.",
          "Multi-Region: Replicate data across AWS regions."
        ],
        "realWorldApplication": "Used by Google Spanner and Shopify for global, scalable data stores.",
        "expertInsights": "Use hash-based sharding for even distribution. Plan for cross-region latency.",
        "commonMistakes": [
          "Poor shard key selection, causing hotspots.",
          "Ignoring latency in multi-region setups."
        ],
        "exercises": [
          {
            "title": "Design a Sharded System",
            "prompt": "Model a sharded database for user data with multi-region support.",
            "difficulty": "hard",
            "hints": [
              "Use hash-based sharding",
              "Replicate across regions"
            ],
            "solution": "sharding.sql: CREATE TABLE users (id BIGINT, shard_key BIGINT, name VARCHAR, PRIMARY KEY (shard_key, id)); INSERT INTO users (id, shard_key, name) VALUES (1, hash(id) % 4, 'Test'); -- Multi-region: Replicate to us-east-1, eu-west-1."
          }
        ],
        "quiz": [
          {
            "question": "What distributes data across nodes?",
            "options": [
              "Sharding",
              "CQRS",
              "Sagas",
              "Retries"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What reduces latency in global apps?",
            "options": [
              "Single-region",
              "Multi-region",
              "Event-Sourcing",
              "Kafka"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Database Sharding",
            "url": "https://www.cockroachlabs.com/docs/stable/sharding.html",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf555",
        "lessonId": "68d1a7a6cd394e8cc4daf54f"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Data Systems",
        "slug": "data-systems",
        "description": "Master advanced database and storage strategies for performance, scalability, and correctness across relational, NoSQL, and analytics systems.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf556"
      }
    ],
    "courses": [
      {
        "title": "Advanced Databases & Storage Strategies",
        "slug": "advanced-databases-storage",
        "shortDescription": "An advanced course on optimizing relational and NoSQL databases, search systems, object storage, and OLTP/OLAP pipelines for performance and correctness.",
        "level": "Advanced",
        "longDescription": "This course focuses on advanced database and storage strategies, covering deep PostgreSQL optimization, distributed NoSQL patterns, search and analytics with ElasticSearch or vector stores, object storage lifecycles, and OLTP/OLAP pipelines with ETL basics. Through hands-on exercises, real-world examples, and quizzes, you’ll optimize slow queries and design sharding/replica strategies. The course equips you to select and tune data stores for high-performance, scalable applications.",
        "tags": [
          "postgresql",
          "nosql",
          "elasticsearch",
          "object-storage",
          "oltp",
          "olap",
          "etl",
          "sharding"
        ],
        "thumbnail": "https://example.com/thumbnails/advanced-databases.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Optimize databases and storage systems for performance and correctness with advanced indexing, NoSQL patterns, and analytics pipelines.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf557",
        "domainId": "68d1a7a6cd394e8cc4daf556"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Advanced Databases & Storage Strategies",
        "slug": "advanced-databases-storage",
        "description": "Master PostgreSQL optimization, NoSQL patterns, search systems, object storage, and OLTP/OLAP pipelines for scalable data solutions.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf558",
        "courseId": "68d1a7a6cd394e8cc4daf557",
        "lessonIds": [
          "68d1a7a6cd394e8cc4daf559",
          "68d1a7a6cd394e8cc4daf55a",
          "68d1a7a6cd394e8cc4daf55b",
          "68d1a7a6cd394e8cc4daf55c",
          "68d1a7a6cd394e8cc4daf55d"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "Deep PostgreSQL Optimization",
        "slug": "deep-postgres-optimization",
        "description": "Master indexing strategies, query tuning, partitioning, and logical replication in PostgreSQL.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf559",
        "moduleId": "68d1a7a6cd394e8cc4daf558",
        "contentId": "68d1a7a6cd394e8cc4daf55e"
      },
      {
        "level": "Advanced",
        "title": "Distributed NoSQL Patterns",
        "slug": "distributed-nosql-patterns",
        "description": "Apply hot keys mitigation, anti-entropy, and TTLs in Cassandra, MongoDB, and DynamoDB.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf55a",
        "moduleId": "68d1a7a6cd394e8cc4daf558",
        "contentId": "68d1a7a6cd394e8cc4daf55f"
      },
      {
        "level": "Advanced",
        "title": "Search and Analytics",
        "slug": "search-analytics",
        "description": "Implement ElasticSearch/OpenSearch and vector stores for semantic search and analytics.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf55b",
        "moduleId": "68d1a7a6cd394e8cc4daf558",
        "contentId": "68d1a7a6cd394e8cc4daf560"
      },
      {
        "level": "Advanced",
        "title": "Object Storage Patterns",
        "slug": "object-storage-patterns",
        "description": "Design S3 lifecycles and optimize cost/IO for object storage.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf55c",
        "moduleId": "68d1a7a6cd394e8cc4daf558",
        "contentId": "68d1a7a6cd394e8cc4daf561"
      },
      {
        "level": "Advanced",
        "title": "OLTP vs OLAP Pipelines",
        "slug": "oltp-olap-pipelines",
        "description": "Understand OLTP vs OLAP, ETL basics, and data warehouses like BigQuery/Redshift.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf55d",
        "moduleId": "68d1a7a6cd394e8cc4daf558",
        "contentId": "68d1a7a6cd394e8cc4daf562"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "PostgreSQL optimization involves advanced indexing (e.g., B-tree, GIN), query tuning with EXPLAIN, partitioning for large datasets, and logical replication for scalability. This lesson covers techniques to boost performance and ensure correctness in PostgreSQL.",
        "examples": [
          "Index: CREATE INDEX idx_user_email ON users(email);",
          "Partitioning: CREATE TABLE orders PARTITION BY RANGE (created_at);"
        ],
        "realWorldApplication": "Used by GitLab and Atlassian for high-performance relational databases.",
        "expertInsights": "Use EXPLAIN ANALYZE to identify slow queries. Partition large tables to improve performance.",
        "commonMistakes": [
          "Over-indexing, increasing write latency.",
          "Not analyzing query plans, missing bottlenecks."
        ],
        "exercises": [
          {
            "title": "Optimize a Slow Query",
            "prompt": "Optimize a slow PostgreSQL query using indexes and EXPLAIN.",
            "difficulty": "medium",
            "hints": [
              "Run EXPLAIN to find bottlenecks",
              "Add appropriate index"
            ],
            "solution": "query.sql: EXPLAIN SELECT * FROM orders WHERE customer_id = 123; -- Slow query\nCREATE INDEX idx_orders_customer ON orders(customer_id);\nEXPLAIN SELECT * FROM orders WHERE customer_id = 123; -- Optimized"
          }
        ],
        "quiz": [
          {
            "question": "What identifies query bottlenecks in PostgreSQL?",
            "options": [
              "CREATE INDEX",
              "EXPLAIN ANALYZE",
              "ALTER TABLE",
              "SELECT"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What improves large table performance?",
            "options": [
              "Partitioning",
              "Dropping indexes",
              "Increasing connections",
              "Disabling replication"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "PostgreSQL Performance Tuning",
            "url": "https://www.postgresql.org/docs/current/performance-tips.html",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf55e",
        "lessonId": "68d1a7a6cd394e8cc4daf559"
      },
      {
        "level": "Advanced",
        "explanation": "Distributed NoSQL databases like Cassandra, MongoDB, and DynamoDB handle scale with patterns like hot key mitigation, anti-entropy, and TTLs. This lesson covers designing efficient NoSQL systems with these techniques.",
        "examples": [
          "Hot Key Fix: Spread reads across replicas.",
          "TTL: SET mykey \"value\" EX 3600 (Redis)."
        ],
        "realWorldApplication": "Used by Netflix and Uber for scalable, high-throughput data stores.",
        "expertInsights": "Avoid hot keys with proper data modeling. Use TTLs for ephemeral data.",
        "commonMistakes": [
          "Poor partition key choice, causing hotspots.",
          "Not using anti-entropy, leading to data inconsistency."
        ],
        "exercises": [
          {
            "title": "Design a Sharding/Replica Strategy",
            "prompt": "Create a sharding and replication strategy for a Cassandra user table.",
            "difficulty": "hard",
            "hints": [
              "Use a partition key",
              "Set replication factor"
            ],
            "solution": "schema.cql: CREATE KEYSPACE users WITH replication = {'class': 'SimpleStrategy', 'replication_factor': 3}; CREATE TABLE users.by_id (user_id UUID, name TEXT, PRIMARY KEY (user_id));"
          }
        ],
        "quiz": [
          {
            "question": "What causes performance issues in NoSQL?",
            "options": [
              "Hot keys",
              "Indexes",
              "Joins",
              "Views"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What ensures NoSQL data consistency?",
            "options": [
              "Anti-entropy",
              "Indexing",
              "TTL",
              "Sharding"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Cassandra Data Modeling",
            "url": "https://cassandra.apache.org/doc/latest/cassandra/data_modeling/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf55f",
        "lessonId": "68d1a7a6cd394e8cc4daf55a"
      },
      {
        "level": "Advanced",
        "explanation": "ElasticSearch/OpenSearch and vector stores enable powerful search and analytics, including semantic search with embeddings. This lesson covers setting up ElasticSearch for full-text search and vector stores for AI-driven queries.",
        "examples": [
          "ElasticSearch: { query: { match: { text: 'search' } } }",
          "Vector Search: KNN query with embeddings."
        ],
        "realWorldApplication": "Used by Airbnb and Amazon for search and recommendation systems.",
        "expertInsights": "Optimize ElasticSearch mappings for performance. Use vector stores for semantic queries.",
        "commonMistakes": [
          "Not defining mappings, slowing searches.",
          "Ignoring vector store indexing, reducing accuracy."
        ],
        "exercises": [
          {
            "title": "Set Up ElasticSearch",
            "prompt": "Create an ElasticSearch index for product search with optimized mappings.",
            "difficulty": "medium",
            "hints": [
              "Define text field mappings",
              "Use keyword for exact matches"
            ],
            "solution": "index.json: PUT /products { \"mappings\": { \"properties\": { \"name\": { \"type\": \"text\", \"fields\": { \"keyword\": { \"type\": \"keyword\" } } } } } }"
          }
        ],
        "quiz": [
          {
            "question": "What powers full-text search?",
            "options": [
              "ElasticSearch",
              "PostgreSQL",
              "Redis",
              "S3"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What enables semantic search?",
            "options": [
              "Vector stores",
              "B-tree indexes",
              "TTL",
              "Joins"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "ElasticSearch Guide",
            "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf560",
        "lessonId": "68d1a7a6cd394e8cc4daf55b"
      },
      {
        "level": "Advanced",
        "explanation": "Object storage like AWS S3 uses lifecycle policies and IO optimization to manage costs and performance. This lesson covers designing S3 buckets with lifecycle rules and optimizing access patterns.",
        "examples": [
          "S3 Lifecycle: Move to Glacier after 30 days.",
          "IO: Use multipart uploads for large files."
        ],
        "realWorldApplication": "Used by Dropbox and Netflix for scalable, cost-efficient storage.",
        "expertInsights": "Use lifecycle policies to reduce costs. Optimize IO with batch operations.",
        "commonMistakes": [
          "Not setting lifecycles, increasing costs.",
          "Using small, frequent writes, slowing performance."
        ],
        "exercises": [
          {
            "title": "Design S3 Lifecycle Policy",
            "prompt": "Create an S3 bucket with a lifecycle policy for archiving.",
            "difficulty": "medium",
            "hints": [
              "Move to Glacier after 30 days",
              "Delete after 365 days"
            ],
            "solution": "lifecycle.json: { \"Rules\": [{ \"ID\": \"Archive\", \"Status\": \"Enabled\", \"Filter\": { \"Prefix\": \"\" }, \"Transitions\": [{ \"Days\": 30, \"StorageClass\": \"GLACIER\" }], \"Expiration\": { \"Days\": 365 } }] }"
          }
        ],
        "quiz": [
          {
            "question": "What manages S3 data retention?",
            "options": [
              "Lifecycle policies",
              "Indexes",
              "Sharding",
              "Replication"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What optimizes large file uploads?",
            "options": [
              "Multipart uploads",
              "Single writes",
              "Indexes",
              "TTL"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "AWS S3 Lifecycle Management",
            "url": "https://docs.aws.amazon.com/AmazonS3/latest/userguide/object-lifecycle-mgmt.html",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf561",
        "lessonId": "68d1a7a6cd394e8cc4daf55c"
      },
      {
        "level": "Advanced",
        "explanation": "OLTP (Online Transaction Processing) and OLAP (Online Analytical Processing) serve different workloads, with ETL pipelines feeding data warehouses like BigQuery or Redshift. This lesson covers designing pipelines for transactional and analytical systems.",
        "examples": [
          "ETL: Extract from PostgreSQL, transform with Python, load to BigQuery.",
          "OLAP: SELECT COUNT(*) FROM sales GROUP BY region;"
        ],
        "realWorldApplication": "Used by Google and Snowflake for analytics and reporting.",
        "expertInsights": "Use OLTP for transactions, OLAP for analytics. Optimize ETL for incremental updates.",
        "commonMistakes": [
          "Running analytics on OLTP, slowing transactions.",
          "Not optimizing ETL, causing delays."
        ],
        "exercises": [
          {
            "title": "Design an ETL Pipeline",
            "prompt": "Create an ETL pipeline from PostgreSQL to BigQuery.",
            "difficulty": "hard",
            "hints": [
              "Extract with SQL",
              "Load incrementally"
            ],
            "solution": "etl.py: import pandas as pd; from google.cloud import bigquery; client = bigquery.Client(); df = pd.read_sql('SELECT * FROM orders WHERE updated_at > ?', conn, params=['2023-01-01']); df.to_gbq('dataset.orders', project_id='my-project', if_exists='append');"
          }
        ],
        "quiz": [
          {
            "question": "What handles transactional workloads?",
            "options": [
              "OLTP",
              "OLAP",
              "ETL",
              "S3"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What feeds data warehouses?",
            "options": [
              "Indexes",
              "ETL pipelines",
              "Sharding",
              "TTL"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "BigQuery ETL Guide",
            "url": "https://cloud.google.com/bigquery/docs/loading-data",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf562",
        "lessonId": "68d1a7a6cd394e8cc4daf55d"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Security Engineering",
        "slug": "security-engineering",
        "description": "Embed security into the SDLC by mastering threat modeling, advanced authentication, secure data practices, and compliance for robust systems.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf563"
      }
    ],
    "courses": [
      {
        "title": "Security Engineering & Threat Modeling (Advanced)",
        "slug": "security-engineering-threat-modeling",
        "shortDescription": "An advanced course on securing systems end-to-end with threat modeling, advanced authentication, secure data practices, and compliance.",
        "level": "Advanced",
        "longDescription": "This course focuses on advanced security engineering, covering threat modeling with STRIDE, OAuth2 and OIDC authentication flows, secure data practices like encryption and key rotation, application security against SSRF and XSS, supply chain security, and compliance with GDPR and PCI DSS. Through hands-on exercises, real-world examples, and quizzes, you’ll run a threat model on a capstone design and produce mitigations. The course equips you to build secure, compliant systems integrated into the SDLC.",
        "tags": [
          "threat-modeling",
          "oauth2",
          "oidc",
          "encryption",
          "application-security",
          "supply-chain",
          "compliance"
        ],
        "thumbnail": "https://example.com/thumbnails/security-engineering.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Secure systems with threat modeling, advanced authentication, encryption, and compliance practices embedded in the SDLC.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf564",
        "domainId": "68d1a7a6cd394e8cc4daf563"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Security Engineering & Threat Modeling",
        "slug": "security-engineering-threat-modeling",
        "description": "Master threat modeling, advanced authentication, secure data practices, application security, supply chain security, and compliance for robust systems.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf565",
        "courseId": "68d1a7a6cd394e8cc4daf564",
        "lessonIds": [
          "68d1a7a6cd394e8cc4daf566",
          "68d1a7a6cd394e8cc4daf567",
          "68d1a7a6cd394e8cc4daf568",
          "68d1a7a6cd394e8cc4daf569",
          "68d1a7a6cd394e8cc4daf56a",
          "68d1a7a6cd394e8cc4daf56b"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "Threat Modeling and Secure Design Patterns",
        "slug": "threat-modeling-secure-design",
        "description": "Apply STRIDE methodology and secure design patterns to identify and mitigate threats.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf566",
        "moduleId": "68d1a7a6cd394e8cc4daf565",
        "contentId": "68d1a7a6cd394e8cc4daf56c"
      },
      {
        "level": "Advanced",
        "title": "Advanced Authentication",
        "slug": "advanced-authentication",
        "description": "Implement OAuth2 flows, OIDC, token rotation, delegation, PKCE, and client credentials.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf567",
        "moduleId": "68d1a7a6cd394e8cc4daf565",
        "contentId": "68d1a7a6cd394e8cc4daf56d"
      },
      {
        "level": "Advanced",
        "title": "Secure Data Practices",
        "slug": "secure-data-practices",
        "description": "Use encryption at-rest and in-transit, key rotation, and envelope encryption for data security.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf568",
        "moduleId": "68d1a7a6cd394e8cc4daf565",
        "contentId": "68d1a7a6cd394e8cc4daf56e"
      },
      {
        "level": "Advanced",
        "title": "Application Security",
        "slug": "application-security",
        "description": "Mitigate SSRF, complex XSS scenarios, and tune content security policies.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf569",
        "moduleId": "68d1a7a6cd394e8cc4daf565",
        "contentId": "68d1a7a6cd394e8cc4daf56f"
      },
      {
        "level": "Advanced",
        "title": "Supply Chain Security",
        "slug": "supply-chain-security",
        "description": "Implement software composition analysis, signed artifacts, and reproducible builds.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf56a",
        "moduleId": "68d1a7a6cd394e8cc4daf565",
        "contentId": "68d1a7a6cd394e8cc4daf570"
      },
      {
        "level": "Advanced",
        "title": "Compliance Basics",
        "slug": "compliance-basics",
        "description": "Understand GDPR, PCI DSS, and payment-specific compliance requirements.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf56b",
        "moduleId": "68d1a7a6cd394e8cc4daf565",
        "contentId": "68d1a7a6cd394e8cc4daf571"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "Threat modeling with STRIDE (Spoofing, Tampering, Repudiation, Information Disclosure, Denial of Service, Elevation of Privilege) identifies risks early in system design. This lesson covers applying STRIDE and secure design patterns to mitigate threats.",
        "examples": [
          "STRIDE: Identify spoofing risks in user login.",
          "Secure Design: Principle of least privilege."
        ],
        "realWorldApplication": "Used by Microsoft and Google to secure large-scale systems.",
        "expertInsights": "Run threat models iteratively. Use STRIDE to prioritize mitigations.",
        "commonMistakes": [
          "Skipping threat modeling, missing vulnerabilities.",
          "Not involving stakeholders, reducing effectiveness."
        ],
        "exercises": [
          {
            "title": "Run a Threat Model",
            "prompt": "Apply STRIDE to a capstone system design and propose mitigations.",
            "difficulty": "hard",
            "hints": [
              "List assets and entry points",
              "Apply STRIDE categories"
            ],
            "solution": "threat-model.md: System: Payment API. Asset: User data. Entry: Login endpoint. STRIDE: Spoofing (unauthenticated access). Mitigation: Enforce OAuth2 with PKCE. Tampering: Mitigate with HMAC signatures."
          }
        ],
        "quiz": [
          {
            "question": "What identifies security risks in design?",
            "options": [
              "STRIDE",
              "OAuth2",
              "Encryption",
              "CSS"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What mitigates spoofing risks?",
            "options": [
              "Rate limiting",
              "Authentication",
              "Indexing",
              "Caching"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "STRIDE Threat Modeling",
            "url": "https://docs.microsoft.com/en-us/azure/security/develop/threat-modeling-tool-threats",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf56c",
        "lessonId": "68d1a7a6cd394e8cc4daf566"
      },
      {
        "level": "Advanced",
        "explanation": "Advanced authentication with OAuth2 and OIDC includes flows like authorization code, PKCE, client credentials, token rotation, and delegation. This lesson covers implementing secure authentication for various use cases.",
        "examples": [
          "OAuth2: Authorization code flow with PKCE.",
          "OIDC: ID token with user info endpoint."
        ],
        "realWorldApplication": "Used by Okta and Auth0 for secure identity management.",
        "expertInsights": "Use PKCE for public clients. Rotate tokens regularly to limit exposure.",
        "commonMistakes": [
          "Not using PKCE, risking token theft.",
          "Storing tokens insecurely, enabling leaks."
        ],
        "exercises": [
          {
            "title": "Implement OAuth2 with PKCE",
            "prompt": "Set up an OAuth2 authorization code flow with PKCE.",
            "difficulty": "hard",
            "hints": [
              "Generate code verifier/challenge",
              "Use secure token storage"
            ],
            "solution": "auth.js: import { randomBytes, createHash } from 'crypto'; const verifier = randomBytes(32).toString('base64url'); const challenge = createHash('sha256').update(verifier).digest('base64url'); const authUrl = `https://auth.example.com/authorize?response_type=code&client_id=abc&code_challenge=${challenge}&code_challenge_method=S256`;"
          }
        ],
        "quiz": [
          {
            "question": "What enhances OAuth2 security for public clients?",
            "options": [
              "PKCE",
              "Client credentials",
              "Token rotation",
              "HMAC"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What provides user identity in OIDC?",
            "options": [
              "Access token",
              "ID token",
              "Refresh token",
              "Client secret"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "OAuth2 Documentation",
            "url": "https://oauth.net/2/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf56d",
        "lessonId": "68d1a7a6cd394e8cc4daf567"
      },
      {
        "level": "Advanced",
        "explanation": "Secure data practices involve encryption at-rest and in-transit, key rotation, and envelope encryption to protect sensitive data. This lesson covers implementing encryption with tools like AWS KMS or OpenSSL.",
        "examples": [
          "At-Rest: AES-256 encryption with KMS key.",
          "In-Transit: TLS 1.3 for API endpoints."
        ],
        "realWorldApplication": "Used by AWS and Stripe for secure data handling.",
        "expertInsights": "Use envelope encryption for scalability. Rotate keys regularly with auditing.",
        "commonMistakes": [
          "Not encrypting sensitive data, risking breaches.",
          "Using weak ciphers, compromising security."
        ],
        "exercises": [
          {
            "title": "Implement Envelope Encryption",
            "prompt": "Encrypt data using AWS KMS with envelope encryption.",
            "difficulty": "hard",
            "hints": [
              "Generate data key with KMS",
              "Encrypt with AES"
            ],
            "solution": "encrypt.js: import AWS from 'aws-sdk'; const kms = new AWS.KMS(); async function encrypt(data) { const { Plaintext, CiphertextBlob } = await kms.generateDataKey({ KeyId: 'alias/my-key' }).promise(); const cipher = createCipheriv('aes-256-gcm', Plaintext, iv); const encrypted = cipher.update(data, 'utf8', 'hex'); return { encrypted, key: CiphertextBlob }; }"
          }
        ],
        "quiz": [
          {
            "question": "What secures data at-rest?",
            "options": [
              "TLS",
              "AES encryption",
              "OAuth2",
              "CSP"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What manages encryption keys?",
            "options": [
              "Key rotation",
              "Token rotation",
              "SSRF",
              "XSS"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "AWS KMS Encryption",
            "url": "https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf56e",
        "lessonId": "68d1a7a6cd394e8cc4daf568"
      },
      {
        "level": "Advanced",
        "explanation": "Application security mitigates risks like Server-Side Request Forgery (SSRF), complex Cross-Site Scripting (XSS), and misconfigured Content Security Policies (CSP). This lesson covers identifying and preventing these vulnerabilities.",
        "examples": [
          "SSRF Mitigation: Whitelist allowed URLs.",
          "CSP: Content-Security-Policy: default-src 'self';"
        ],
        "realWorldApplication": "Used by GitHub and Cloudflare to secure web applications.",
        "expertInsights": "Validate all inputs to prevent SSRF. Use strict CSP to block XSS.",
        "commonMistakes": [
          "Not validating URLs, enabling SSRF.",
          "Loose CSP, allowing XSS attacks."
        ],
        "exercises": [
          {
            "title": "Tune Content Security Policy",
            "prompt": "Configure a CSP to prevent XSS in a web app.",
            "difficulty": "medium",
            "hints": [
              "Set default-src to 'self'",
              "Restrict script-src"
            ],
            "solution": "server.js: import express from 'express'; const app = express(); app.use((req, res, next) => { res.set('Content-Security-Policy', \"default-src 'self'; script-src 'self' 'nonce-abc123'\"); next(); }); app.get('/', (req, res) => res.send('<script nonce=\"abc123\">...</script>')); app.listen(3000);"
          }
        ],
        "quiz": [
          {
            "question": "What prevents XSS attacks?",
            "options": [
              "SSRF",
              "CSP",
              "OAuth2",
              "Encryption"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What mitigates SSRF risks?",
            "options": [
              "URL whitelisting",
              "Token rotation",
              "Key rotation",
              "Caching"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "OWASP Application Security",
            "url": "https://owasp.org/www-project-top-ten/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf56f",
        "lessonId": "68d1a7a6cd394e8cc4daf569"
      },
      {
        "level": "Advanced",
        "explanation": "Supply chain security involves software composition analysis (SCA), signed artifacts, and reproducible builds to ensure trusted dependencies. This lesson covers securing the software supply chain with tools like Dependabot and Sigstore.",
        "examples": [
          "SCA: Dependabot scan for vulnerable packages.",
          "Signed Artifact: Cosign for container image signing."
        ],
        "realWorldApplication": "Used by Docker and GitHub for secure software delivery.",
        "expertInsights": "Automate SCA to catch vulnerabilities early. Use signed artifacts for trust.",
        "commonMistakes": [
          "Ignoring dependency vulnerabilities, risking exploits.",
          "Not verifying artifacts, enabling tampering."
        ],
        "exercises": [
          {
            "title": "Secure Supply Chain",
            "prompt": "Set up SCA and signed artifacts for a Node.js project.",
            "difficulty": "hard",
            "hints": [
              "Use Dependabot for SCA",
              "Sign with Cosign"
            ],
            "solution": "dependabot.yml: version: 2\nupdates:\n  - package-ecosystem: npm\n    directory: /\n    schedule: { interval: daily }\ncosign.sh: cosign sign --key cosign.key my-image:tag"
          }
        ],
        "quiz": [
          {
            "question": "What detects vulnerable dependencies?",
            "options": [
              "SCA",
              "CSP",
              "OAuth2",
              "SSRF"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What ensures artifact trust?",
            "options": [
              "Signed artifacts",
              "Key rotation",
              "Token rotation",
              "Encryption"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Sigstore Documentation",
            "url": "https://docs.sigstore.dev/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf570",
        "lessonId": "68d1a7a6cd394e8cc4daf56a"
      },
      {
        "level": "Advanced",
        "explanation": "Compliance with GDPR and PCI DSS ensures legal and secure handling of user data and payments. This lesson covers key requirements, such as data minimization, consent, and secure payment processing.",
        "examples": [
          "GDPR: Store minimal user data, obtain consent.",
          "PCI DSS: Tokenize credit card data."
        ],
        "realWorldApplication": "Used by Stripe and Shopify for compliant payment systems.",
        "expertInsights": "Implement GDPR consent flows early. Use tokenization for PCI DSS compliance.",
        "commonMistakes": [
          "Storing sensitive data unencrypted, violating GDPR.",
          "Not scoping PCI DSS, increasing audit complexity."
        ],
        "exercises": [
          {
            "title": "Design GDPR-Compliant Flow",
            "prompt": "Create a user consent flow for GDPR compliance.",
            "difficulty": "medium",
            "hints": [
              "Implement opt-in consent",
              "Minimize data collection"
            ],
            "solution": "consent.js: function handleConsent(userId, consent) { if (consent.optIn) { saveMinimalData(userId, { email: 'user@example.com' }); } else { deleteUserData(userId); } }"
          }
        ],
        "quiz": [
          {
            "question": "What requires user consent under GDPR?",
            "options": [
              "Data processing",
              "Encryption",
              "SSRF",
              "XSS"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What secures payment data for PCI DSS?",
            "options": [
              "Tokenization",
              "Indexing",
              "Caching",
              "Sharding"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "GDPR Compliance Guide",
            "url": "https://gdpr.eu/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf571",
        "lessonId": "68d1a7a6cd394e8cc4daf56b"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Site Reliability Engineering",
        "slug": "site-reliability-engineering",
        "description": "Implement observability, distributed tracing, and SLOs to ensure system reliability and performance in production environments.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf572"
      }
    ],
    "courses": [
      {
        "title": "Observability, Tracing & SLOs (SRE Practices)",
        "slug": "observability-tracing-slos",
        "shortDescription": "An advanced course on observability, distributed tracing, and SLOs to manage system reliability using modern SRE practices.",
        "level": "Advanced",
        "longDescription": "This course dives into observability and Site Reliability Engineering (SRE) practices, covering centralized logging, metrics with Prometheus and Grafana, distributed tracing with OpenTelemetry, alerting, SLO/SLI definition, and chaos engineering. Through hands-on exercises, real-world examples, and quizzes, you’ll instrument a service with OpenTelemetry and create an SLO dashboard. The course equips you to build observable, reliable systems with actionable reliability metrics.",
        "tags": [
          "observability",
          "distributed-tracing",
          "slos",
          "sre",
          "prometheus",
          "grafana",
          "opentelemetry",
          "chaos-engineering"
        ],
        "thumbnail": "https://example.com/thumbnails/observability-slos.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Build observable systems with centralized logging, tracing, metrics, SLOs, and chaos engineering for reliable production environments.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf573",
        "domainId": "68d1a7a6cd394e8cc4daf572"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Observability, Tracing & SLOs",
        "slug": "observability-tracing-slos",
        "description": "Master centralized logging, metrics, distributed tracing, alerting, SLOs, and chaos engineering for reliable systems.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf574",
        "courseId": "68d1a7a6cd394e8cc4daf573",
        "lessonIds": [
          "68d1a7a6cd394e8cc4daf575",
          "68d1a7a6cd394e8cc4daf576",
          "68d1a7a6cd394e8cc4daf577",
          "68d1a7a6cd394e8cc4daf578",
          "68d1a7a6cd394e8cc4daf579",
          "68d1a7a6cd394e8cc4daf57a"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "Centralized Logging and Retention",
        "slug": "centralized-logging",
        "description": "Implement centralized logging, structured logs, log sampling, and retention strategies.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf575",
        "moduleId": "68d1a7a6cd394e8cc4daf574",
        "contentId": "68d1a7a6cd394e8cc4daf57b"
      },
      {
        "level": "Advanced",
        "title": "Metrics and Dashboards",
        "slug": "metrics-dashboards",
        "description": "Set up Prometheus and Grafana for key metrics and cardinality control.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf576",
        "moduleId": "68d1a7a6cd394e8cc4daf574",
        "contentId": "68d1a7a6cd394e8cc4daf57c"
      },
      {
        "level": "Advanced",
        "title": "Distributed Tracing with OpenTelemetry",
        "slug": "distributed-tracing",
        "description": "Implement spans, traces, and tail-based sampling with OpenTelemetry.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf577",
        "moduleId": "68d1a7a6cd394e8cc4daf574",
        "contentId": "68d1a7a6cd394e8cc4daf57d"
      },
      {
        "level": "Advanced",
        "title": "Alerting and Incident Response",
        "slug": "alerting-incident-response",
        "description": "Design alerting systems, on-call processes, and incident response runbooks.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf578",
        "moduleId": "68d1a7a6cd394e8cc4daf574",
        "contentId": "68d1a7a6cd394e8cc4daf57e"
      },
      {
        "level": "Advanced",
        "title": "SLOs, SLIs, and Error Budgets",
        "slug": "slos-slis-error-budgets",
        "description": "Define SLOs/SLIs, measure error budgets, and act on reliability metrics.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf579",
        "moduleId": "68d1a7a6cd394e8cc4daf574",
        "contentId": "68d1a7a6cd394e8cc4daf57f"
      },
      {
        "level": "Advanced",
        "title": "Chaos Engineering Basics",
        "slug": "chaos-engineering",
        "description": "Implement failure injection and resilience testing for system reliability.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf57a",
        "moduleId": "68d1a7a6cd394e8cc4daf574",
        "contentId": "68d1a7a6cd394e8cc4daf580"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "Centralized logging with structured logs, sampling, and retention strategies enables efficient debugging and monitoring. This lesson covers setting up centralized logging with tools like ELK Stack or Fluentd, focusing on JSON logs and retention policies.",
        "examples": [
          "Structured Log: {\"level\": \"error\", \"message\": \"db failure\", \"timestamp\": \"2025-09-16T00:00:00Z\"}",
          "Retention: Keep logs for 30 days, sample 10% of verbose logs."
        ],
        "realWorldApplication": "Used by Netflix and Uber for production debugging and monitoring.",
        "expertInsights": "Use structured JSON logs for queryability. Sample verbose logs to reduce costs.",
        "commonMistakes": [
          "Unstructured logs, complicating searches.",
          "No retention policy, causing storage issues."
        ],
        "exercises": [
          {
            "title": "Set Up Centralized Logging",
            "prompt": "Configure structured logging with retention for a Node.js service.",
            "difficulty": "medium",
            "hints": [
              "Use Winston for structured logs",
              "Set 30-day retention"
            ],
            "solution": "logging.js: import winston from 'winston'; const logger = winston.createLogger({ format: winston.format.json(), transports: [new winston.transports.File({ filename: 'logs.json', maxFiles: 30, tailable: true })] }); logger.error('db failure');"
          }
        ],
        "quiz": [
          {
            "question": "What improves log queryability?",
            "options": [
              "Structured logs",
              "Unstructured logs",
              "Caching",
              "Sharding"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What reduces log storage costs?",
            "options": [
              "Sampling",
              "Indexing",
              "Encryption",
              "Compression"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "ELK Stack Logging",
            "url": "https://www.elastic.co/guide/en/elk-stack/current/index.html",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf57b",
        "lessonId": "68d1a7a6cd394e8cc4daf575"
      },
      {
        "level": "Advanced",
        "explanation": "Metrics and dashboards with Prometheus and Grafana provide insights into system health. Controlling cardinality prevents performance issues. This lesson covers setting up key metrics and dashboards for a service.",
        "examples": [
          "Prometheus: http_requests_total{status=\"200\"}",
          "Grafana: Dashboard for request latency."
        ],
        "realWorldApplication": "Used by GitLab and Cloudflare for system monitoring.",
        "expertInsights": "Keep cardinality low with selective labels. Use Grafana for actionable dashboards.",
        "commonMistakes": [
          "High cardinality, slowing Prometheus.",
          "Missing key metrics, reducing visibility."
        ],
        "exercises": [
          {
            "title": "Create a Prometheus Dashboard",
            "prompt": "Set up Prometheus metrics and a Grafana dashboard for request latency.",
            "difficulty": "medium",
            "hints": [
              "Expose latency metric",
              "Use Grafana to visualize"
            ],
            "solution": "metrics.js: import prom from 'prom-client'; const latency = new prom.Histogram({ name: 'http_request_duration_seconds', help: 'Request latency', buckets: [0.1, 0.5, 1] }); app.get('/', (req, res) => { const end = latency.startTimer(); res.send('OK'); end(); });"
          }
        ],
        "quiz": [
          {
            "question": "What stores time-series metrics?",
            "options": [
              "Prometheus",
              "Grafana",
              "OpenTelemetry",
              "ELK"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What impacts Prometheus performance?",
            "options": [
              "High cardinality",
              "Low latency",
              "Structured logs",
              "Sampling"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Prometheus Documentation",
            "url": "https://prometheus.io/docs/introduction/overview/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf57c",
        "lessonId": "68d1a7a6cd394e8cc4daf576"
      },
      {
        "level": "Advanced",
        "explanation": "Distributed tracing with OpenTelemetry tracks requests across services using spans and traces, with tail-based sampling for efficiency. This lesson covers instrumenting a service with OpenTelemetry for tracing.",
        "examples": [
          "Span: { name: 'process-payment', duration: 200ms }",
          "Trace: Parent span with child spans across services."
        ],
        "realWorldApplication": "Used by Uber and Shopify for request debugging.",
        "expertInsights": "Use tail-based sampling for high-volume systems. Instrument critical paths first.",
        "commonMistakes": [
          "Not instrumenting all services, losing trace context.",
          "Over-sampling traces, increasing costs."
        ],
        "exercises": [
          {
            "title": "Instrument with OpenTelemetry",
            "prompt": "Add OpenTelemetry tracing to a Node.js service.",
            "difficulty": "hard",
            "hints": [
              "Use OpenTelemetry SDK",
              "Export to Jaeger"
            ],
            "solution": "tracing.js: import { trace } from '@opentelemetry/api'; import { NodeSDK } from '@opentelemetry/sdk-node'; const sdk = new NodeSDK({ traceExporter: new JaegerExporter({ endpoint: 'http://localhost:14268/api/traces' }) }); sdk.start(); const tracer = trace.getTracer('my-service'); app.get('/', (req, res) => { tracer.startActiveSpan('handle-request', span => { res.send('OK'); span.end(); }); });"
          }
        ],
        "quiz": [
          {
            "question": "What tracks requests across services?",
            "options": [
              "Distributed tracing",
              "Logging",
              "Metrics",
              "Alerting"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What reduces tracing overhead?",
            "options": [
              "Tail-based sampling",
              "High cardinality",
              "Structured logs",
              "Error budgets"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "OpenTelemetry Documentation",
            "url": "https://opentelemetry.io/docs/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf57d",
        "lessonId": "68d1a7a6cd394e8cc4daf577"
      },
      {
        "level": "Advanced",
        "explanation": "Effective alerting and on-call processes, paired with incident response runbooks, ensure rapid issue resolution. This lesson covers designing alerts and runbooks for production incidents.",
        "examples": [
          "Alert: CPU usage > 80% for 5 minutes.",
          "Runbook: Restart service, check logs."
        ],
        "realWorldApplication": "Used by PagerDuty and Datadog for incident management.",
        "expertInsights": "Set actionable alerts with clear thresholds. Document runbooks for repeatability.",
        "commonMistakes": [
          "Over-alerting, causing fatigue.",
          "Vague runbooks, slowing resolution."
        ],
        "exercises": [
          {
            "title": "Design an Alerting System",
            "prompt": "Create a Prometheus alert and runbook for high latency.",
            "difficulty": "medium",
            "hints": [
              "Use PromQL for alert",
              "Document steps in runbook"
            ],
            "solution": "alerts.yml: groups:\n- name: latency\n  rules:\n  - alert: HighLatency\n    expr: histogram_quantile(0.95, sum(rate(http_request_duration_seconds_bucket[5m])) by (le)) > 1\n    for: 5m\n    annotations:\n      runbook: 'Check service logs, scale pods.'"
          }
        ],
        "quiz": [
          {
            "question": "What reduces alert fatigue?",
            "options": [
              "Actionable alerts",
              "Frequent alerts",
              "Unstructured logs",
              "High cardinality"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What guides incident resolution?",
            "options": [
              "Runbooks",
              "Traces",
              "Metrics",
              "Logs"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "PagerDuty Incident Response",
            "url": "https://response.pagerduty.com/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf57e",
        "lessonId": "68d1a7a6cd394e8cc4daf578"
      },
      {
        "level": "Advanced",
        "explanation": "Service Level Objectives (SLOs) and Indicators (SLIs) define reliability targets, with error budgets guiding trade-offs. This lesson covers defining SLOs/SLIs and creating dashboards to monitor them.",
        "examples": [
          "SLI: 99.9% API availability.",
          "Error Budget: 0.1% downtime per month."
        ],
        "realWorldApplication": "Used by Google and Spotify for reliability management.",
        "expertInsights": "Define SLIs based on user experience. Use error budgets to balance innovation and stability.",
        "commonMistakes": [
          "Setting unrealistic SLOs, causing burnout.",
          "Not monitoring error budgets, missing issues."
        ],
        "exercises": [
          {
            "title": "Create an SLO Dashboard",
            "prompt": "Design an SLO dashboard for API availability using Grafana.",
            "difficulty": "hard",
            "hints": [
              "Use Prometheus SLI metrics",
              "Visualize in Grafana"
            ],
            "solution": "slo.yml: groups:\n- name: slo\n  rules:\n  - record: slo:api_availability\n    expr: sum(rate(http_requests_total{status=\"200\"}[28d])) / sum(rate(http_requests_total[28d]))\ngrafana.json: { \"panels\": [{ \"type\": \"graph\", \"targets\": [{ \"expr\": \"slo:api_availability\", \"legendFormat\": \"API Availability\" }], \"thresholds\": [{ \"value\": 0.999, \"colorMode\": \"critical\" }] }] }"
          }
        ],
        "quiz": [
          {
            "question": "What measures user-facing reliability?",
            "options": [
              "SLIs",
              "Logs",
              "Traces",
              "Alerts"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What balances reliability and innovation?",
            "options": [
              "Error budgets",
              "Runbooks",
              "Sampling",
              "Cardinality"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "SRE SLO Guide",
            "url": "https://sre.google/sre-book/service-level-objectives/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf57f",
        "lessonId": "68d1a7a6cd394e8cc4daf579"
      },
      {
        "level": "Advanced",
        "explanation": "Chaos engineering tests system resilience through controlled failure injection. This lesson covers implementing chaos experiments with tools like Chaos Mesh to validate system reliability.",
        "examples": [
          "Chaos Mesh: Inject network latency in a pod.",
          "Failure: Simulate 50% service downtime."
        ],
        "realWorldApplication": "Used by Netflix and AWS for resilience testing.",
        "expertInsights": "Start with small failures. Monitor SLIs during chaos experiments.",
        "commonMistakes": [
          "Running chaos in production without monitoring.",
          "Not defining blast radius, causing outages."
        ],
        "exercises": [
          {
            "title": "Run a Chaos Experiment",
            "prompt": "Inject network latency into a service using Chaos Mesh.",
            "difficulty": "hard",
            "hints": [
              "Define chaos YAML",
              "Limit blast radius"
            ],
            "solution": "chaos.yml: apiVersion: chaos-mesh.org/v1alpha1\nkind: NetworkChaos\nmetadata:\n  name: latency\nspec:\n  action: delay\n  mode: one\n  selector:\n    namespaces:\n      - default\n    labelSelectors:\n      app: my-service\n  delay:\n    latency: 200ms\n  duration: 5m"
          }
        ],
        "quiz": [
          {
            "question": "What tests system resilience?",
            "options": [
              "Chaos engineering",
              "Distributed tracing",
              "SLOs",
              "Logging"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What limits chaos experiment impact?",
            "options": [
              "Blast radius",
              "Error budget",
              "Sampling",
              "Cardinality"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Chaos Mesh Documentation",
            "url": "https://chaos-mesh.org/docs/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf580",
        "lessonId": "68d1a7a6cd394e8cc4daf57a"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Performance Engineering",
        "slug": "performance-engineering",
        "description": "Optimize system latency, throughput, and cloud costs through advanced frontend, backend, caching, and cost engineering techniques.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf581"
      }
    ],
    "courses": [
      {
        "title": "Performance Engineering & Cost Optimization",
        "slug": "performance-engineering-cost-optimization",
        "shortDescription": "An advanced course on optimizing latency, throughput, and cloud spend with frontend, backend, caching, and cost engineering strategies.",
        "level": "Advanced",
        "longDescription": "This course focuses on performance engineering and cost optimization, covering frontend metrics like LCP/CLS/FID, backend optimization with connection pooling and async workers, caching and CDN strategies, cloud cost engineering, and performance budgets with CI integration. Through hands-on exercises, real-world examples, and quizzes, you’ll add caching to reduce database load and demonstrate cost/latency improvements. The course equips you to build high-performance, cost-efficient systems.",
        "tags": [
          "performance",
          "frontend-optimization",
          "backend-optimization",
          "caching",
          "cdn",
          "cost-engineering",
          "performance-budgets"
        ],
        "thumbnail": "https://example.com/thumbnails/performance-cost.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Optimize latency, throughput, and cloud costs with advanced performance and cost engineering techniques.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf582",
        "domainId": "68d1a7a6cd394e8cc4daf581"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Performance Engineering & Cost Optimization",
        "slug": "performance-engineering-cost-optimization",
        "description": "Master frontend and backend performance optimization, caching, CDN strategies, cost engineering, and performance budgets for efficient systems.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf583",
        "courseId": "68d1a7a6cd394e8cc4daf582",
        "lessonIds": [
          "68d1a7a6cd394e8cc4daf584",
          "68d1a7a6cd394e8cc4daf585",
          "68d1a7a6cd394e8cc4daf586",
          "68d1a7a6cd394e8cc4daf587",
          "68d1a7a6cd394e8cc4daf588"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "Frontend Performance Optimization",
        "slug": "frontend-performance",
        "description": "Improve LCP, CLS, and FID with image optimization and critical-path rendering.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf584",
        "moduleId": "68d1a7a6cd394e8cc4daf583",
        "contentId": "68d1a7a6cd394e8cc4daf589"
      },
      {
        "level": "Advanced",
        "title": "Backend Performance Optimization",
        "slug": "backend-performance",
        "description": "Optimize backend with connection pooling, query tuning, async workers, and batching.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf585",
        "moduleId": "68d1a7a6cd394e8cc4daf583",
        "contentId": "68d1a7a6cd394e8cc4daf58a"
      },
      {
        "level": "Advanced",
        "title": "Caching and CDN Strategies",
        "slug": "caching-cdn",
        "description": "Implement caching and CDN strategies with cache invalidation at scale.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf586",
        "moduleId": "68d1a7a6cd394e8cc4daf583",
        "contentId": "68d1a7a6cd394e8cc4daf58b"
      },
      {
        "level": "Advanced",
        "title": "Cost Engineering",
        "slug": "cost-engineering",
        "description": "Optimize cloud spend with right-sizing, reserved/savings plans, and spot instances.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf587",
        "moduleId": "68d1a7a6cd394e8cc4daf583",
        "contentId": "68d1a7a6cd394e8cc4daf58c"
      },
      {
        "level": "Advanced",
        "title": "Performance Budgets and Testing",
        "slug": "performance-budgets-testing",
        "description": "Define performance budgets and integrate automated perf checks in CI pipelines.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf588",
        "moduleId": "68d1a7a6cd394e8cc4daf583",
        "contentId": "68d1a7a6cd394e8cc4daf58d"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "Frontend performance focuses on improving Largest Contentful Paint (LCP), Cumulative Layout Shift (CLS), and First Input Delay (FID) through techniques like image optimization and critical-path rendering. This lesson covers optimizing web performance for better user experience.",
        "examples": [
          "Image: Use WebP with lazy loading.",
          "Critical CSS: Inline styles for above-the-fold content."
        ],
        "realWorldApplication": "Used by Shopify and Airbnb for fast-loading web apps.",
        "expertInsights": "Prioritize LCP for perceived speed. Minimize CLS with stable layouts.",
        "commonMistakes": [
          "Not optimizing images, increasing load times.",
          "Overloading JavaScript, delaying FID."
        ],
        "exercises": [
          {
            "title": "Optimize Frontend Performance",
            "prompt": "Optimize a webpage for LCP and CLS with image optimization.",
            "difficulty": "medium",
            "hints": [
              "Use WebP format",
              "Set explicit image dimensions"
            ],
            "solution": "index.html: <img src=\"image.webp\" loading=\"lazy\" width=\"300\" height=\"200\" style=\"critical: true;\"> <style>/* Inline critical CSS */</style>"
          }
        ],
        "quiz": [
          {
            "question": "What measures page render time?",
            "options": [
              "LCP",
              "CLS",
              "FID",
              "TTFB"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What improves image load times?",
            "options": [
              "WebP format",
              "PNG format",
              "JavaScript",
              "CSS"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Web Vitals Guide",
            "url": "https://web.dev/vitals/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf589",
        "lessonId": "68d1a7a6cd394e8cc4daf584"
      },
      {
        "level": "Advanced",
        "explanation": "Backend performance optimization involves connection pooling, query tuning, async workers, and batching to reduce latency and increase throughput. This lesson covers techniques to optimize backend systems like APIs and databases.",
        "examples": [
          "Connection Pooling: Use pgxpool for PostgreSQL.",
          "Batching: Combine multiple API calls into one."
        ],
        "realWorldApplication": "Used by Netflix and GitHub for high-throughput APIs.",
        "expertInsights": "Use connection pooling to reduce database overhead. Batch requests to minimize round-trips.",
        "commonMistakes": [
          "Not tuning queries, causing slow responses.",
          "Blocking I/O, reducing throughput."
        ],
        "exercises": [
          {
            "title": "Optimize Backend Query",
            "prompt": "Add connection pooling and batching to a Node.js API.",
            "difficulty": "hard",
            "hints": [
              "Use pgxpool for pooling",
              "Batch multiple queries"
            ],
            "solution": "server.js: import { Pool } from 'pg'; const pool = new Pool({ max: 20 }); app.post('/batch', async (req, res) => { const client = await pool.connect(); try { const result = await client.query('SELECT * FROM users WHERE id = ANY($1)', [req.body.ids]); res.json(result.rows); } finally { client.release(); } });"
          }
        ],
        "quiz": [
          {
            "question": "What reduces database overhead?",
            "options": [
              "Connection pooling",
              "Query batching",
              "Async workers",
              "All of the above"
            ],
            "correctOption": [
              3
            ]
          },
          {
            "question": "What minimizes API round-trips?",
            "options": [
              "Batching",
              "Caching",
              "Pooling",
              "Indexing"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "PostgreSQL Connection Pooling",
            "url": "https://node-postgres.com/features/pooling",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf58a",
        "lessonId": "68d1a7a6cd394e8cc4daf585"
      },
      {
        "level": "Advanced",
        "explanation": "Caching and Content Delivery Networks (CDNs) reduce latency and database load, with cache invalidation ensuring data freshness. This lesson covers implementing caching with Redis and CDNs like Cloudflare.",
        "examples": [
          "Redis: SETEX user:123 3600 data.",
          "CDN: Cache static assets with 1-year TTL."
        ],
        "realWorldApplication": "Used by Twitter and Shopify for fast content delivery.",
        "expertInsights": "Use Redis for in-memory caching. Invalidate caches carefully to avoid stale data.",
        "commonMistakes": [
          "Not invalidating caches, serving stale data.",
          "Caching dynamic data, causing inconsistencies."
        ],
        "exercises": [
          {
            "title": "Add Caching to Reduce DB Load",
            "prompt": "Implement Redis caching for a user API to reduce database load.",
            "difficulty": "hard",
            "hints": [
              "Cache with TTL",
              "Invalidate on update"
            ],
            "solution": "cache.js: import redis from 'redis'; const client = redis.createClient(); app.get('/user/:id', async (req, res) => { const cached = await client.get(`user:${req.params.id}`); if (cached) return res.json(JSON.parse(cached)); const user = await db.query('SELECT * FROM users WHERE id = $1', [req.params.id]); await client.setEx(`user:${req.params.id}`, 3600, JSON.stringify(user)); res.json(user); });"
          }
        ],
        "quiz": [
          {
            "question": "What reduces database load?",
            "options": [
              "Caching",
              "Batching",
              "Pooling",
              "All of the above"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What ensures cache freshness?",
            "options": [
              "Cache invalidation",
              "TTL",
              "CDN",
              "Indexing"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Redis Caching Guide",
            "url": "https://redis.io/docs/management/optimization/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf58b",
        "lessonId": "68d1a7a6cd394e8cc4daf586"
      },
      {
        "level": "Advanced",
        "explanation": "Cost engineering optimizes cloud spend through right-sizing instances, reserved/savings plans, spot instances, and caching to reduce egress/compute costs. This lesson covers cost optimization strategies in AWS or GCP.",
        "examples": [
          "Right-Sizing: Use t3.micro instead of t3.large.",
          "Spot Instances: Run batch jobs on EC2 spot."
        ],
        "realWorldApplication": "Used by Dropbox and Lyft for cost-efficient cloud infrastructure.",
        "expertInsights": "Use savings plans for predictable workloads. Leverage spot instances for fault-tolerant jobs.",
        "commonMistakes": [
          "Overprovisioning instances, wasting budget.",
          "Not using caching, increasing egress costs."
        ],
        "exercises": [
          {
            "title": "Optimize Cloud Costs",
            "prompt": "Configure caching and spot instances to reduce AWS costs.",
            "difficulty": "hard",
            "hints": [
              "Use Redis for caching",
              "Run jobs on spot instances"
            ],
            "solution": "cost.tf: resource \"aws_elasticache_cluster\" \"cache\" { engine = \"redis\" node_type = \"cache.t3.micro\" } resource \"aws_spot_instance_request\" \"batch\" { ami = \"ami-123\" instance_type = \"t3.micro\" spot_price = \"0.01\" }"
          }
        ],
        "quiz": [
          {
            "question": "What reduces cloud compute costs?",
            "options": [
              "Right-sizing",
              "Overprovisioning",
              "High cardinality",
              "Uncached data"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What runs cost-efficient batch jobs?",
            "options": [
              "Spot instances",
              "Reserved instances",
              "On-demand instances",
              "Dedicated hosts"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "AWS Cost Optimization",
            "url": "https://aws.amazon.com/architecture/cost-optimization/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf58c",
        "lessonId": "68d1a7a6cd394e8cc4daf587"
      },
      {
        "level": "Advanced",
        "explanation": "Performance budgets set latency/throughput targets, with regression testing and CI checks ensuring consistency. This lesson covers defining budgets and automating performance tests with tools like Lighthouse CI.",
        "examples": [
          "Budget: LCP < 2s, CLS < 0.1.",
          "CI: Run Lighthouse on every commit."
        ],
        "realWorldApplication": "Used by Google and Vercel for consistent performance.",
        "expertInsights": "Set realistic performance budgets. Automate tests to catch regressions early.",
        "commonMistakes": [
          "Not enforcing budgets, allowing regressions.",
          "Manual testing, missing issues."
        ],
        "exercises": [
          {
            "title": "Set Up Performance Budgets",
            "prompt": "Define a performance budget and add Lighthouse CI checks.",
            "difficulty": "medium",
            "hints": [
              "Set LCP and CLS limits",
              "Integrate with GitHub Actions"
            ],
            "solution": ".lighthouserc.js: module.exports = { ci: { assert: { budgets: [{ path: '/', resourceSizes: [{ resourceType: 'document', budget: 100 }], timings: [{ metric: 'largest-contentful-paint', budget: 2000 }, { metric: 'cumulative-layout-shift', budget: 0.1 }] }] } }; .github/workflows/ci.yml: jobs: lighthouse: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - run: npm install -g @lhci/cli@0.8.x - run: lhci autorun"
          }
        ],
        "quiz": [
          {
            "question": "What ensures consistent performance?",
            "options": [
              "Performance budgets",
              "Manual testing",
              "Uncached data",
              "Overprovisioning"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What catches performance regressions?",
            "options": [
              "CI checks",
              "Spot instances",
              "Caching",
              "Batching"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Lighthouse CI Guide",
            "url": "https://github.com/GoogleChrome/lighthouse-ci",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf58d",
        "lessonId": "68d1a7a6cd394e8cc4daf588"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Serverless and Edge Computing",
        "slug": "serverless-edge-computing",
        "description": "Leverage serverless and edge architectures for scalable, low-latency applications while understanding their limitations and trade-offs.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf58e"
      }
    ],
    "courses": [
      {
        "title": "Serverless & Edge Architectures (Advanced Use)",
        "slug": "serverless-edge-architectures",
        "shortDescription": "An advanced course on designing serverless and edge architectures, focusing on patterns, observability, and appropriate use cases.",
        "level": "Advanced",
        "longDescription": "This course explores advanced serverless and edge computing architectures, covering stateless function patterns, edge middleware with CDN workers, data locality and consistency, observability and cost management, and when to avoid serverless. Through hands-on exercises, real-world examples, and quizzes, you’ll build an edge function that serves prerendered content with personalized fragments. The course equips you to design scalable, low-latency systems while navigating serverless limitations.",
        "tags": [
          "serverless",
          "edge-computing",
          "cloudflare-workers",
          "vercel",
          "observability",
          "data-locality",
          "stateless"
        ],
        "thumbnail": "https://example.com/thumbnails/serverless-edge.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Design scalable serverless and edge architectures with patterns, observability, and awareness of limitations.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf58f",
        "domainId": "68d1a7a6cd394e8cc4daf58e"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Serverless & Edge Architectures",
        "slug": "serverless-edge-architectures",
        "description": "Master serverless patterns, edge computing, data locality, observability, and appropriate use cases for scalable architectures.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf590",
        "courseId": "68d1a7a6cd394e8cc4daf58f",
        "lessonIds": [
          "68d1a7a6cd394e8cc4daf591",
          "68d1a7a6cd394e8cc4daf592",
          "68d1a7a6cd394e8cc4daf593",
          "68d1a7a6cd394e8cc4daf594",
          "68d1a7a6cd394e8cc4daf595"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "Serverless Patterns",
        "slug": "serverless-patterns",
        "description": "Design stateless functions, manage cold starts, and evaluate provisioned concurrency trade-offs.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf591",
        "moduleId": "68d1a7a6cd394e8cc4daf590",
        "contentId": "68d1a7a6cd394e8cc4daf596"
      },
      {
        "level": "Advanced",
        "title": "Edge Computing",
        "slug": "edge-computing",
        "description": "Implement middleware and logic at the edge with Vercel or Cloudflare Workers.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf592",
        "moduleId": "68d1a7a6cd394e8cc4daf590",
        "contentId": "68d1a7a6cd394e8cc4daf597"
      },
      {
        "level": "Advanced",
        "title": "Data Locality and Consistency",
        "slug": "data-locality-consistency",
        "description": "Manage data locality, latency, and eventual consistency in edge architectures.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf593",
        "moduleId": "68d1a7a6cd394e8cc4daf590",
        "contentId": "68d1a7a6cd394e8cc4daf598"
      },
      {
        "level": "Advanced",
        "title": "Observability and Cost in Serverless",
        "slug": "serverless-observability-cost",
        "description": "Implement observability and cost patterns for serverless, with debugging techniques.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf594",
        "moduleId": "68d1a7a6cd394e8cc4daf590",
        "contentId": "68d1a7a6cd394e8cc4daf599"
      },
      {
        "level": "Advanced",
        "title": "When Not to Use Serverless",
        "slug": "serverless-limitations",
        "description": "Understand limitations of serverless for long-running jobs, heavy CPU, and stateful services.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf595",
        "moduleId": "68d1a7a6cd394e8cc4daf590",
        "contentId": "68d1a7a6cd394e8cc4daf59a"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "Serverless patterns leverage stateless functions for scalability, addressing cold starts and using provisioned concurrency to manage latency. This lesson covers designing serverless functions with AWS Lambda or similar platforms, optimizing for performance and cost.",
        "examples": [
          "Stateless Function: Lambda for user authentication.",
          "Provisioned Concurrency: Pre-warm 10 instances."
        ],
        "realWorldApplication": "Used by Netflix and Airbnb for event-driven workloads.",
        "expertInsights": "Minimize cold starts with provisioned concurrency. Keep functions stateless for scalability.",
        "commonMistakes": [
          "Ignoring cold starts, increasing latency.",
          "Storing state in functions, breaking scalability."
        ],
        "exercises": [
          {
            "title": "Design a Stateless Lambda Function",
            "prompt": "Create a stateless AWS Lambda function for processing user data.",
            "difficulty": "medium",
            "hints": [
              "Use JSON input/output",
              "Avoid local state"
            ],
            "solution": "lambda.js: exports.handler = async (event) => { const user = JSON.parse(event.body); return { statusCode: 200, body: JSON.stringify({ id: user.id, processed: true }) }; };"
          }
        ],
        "quiz": [
          {
            "question": "What reduces serverless latency?",
            "options": [
              "Provisioned concurrency",
              "Stateful functions",
              "Long timeouts",
              "Cold starts"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What ensures serverless scalability?",
            "options": [
              "Stateless design",
              "Local storage",
              "High memory",
              "Long-running jobs"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "AWS Lambda Best Practices",
            "url": "https://docs.aws.amazon.com/lambda/latest/dg/best-practices.html",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf596",
        "lessonId": "68d1a7a6cd394e8cc4daf591"
      },
      {
        "level": "Advanced",
        "explanation": "Edge computing with CDN workers (e.g., Cloudflare Workers, Vercel Edge Functions) enables low-latency processing at the network edge. This lesson covers implementing middleware and logic at the edge for performance.",
        "examples": [
          "Cloudflare Worker: Rewrite response headers.",
          "Vercel Edge: Serve prerendered content."
        ],
        "realWorldApplication": "Used by Vercel and Cloudflare for fast, global content delivery.",
        "expertInsights": "Run lightweight logic at the edge. Avoid heavy computation to maintain low latency.",
        "commonMistakes": [
          "Running complex logic at edge, increasing latency.",
          "Not caching edge responses, missing performance gains."
        ],
        "exercises": [
          {
            "title": "Build an Edge Function",
            "prompt": "Create a Cloudflare Worker to serve prerendered content with personalized fragments.",
            "difficulty": "hard",
            "hints": [
              "Use KV for prerendered content",
              "Inject user data dynamically"
            ],
            "solution": "worker.js: addEventListener('fetch', event => { event.respondWith(handleRequest(event.request)); }); async function handleRequest(request) { const prerendered = await KV.get('page'); const user = await getUser(request); return new Response(prerendered.replace('{{user}}', user.name), { headers: { 'Content-Type': 'text/html' } }); }"
          }
        ],
        "quiz": [
          {
            "question": "What runs logic at the network edge?",
            "options": [
              "CDN workers",
              "Lambda functions",
              "EC2 instances",
              "S3 buckets"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What improves edge performance?",
            "options": [
              "Lightweight logic",
              "Heavy computation",
              "Stateful services",
              "Long timeouts"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Cloudflare Workers Docs",
            "url": "https://developers.cloudflare.com/workers/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf597",
        "lessonId": "68d1a7a6cd394e8cc4daf592"
      },
      {
        "level": "Advanced",
        "explanation": "Data locality and eventual consistency at the edge reduce latency but introduce consistency challenges. This lesson covers managing data placement and consistency in edge architectures like Cloudflare’s Durable Objects.",
        "examples": [
          "Data Locality: Store user data in closest region.",
          "Eventual Consistency: Sync edge caches periodically."
        ],
        "realWorldApplication": "Used by Fastly and Akamai for low-latency content delivery.",
        "expertInsights": "Place data near users for speed. Use eventual consistency for non-critical data.",
        "commonMistakes": [
          "Assuming strong consistency at edge, causing errors.",
          "Ignoring latency, slowing user experience."
        ],
        "exercises": [
          {
            "title": "Manage Edge Data Locality",
            "prompt": "Design an edge system with data locality and eventual consistency.",
            "difficulty": "hard",
            "hints": [
              "Use KV for local storage",
              "Sync periodically"
            ],
            "solution": "edge-data.js: addEventListener('fetch', event => { event.respondWith(handleData(event.request)); }); async function handleData(request) { const region = request.cf.region; const data = await KV.get(`user:${userId}:${region}`) || await syncFromCentral(userId); return new Response(data); } async function syncFromCentral(userId) { const data = await fetchCentral(userId); await KV.put(`user:${userId}:${region}`, data, { expirationTtl: 3600 }); return data; }"
          }
        ],
        "quiz": [
          {
            "question": "What reduces edge latency?",
            "options": [
              "Data locality",
              "Centralized storage",
              "Strong consistency",
              "Long timeouts"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What suits non-critical edge data?",
            "options": [
              "Eventual consistency",
              "Strong consistency",
              "Local storage",
              "Heavy computation"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Cloudflare Durable Objects",
            "url": "https://developers.cloudflare.com/durable-objects/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf598",
        "lessonId": "68d1a7a6cd394e8cc4daf593"
      },
      {
        "level": "Advanced",
        "explanation": "Observability in serverless environments tracks function performance and costs, with debugging techniques like log aggregation and tracing. This lesson covers setting up observability with tools like AWS X-Ray or CloudWatch.",
        "examples": [
          "X-Ray: Trace Lambda execution.",
          "CloudWatch: Log function errors with metrics."
        ],
        "realWorldApplication": "Used by AWS and Vercel for serverless monitoring.",
        "expertInsights": "Use tracing for performance bottlenecks. Monitor costs to avoid overspending.",
        "commonMistakes": [
          "Not enabling tracing, missing bottlenecks.",
          "Ignoring cost metrics, leading to budget overruns."
        ],
        "exercises": [
          {
            "title": "Set Up Serverless Observability",
            "prompt": "Add X-Ray tracing and CloudWatch logs to a Lambda function.",
            "difficulty": "medium",
            "hints": [
              "Enable X-Ray in Lambda",
              "Log structured data"
            ],
            "solution": "lambda.js: import AWSXRay from 'aws-xray-sdk'; import { CloudWatchLogs } from 'aws-sdk'; AWSXRay.captureAWS(require('aws-sdk')); exports.handler = async (event) => { console.log({ event, level: 'info' }); return { statusCode: 200, body: JSON.stringify({ success: true }) }; };"
          }
        ],
        "quiz": [
          {
            "question": "What tracks serverless performance?",
            "options": [
              "Distributed tracing",
              "Caching",
              "Batching",
              "Indexing"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What monitors serverless costs?",
            "options": [
              "CloudWatch",
              "X-Ray",
              "S3",
              "DynamoDB"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "AWS X-Ray Guide",
            "url": "https://docs.aws.amazon.com/xray/latest/devguide/aws-xray.html",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf599",
        "lessonId": "68d1a7a6cd394e8cc4daf594"
      },
      {
        "level": "Advanced",
        "explanation": "Serverless is unsuitable for long-running jobs, heavy CPU tasks, or stateful services due to timeouts and resource constraints. This lesson covers identifying when to avoid serverless and choosing alternatives like containers or VMs.",
        "examples": [
          "Long-Running: Use ECS for batch processing.",
          "Stateful: Use Kubernetes for session persistence."
        ],
        "realWorldApplication": "Used by Spotify and Lyft for workload-specific architectures.",
        "expertInsights": "Avoid serverless for CPU-intensive tasks. Use containers for stateful apps.",
        "commonMistakes": [
          "Using serverless for long jobs, hitting timeouts.",
          "Assuming serverless fits all workloads, causing performance issues."
        ],
        "exercises": [
          {
            "title": "Evaluate Serverless Limitations",
            "prompt": "Design a system avoiding serverless for a CPU-intensive task.",
            "difficulty": "medium",
            "hints": [
              "Use ECS for compute",
              "Avoid Lambda timeouts"
            ],
            "solution": "ecs.tf: resource \"aws_ecs_task_definition\" \"batch\" { family = \"batch-job\" cpu = \"1024\" memory = \"2048\" container_definitions = jsonencode([{ name: \"batch\", image: \"my-image:latest\", essential: true }]) } resource \"aws_ecs_service\" \"batch-service\" { cluster = \"my-cluster\" task_definition = aws_ecs_task_definition.batch.arn desired_count = 1 }"
          }
        ],
        "quiz": [
          {
            "question": "What is unsuitable for serverless?",
            "options": [
              "Long-running jobs",
              "Stateless APIs",
              "Event-driven tasks",
              "Lightweight logic"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What handles stateful workloads better?",
            "options": [
              "Kubernetes",
              "Lambda",
              "Cloudflare Workers",
              "S3"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "AWS ECS Guide",
            "url": "https://docs.aws.amazon.com/AmazonECS/latest/developerguide/Welcome.html",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf59a",
        "lessonId": "68d1a7a6cd394e8cc4daf595"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "DevOps",
        "slug": "devops",
        "description": "Master advanced DevOps practices for reliable deployments and infrastructure management using CI/CD, GitOps, and Infrastructure as Code.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf59b"
      }
    ],
    "courses": [
      {
        "title": "Advanced DevOps: CI/CD, GitOps & IaC (Terraform/Pulumi)",
        "slug": "advanced-devops-cicd-gitops-iac",
        "shortDescription": "An advanced course on CI/CD pipelines, GitOps workflows, and Infrastructure as Code for reliable deployments.",
        "level": "Advanced",
        "longDescription": "This course dives into advanced DevOps practices, covering GitOps workflows, Terraform/Pulumi for IaC, secure secrets management, pipeline hardening, progressive delivery, and disaster recovery. Through hands-on exercises, real-world examples, and quizzes, you’ll implement a GitHub Action to test, build, and deploy to a staging environment using Terraform. The course equips you to manage infrastructure and deployments with reliability and security.",
        "tags": [
          "devops",
          "cicd",
          "gitops",
          "infrastructure-as-code",
          "terraform",
          "secrets-management",
          "progressive-delivery",
          "disaster-recovery"
        ],
        "thumbnail": "https://example.com/thumbnails/advanced-devops.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Deploy reliably and manage infrastructure as code using CI/CD, GitOps, and Terraform/Pulumi.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf59c",
        "domainId": "68d1a7a6cd394e8cc4daf59b"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Advanced DevOps: CI/CD, GitOps & IaC",
        "slug": "advanced-devops-cicd-gitops-iac",
        "description": "Master GitOps, Terraform, secrets management, pipeline hardening, progressive delivery, and disaster recovery for reliable infrastructure.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf59d",
        "courseId": "68d1a7a6cd394e8cc4daf59c",
        "lessonIds": [
          "68d1a7a6cd394e8cc4daf59e",
          "68d1a7a6cd394e8cc4daf59f",
          "68d1a7a6cd394e8cc4daf5a0",
          "68d1a7a6cd394e8cc4daf5a1",
          "68d1a7a6cd394e8cc4daf5a2",
          "68d1a7a6cd394e8cc4daf5a3"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "GitOps Workflows and Safe Rollouts",
        "slug": "gitops-workflows",
        "description": "Implement GitOps workflows, environment promotion, and safe rollouts using canary and blue/green deployments.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf59e",
        "moduleId": "68d1a7a6cd394e8cc4daf59d",
        "contentId": "68d1a7a6cd394e8cc4daf5a4"
      },
      {
        "level": "Advanced",
        "title": "Advanced Terraform",
        "slug": "advanced-terraform",
        "description": "Use Terraform modules, remote state, drift detection, and testing with Terratest.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf59f",
        "moduleId": "68d1a7a6cd394e8cc4daf59d",
        "contentId": "68d1a7a6cd394e8cc4daf5a5"
      },
      {
        "level": "Advanced",
        "title": "Secure Secrets Management and Policy-as-Code",
        "slug": "secrets-management-policy",
        "description": "Implement secure secrets management with Vault or KMS and policy-as-code with OPA.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5a0",
        "moduleId": "68d1a7a6cd394e8cc4daf59d",
        "contentId": "68d1a7a6cd394e8cc4daf5a6"
      },
      {
        "level": "Advanced",
        "title": "Pipeline Hardening",
        "slug": "pipeline-hardening",
        "description": "Secure CI/CD pipelines with secrets, ephemeral runners, and artifact signing.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5a1",
        "moduleId": "68d1a7a6cd394e8cc4daf59d",
        "contentId": "68d1a7a6cd394e8cc4daf5a7"
      },
      {
        "level": "Advanced",
        "title": "Progressive Delivery and Feature Flags",
        "slug": "progressive-delivery-flags",
        "description": "Implement progressive delivery and feature flags with tools like LaunchDarkly or Unleash.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5a2",
        "moduleId": "68d1a7a6cd394e8cc4daf59d",
        "contentId": "68d1a7a6cd394e8cc4daf5a8"
      },
      {
        "level": "Advanced",
        "title": "Disaster Recovery and Runbooks",
        "slug": "disaster-recovery-runbooks",
        "description": "Design disaster recovery strategies, backup plans, and test DR scenarios.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5a3",
        "moduleId": "68d1a7a6cd394e8cc4daf59d",
        "contentId": "68d1a7a6cd394e8cc4daf5a9"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "GitOps uses Git as the single source of truth for infrastructure and application deployments, enabling safe rollouts like canary and blue/green deployments. This lesson covers setting up GitOps workflows with tools like ArgoCD for environment promotion and rollback strategies.",
        "examples": [
          "Canary: Deploy to 10% of users, monitor, then scale to 100%.",
          "Blue/Green: Run two identical environments, switch traffic instantly."
        ],
        "realWorldApplication": "Used by GitLab and Weaveworks for automated, auditable deployments.",
        "expertInsights": "Use declarative Git configs for reproducibility. Always test rollouts in lower environments first.",
        "commonMistakes": [
          "Not validating Git configs, leading to deployment failures.",
          "Skipping rollback plans, risking prolonged outages."
        ],
        "exercises": [
          {
            "title": "Set Up a GitOps Canary Deployment",
            "prompt": "Configure an ArgoCD application for a canary rollout of a web app.",
            "difficulty": "hard",
            "hints": [
              "Use ArgoCD Application CRD",
              "Define canary steps with weights"
            ],
            "solution": "app.yaml: apiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  name: web-app\nspec:\n  destination:\n    namespace: staging\n    server: https://kubernetes.default.svc\n  source:\n    repoURL: https://github.com/org/app.git\n    path: manifests\n  syncPolicy:\n    automated:\n      prune: true\n    syncOptions:\n      - CreateNamespace=true\n  rollout:\n    strategy:\n      canary:\n        steps:\n        - setWeight: 10\n        - pause: { duration: 5m }\n        - setWeight: 50\n        - pause: { duration: 5m }"
          }
        ],
        "quiz": [
          {
            "question": "What drives GitOps workflows?",
            "options": [
              "Git as source of truth",
              "Manual CLI commands",
              "Database triggers",
              "Cron jobs"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What ensures low-risk rollouts?",
            "options": [
              "Canary deployment",
              "Full deployment",
              "Manual testing",
              "Local builds"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 150,
        "resources": [
          {
            "title": "ArgoCD Getting Started",
            "url": "https://argo-cd.readthedocs.io/en/stable/getting_started/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5a4",
        "lessonId": "68d1a7a6cd394e8cc4daf59e"
      },
      {
        "level": "Advanced",
        "explanation": "Advanced Terraform usage involves modular design, remote state for collaboration, drift detection for consistency, and testing with Terratest. This lesson covers structuring scalable Terraform projects and validating configurations.",
        "examples": [
          "Module: Reusable VPC with subnets and security groups.",
          "Remote State: Store in S3 with locking via DynamoDB."
        ],
        "realWorldApplication": "Used by HashiCorp and AWS for large-scale infrastructure management.",
        "expertInsights": "Break configs into modules for maintainability. Use Terratest for automated validation.",
        "commonMistakes": [
          "Hardcoding values in Terraform, reducing flexibility.",
          "Ignoring drift detection, leading to configuration mismatches."
        ],
        "exercises": [
          {
            "title": "Create a Modular Terraform Project",
            "prompt": "Build a Terraform module for an EC2 instance with remote state and drift detection.",
            "difficulty": "hard",
            "hints": [
              "Use S3 backend for state",
              "Write Terratest for validation"
            ],
            "solution": "main.tf: module \"ec2\" { source = \"./modules/ec2\" instance_type = \"t3.micro\" } terraform { backend \"s3\" { bucket = \"my-state\" key = \"prod.tfstate\" region = \"us-east-1\" dynamodb_table = \"state-locking\" } } modules/ec2/main.tf: resource \"aws_instance\" \"app\" { ami = \"ami-123\" instance_type = var.instance_type } test/ec2_test.go: package test import (\"testing\" \"github.com/gruntwork-io/terratest/modules/terraform\") func TestEC2(t *testing.T) { opts := &terraform.Options{TerraformDir: \"..\"} terraform.InitAndApply(t, opts) instanceID := terraform.Output(t, opts, \"instance_id\") }"
          }
        ],
        "quiz": [
          {
            "question": "What enables Terraform collaboration?",
            "options": [
              "Remote state",
              "Local state",
              "Hardcoded configs",
              "Manual backups"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What detects infrastructure mismatches?",
            "options": [
              "Drift detection",
              "Canary deployment",
              "Feature flags",
              "Secrets management"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 150,
        "resources": [
          {
            "title": "Terraform Remote State",
            "url": "https://www.terraform.io/docs/language/state/remote.html",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5a5",
        "lessonId": "68d1a7a6cd394e8cc4daf59f"
      },
      {
        "level": "Advanced",
        "explanation": "Secure secrets management with tools like HashiCorp Vault or AWS KMS, combined with policy-as-code using OPA, ensures secure and auditable access control. This lesson covers integrating these tools for secure infrastructure.",
        "examples": [
          "Vault: Store API keys with dynamic secrets.",
          "OPA: Enforce RBAC policies for deployments."
        ],
        "realWorldApplication": "Used by AWS and Google for secure infrastructure management.",
        "expertInsights": "Rotate secrets regularly. Use OPA for fine-grained policy enforcement.",
        "commonMistakes": [
          "Storing secrets in plain text, risking leaks.",
          "Overly permissive policies, compromising security."
        ],
        "exercises": [
          {
            "title": "Set Up Secrets Management",
            "prompt": "Configure Vault for secrets and OPA for policy enforcement.",
            "difficulty": "hard",
            "hints": [
              "Use Vault for secret storage",
              "Define OPA policy for access"
            ],
            "solution": "vault.hcl: path \"secret/data/app\" { capabilities = [\"read\"] } opa.rego: package auth default allow = false allow { input.user == \"admin\" input.action == \"read\" }"
          }
        ],
        "quiz": [
          {
            "question": "What securely stores secrets?",
            "options": [
              "HashiCorp Vault",
              "Git repository",
              "Local files",
              "Environment variables"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What enforces policy-as-code?",
            "options": [
              "OPA",
              "Terraform",
              "ArgoCD",
              "LaunchDarkly"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "HashiCorp Vault Documentation",
            "url": "https://www.vaultproject.io/docs",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5a6",
        "lessonId": "68d1a7a6cd394e8cc4daf5a0"
      },
      {
        "level": "Advanced",
        "explanation": "Pipeline hardening secures CI/CD workflows with encrypted secrets, ephemeral runners, and artifact signing to ensure integrity. This lesson covers securing GitHub Actions or similar pipelines.",
        "examples": [
          "Ephemeral Runner: Spin up temporary GitHub runner.",
          "Artifact Signing: Use GPG for build verification."
        ],
        "realWorldApplication": "Used by GitHub and CircleCI for secure build pipelines.",
        "expertInsights": "Use ephemeral runners to reduce attack surface. Sign artifacts for trust.",
        "commonMistakes": [
          "Hardcoding secrets in pipelines, risking exposure.",
          "Not signing artifacts, allowing tampering."
        ],
        "exercises": [
          {
            "title": "Harden a CI/CD Pipeline",
            "prompt": "Create a secure GitHub Action with secrets and artifact signing.",
            "difficulty": "hard",
            "hints": [
              "Use GitHub secrets",
              "Sign artifacts with GPG"
            ],
            "solution": ".github/workflows/ci.yml: name: Secure CI on: push jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - run: echo ${{ secrets.API_KEY }} | gpg --sign > artifact.sig"
          }
        ],
        "quiz": [
          {
            "question": "What reduces pipeline attack surface?",
            "options": [
              "Ephemeral runners",
              "Persistent runners",
              "Plaintext secrets",
              "Manual builds"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What ensures artifact integrity?",
            "options": [
              "Artifact signing",
              "Caching",
              "Batching",
              "Logging"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "GitHub Actions Security",
            "url": "https://docs.github.com/en/actions/security-guides",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5a7",
        "lessonId": "68d1a7a6cd394e8cc4daf5a1"
      },
      {
        "level": "Advanced",
        "explanation": "Progressive delivery with feature flags allows controlled rollouts and experimentation. Tools like LaunchDarkly or Unleash enable dynamic feature toggling. This lesson covers integrating feature flags into deployments.",
        "examples": [
          "Feature Flag: Enable new UI for 10% of users.",
          "Progressive Delivery: Gradually increase flag exposure."
        ],
        "realWorldApplication": "Used by Netflix and Spotify for controlled feature releases.",
        "expertInsights": "Use flags for A/B testing. Monitor metrics to validate features.",
        "commonMistakes": [
          "Not cleaning up old flags, causing tech debt.",
          "Rolling out untested features, breaking UX."
        ],
        "exercises": [
          {
            "title": "Implement Feature Flags",
            "prompt": "Add a feature flag for a new API endpoint using Unleash.",
            "difficulty": "medium",
            "hints": [
              "Use Unleash SDK",
              "Toggle endpoint access"
            ],
            "solution": "app.js: import { Unleash } from 'unleash-client'; const unleash = new Unleash({ url: 'http://unleash:4242/api' }); app.get('/new-feature', async (req, res) => { if (await unleash.isEnabled('new-api')) { res.json({ feature: 'enabled' }); } else { res.status(404).json({ error: 'Feature disabled' }); } });"
          }
        ],
        "quiz": [
          {
            "question": "What enables controlled feature rollouts?",
            "options": [
              "Feature flags",
              "Canary deployments",
              "Blue/green deployments",
              "All of the above"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What tool manages feature flags?",
            "options": [
              "LaunchDarkly",
              "Terraform",
              "Vault",
              "ArgoCD"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Unleash Feature Flags",
            "url": "https://docs.getunleash.io/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5a8",
        "lessonId": "68d1a7a6cd394e8cc4daf5a2"
      },
      {
        "level": "Advanced",
        "explanation": "Disaster recovery (DR) involves backup strategies, runbooks, and regular DR testing to ensure system resilience. This lesson covers designing and testing DR plans for infrastructure.",
        "examples": [
          "Backup: Daily S3 snapshots with versioning.",
          "Runbook: Steps to restore RDS from backup."
        ],
        "realWorldApplication": "Used by AWS and Google Cloud for high availability.",
        "expertInsights": "Test DR plans quarterly. Document runbooks clearly for quick recovery.",
        "commonMistakes": [
          "Not testing backups, risking data loss.",
          "Vague runbooks, slowing recovery."
        ],
        "exercises": [
          {
            "title": "Design a DR Runbook",
            "prompt": "Create a runbook for restoring an RDS instance from a backup.",
            "difficulty": "medium",
            "hints": [
              "Use AWS CLI for restore",
              "Document steps clearly"
            ],
            "solution": "runbook.md: # RDS DR Runbook\n1. Identify latest backup: aws rds describe-db-snapshots\n2. Restore: aws rds restore-db-instance-from-db-snapshot --db-instance-identifier new-db --db-snapshot-identifier snapshot-id\n3. Verify: Check connection to new-db\n4. Update DNS: Route 53 to new-db endpoint"
          }
        ],
        "quiz": [
          {
            "question": "What ensures system resilience?",
            "options": [
              "Disaster recovery",
              "Feature flags",
              "Canary deployments",
              "Secrets management"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What guides recovery processes?",
            "options": [
              "Runbooks",
              "Modules",
              "Pipelines",
              "Flags"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "AWS Disaster Recovery",
            "url": "https://aws.amazon.com/disaster-recovery/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5a9",
        "lessonId": "68d1a7a6cd394e8cc4daf5a3"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Machine Learning Integration",
        "slug": "machine-learning-integration",
        "description": "Integrate machine learning features into web applications with focus on system design, monitoring, and responsible AI practices.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5aa"
      }
    ],
    "courses": [
      {
        "title": "Machine Learning Integration & Data-Driven Features",
        "slug": "ml-integration-data-driven",
        "shortDescription": "An advanced course on integrating ML features safely into web apps with system design, monitoring, and responsible AI.",
        "level": "Advanced",
        "longDescription": "This course covers integrating machine learning into web applications, focusing on ML system design, feature stores, model monitoring, embeddings for semantic search, and responsible AI practices. Through hands-on exercises, real-world examples, and quizzes, you’ll add a semantic search endpoint using embeddings and instrument model latency metrics. The course prepares you to build data-driven features with safety and performance in mind.",
        "tags": [
          "machine-learning",
          "model-serving",
          "feature-stores",
          "model-monitoring",
          "embeddings",
          "responsible-ai"
        ],
        "thumbnail": "https://example.com/thumbnails/ml-integration.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Integrate ML features safely into web apps with system design, monitoring, and responsible AI practices.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5ab",
        "domainId": "68d1a7a6cd394e8cc4daf5aa"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Machine Learning Integration & Data-Driven Features",
        "slug": "ml-integration-data-driven",
        "description": "Learn ML system design, feature stores, model monitoring, embeddings, and responsible AI for web applications.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5ac",
        "courseId": "68d1a7a6cd394e8cc4daf5ab",
        "lessonIds": [
          "68d1a7a6cd394e8cc4daf5ad",
          "68d1a7a6cd394e8cc4daf5ae",
          "68d1a7a6cd394e8cc4daf5af",
          "68d1a7a6cd394e8cc4daf5b0",
          "68d1a7a6cd394e8cc4daf5b1"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "ML System Design",
        "slug": "ml-system-design",
        "description": "Design ML systems with model serving, latency vs throughput trade-offs, and batching strategies.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5ad",
        "moduleId": "68d1a7a6cd394e8cc4daf5ac",
        "contentId": "68d1a7a6cd394e8cc4daf5b2"
      },
      {
        "level": "Advanced",
        "title": "Feature Stores & Data Pipelines",
        "slug": "feature-stores-pipelines",
        "description": "Build feature stores and data pipelines for reproducible ML workflows.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5ae",
        "moduleId": "68d1a7a6cd394e8cc4daf5ac",
        "contentId": "68d1a7a6cd394e8cc4daf5b3"
      },
      {
        "level": "Advanced",
        "title": "Model Monitoring and Drift Detection",
        "slug": "model-monitoring-drift",
        "description": "Monitor models for drift detection, A/B testing, and performance metrics.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5af",
        "moduleId": "68d1a7a6cd394e8cc4daf5ac",
        "contentId": "68d1a7a6cd394e8cc4daf5b4"
      },
      {
        "level": "Advanced",
        "title": "Embeddings and Semantic Search",
        "slug": "embeddings-semantic-search",
        "description": "Use embeddings for semantic search and privacy-preserving ML with PII considerations.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5b0",
        "moduleId": "68d1a7a6cd394e8cc4daf5ac",
        "contentId": "68d1a7a6cd394e8cc4daf5b5"
      },
      {
        "level": "Advanced",
        "title": "Responsible AI Practices",
        "slug": "responsible-ai",
        "description": "Apply bias mitigation, explainability, and privacy considerations in ML systems.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5b1",
        "moduleId": "68d1a7a6cd394e8cc4daf5ac",
        "contentId": "68d1a7a6cd394e8cc4daf5b6"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "ML system design balances latency and throughput with model serving strategies like batching and provisioned inference. This lesson covers designing ML pipelines for web apps, optimizing for real-time vs. batch inference.",
        "examples": [
          "Batching: Process 100 requests in one model call.",
          "Provisioned: AWS SageMaker endpoints for low latency."
        ],
        "realWorldApplication": "Used by recommendation systems in Netflix and Amazon.",
        "expertInsights": "Use batching for throughput, provisioned for latency. Monitor model serving metrics.",
        "commonMistakes": [
          "Ignoring cold starts, increasing latency.",
          "Over-batching, delaying responses."
        ],
        "exercises": [
          {
            "title": "Design an ML Serving Pipeline",
            "prompt": "Design a model serving endpoint with batching for image classification.",
            "difficulty": "medium",
            "hints": [
              "Use TensorFlow Serving",
              "Batch size of 32"
            ],
            "solution": "serving.py: import tensorflow as tf; model = tf.saved_model.load('model'); @tf.function def predict(images): return model.signatures['serving_default'](images=tf.stack(images));"
          }
        ],
        "quiz": [
          {
            "question": "What optimizes ML inference throughput?",
            "options": [
              "Batching",
              "Single requests",
              "Cold starts",
              "Low memory"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What reduces ML latency?",
            "options": [
              "Provisioned concurrency",
              "Batching",
              "Eventual consistency",
              "Sharding"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "TensorFlow Serving Guide",
            "url": "https://www.tensorflow.org/tfx/guide/serving",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5b2",
        "lessonId": "68d1a7a6cd394e8cc4daf5ad"
      },
      {
        "level": "Advanced",
        "explanation": "Feature stores centralize feature engineering for reproducibility, with data pipelines ensuring consistent ML workflows. This lesson covers building feature stores with tools like Feast and designing pipelines for ML reproducibility.",
        "examples": [
          "Feast: Define feature views for user data.",
          "Pipeline: Extract from Kafka, transform, load to feature store."
        ],
        "realWorldApplication": "Used by Uber and Airbnb for reproducible ML models.",
        "expertInsights": "Version features for traceability. Use online/offline stores for real-time/batch ML.",
        "commonMistakes": [
          "Not versioning features, causing model drift.",
          "Skipping pipeline testing, leading to errors."
        ],
        "exercises": [
          {
            "title": "Build a Feature Pipeline",
            "prompt": "Design a feature pipeline for user recommendations.",
            "difficulty": "hard",
            "hints": [
              "Use Feast for store",
              "ETL from database"
            ],
            "solution": "feature.yaml: project: my-project\nentity: user\nfeature_view:\n  name: user_features\n  entities: [user]\n  ttl: 86400\n  features:\n    - name: age\n      dtype: int64"
          }
        ],
        "quiz": [
          {
            "question": "What centralizes features for ML?",
            "options": [
              "Feature stores",
              "Databases",
              "Caches",
              "APIs"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What ensures ML reproducibility?",
            "options": [
              "Feature versioning",
              "Model training",
              "Data labeling",
              "GPU allocation"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Feast Feature Store",
            "url": "https://feast.dev/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5b3",
        "lessonId": "68d1a7a6cd394e8cc4daf5ae"
      },
      {
        "level": "Advanced",
        "explanation": "Model monitoring detects drift, performance degradation, and data quality issues. A/B testing compares model versions. This lesson covers implementing monitoring with tools like Arize or WhyLabs.",
        "examples": [
          "Drift Detection: Compare input distributions.",
          "A/B Test: Route 50% traffic to new model."
        ],
        "realWorldApplication": "Used by Meta and Uber for production ML monitoring.",
        "expertInsights": "Monitor input/output distributions for drift. Use A/B testing for safe rollouts.",
        "commonMistakes": [
          "Ignoring model drift, degrading predictions.",
          "Not monitoring latency, impacting UX."
        ],
        "exercises": [
          {
            "title": "Instrument Model Monitoring",
            "prompt": "Add drift detection and latency metrics to a model endpoint.",
            "difficulty": "hard",
            "hints": [
              "Log input/output",
              "Compare distributions"
            ],
            "solution": "monitor.js: import { Histogram } from 'prom-client'; const latency = new Histogram({ name: 'model_latency', help: 'Model inference time' }); app.post('/predict', async (req, res) => { const end = latency.startTimer(); const prediction = model.predict(req.body.input); end(); logDistribution(req.body.input, prediction); res.json(prediction); });"
          }
        ],
        "quiz": [
          {
            "question": "What detects model degradation?",
            "options": [
              "Drift detection",
              "Caching",
              "Indexing",
              "Sharding"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What compares model versions?",
            "options": [
              "A/B testing",
              "Feature stores",
              "ETL",
              "Batching"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Arize ML Monitoring",
            "url": "https://arize.com/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5b4",
        "lessonId": "68d1a7a6cd394e8cc4daf5af"
      },
      {
        "level": "Advanced",
        "explanation": "Embeddings enable semantic search by converting text to vectors, while privacy-preserving ML handles PII with techniques like differential privacy. This lesson covers generating embeddings with Hugging Face and implementing privacy safeguards.",
        "examples": [
          "Embeddings: sentence-transformers for text vectors.",
          "PII: Anonymize user data before model training."
        ],
        "realWorldApplication": "Used by Google Search and ChatGPT for semantic understanding.",
        "expertInsights": "Use sentence embeddings for search. Anonymize PII to comply with privacy laws.",
        "commonMistakes": [
          "Not normalizing embeddings, reducing accuracy.",
          "Training on PII, risking privacy violations."
        ],
        "exercises": [
          {
            "title": "Add Semantic Search Endpoint",
            "prompt": "Implement a semantic search endpoint using embeddings.",
            "difficulty": "hard",
            "hints": [
              "Use Hugging Face transformers",
              "Cosine similarity for search"
            ],
            "solution": "search.js: import { pipeline } from '@huggingface/transformers'; const embedder = await pipeline('feature-extraction', 'sentence-transformers/all-MiniLM-L6-v2'); app.post('/search', async (req, res) => { const query = req.body.query; const queryEmbedding = await embedder(query); const results = db.find({ embedding: { $cosine: queryEmbedding } }); res.json(results); });"
          }
        ],
        "quiz": [
          {
            "question": "What enables semantic search?",
            "options": [
              "Keywords",
              "Embeddings",
              "Indexes",
              "Joins"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What protects PII in ML?",
            "options": [
              "Encryption",
              "Anonymization",
              "Sharding",
              "TTL"
            ],
            "correctOption": [
              1
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Hugging Face Transformers",
            "url": "https://huggingface.co/docs/transformers/index",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5b5",
        "lessonId": "68d1a7a6cd394e8cc4daf5b0"
      },
      {
        "level": "Advanced",
        "explanation": "Responsible AI involves bias mitigation, explainability, and privacy to ensure ethical ML systems. This lesson covers detecting bias in models, basic explainability techniques, and privacy considerations like differential privacy.",
        "examples": [
          "Bias: Check for skewed predictions across demographics.",
          "Explainability: SHAP values for feature importance."
        ],
        "realWorldApplication": "Used by IBM and Google for ethical AI in production systems.",
        "expertInsights": "Audit models for bias regularly. Use explainability for regulatory compliance.",
        "commonMistakes": [
          "Ignoring bias, causing unfair outcomes.",
          "Overlooking privacy, risking data breaches."
        ],
        "exercises": [
          {
            "title": "Instrument Model Latency & Errors",
            "prompt": "Add latency and error metrics to an ML endpoint.",
            "difficulty": "medium",
            "hints": [
              "Use Prometheus Histogram",
              "Log errors"
            ],
            "solution": "metrics.js: import { Histogram, Counter } from 'prom-client'; const latency = new Histogram({ name: 'model_inference_duration_seconds', help: 'Model inference time' }); const errors = new Counter({ name: 'model_errors_total', help: 'Model errors' }); app.post('/predict', async (req, res) => { const end = latency.startTimer(); try { const prediction = await model.predict(req.body.input); end(); res.json(prediction); } catch (error) { end(); errors.inc(); res.status(500).json({ error: 'Prediction failed' }); } });"
          }
        ],
        "quiz": [
          {
            "question": "What mitigates AI bias?",
            "options": [
              "Caching",
              "Auditing",
              "Sharding",
              "TTL"
            ],
            "correctOption": [
              1
            ]
          },
          {
            "question": "What ensures AI explainability?",
            "options": [
              "SHAP values",
              "Indexes",
              "Joins",
              "Batching"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Responsible AI Practices",
            "url": "https://ai.google/responsibility/responsible-ai-practices/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5b6",
        "lessonId": "68d1a7a6cd394e8cc4daf5b1"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Enterprise Architecture",
        "slug": "enterprise-architecture",
        "description": "Design scalable multi-tenant SaaS systems with robust observability and operational controls.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5b7"
      }
    ],
    "courses": [
      {
        "title": "Enterprise Patterns: Multi-Tenant & Observability at Scale",
        "slug": "enterprise-patterns-multitenant-observability",
        "shortDescription": "An advanced course on designing multi-tenant SaaS systems with tenant isolation, billing, observability, and compliance.",
        "level": "Advanced",
        "longDescription": "This course focuses on enterprise-grade multi-tenant SaaS patterns, covering isolation strategies, billing and metering, tenant-aware observability, data residency, and tenant onboarding. Through hands-on exercises, real-world examples, and quizzes, you’ll design a multi-tenant data model and simulate tenant onboarding/migration. The course equips you to build scalable, secure, and compliant SaaS systems with robust operational controls.",
        "tags": [
          "multi-tenant",
          "saas",
          "observability",
          "billing",
          "data-residency",
          "tenant-onboarding",
          "compliance"
        ],
        "thumbnail": "https://example.com/thumbnails/multitenant-observability.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Design SaaS patterns for multi-tenancy with tenant isolation, observability, and compliance.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5b8",
        "domainId": "68d1a7a6cd394e8cc4daf5b7"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Enterprise Patterns: Multi-Tenant & Observability",
        "slug": "enterprise-patterns-multitenant-observability",
        "description": "Master multi-tenant isolation, billing, observability, compliance, and onboarding for scalable SaaS systems.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5b9",
        "courseId": "68d1a7a6cd394e8cc4daf5b8",
        "lessonIds": [
          "68d1a7a6cd394e8cc4daf5ba",
          "68d1a7a6cd394e8cc4daf5bb",
          "68d1a7a6cd394e8cc4daf5bc",
          "68d1a7a6cd394e8cc4daf5bd",
          "68d1a7a6cd394e8cc4daf5be"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "Multi-Tenant Isolation Strategies",
        "slug": "multi-tenant-isolation",
        "description": "Design multi-tenant systems with schema-per-tenant, shared schema, or DB-per-tenant isolation.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5ba",
        "moduleId": "68d1a7a6cd394e8cc4daf5b9",
        "contentId": "68d1a7a6cd394e8cc4daf5bf"
      },
      {
        "level": "Advanced",
        "title": "Billing and Metering Patterns",
        "slug": "billing-metering",
        "description": "Implement billing, metering, rate limiting, and quota enforcement for multi-tenant systems.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5bb",
        "moduleId": "68d1a7a6cd394e8cc4daf5b9",
        "contentId": "68d1a7a6cd394e8cc4daf5c0"
      },
      {
        "level": "Advanced",
        "title": "Tenant-Aware Observability",
        "slug": "tenant-aware-observability",
        "description": "Set up tenant-aware observability with isolated logs, metrics, and cross-tenant blast radius controls.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5bc",
        "moduleId": "68d1a7a6cd394e8cc4daf5b9",
        "contentId": "68d1a7a6cd394e8cc4daf5c1"
      },
      {
        "level": "Advanced",
        "title": "Data Residency and Compliance",
        "slug": "data-residency-compliance",
        "description": "Ensure data residency, regional compliance, and tenant-specific backups and restores.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5bd",
        "moduleId": "68d1a7a6cd394e8cc4daf5b9",
        "contentId": "68d1a7a6cd394e8cc4daf5c2"
      },
      {
        "level": "Advanced",
        "title": "Tenant Onboarding and Migration",
        "slug": "tenant-onboarding-migration",
        "description": "Design tenant onboarding, migration strategies, and independent scaling for tenants.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5be",
        "moduleId": "68d1a7a6cd394e8cc4daf5b9",
        "contentId": "68d1a7a6cd394e8cc4daf5c3"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "Multi-tenant isolation strategies like schema-per-tenant, shared schema, or DB-per-tenant ensure data separation and scalability. This lesson covers designing isolation models for SaaS applications.",
        "examples": [
          "Schema-per-tenant: Separate PostgreSQL schemas per tenant.",
          "DB-per-tenant: Dedicated DynamoDB instance per tenant."
        ],
        "realWorldApplication": "Used by Salesforce and Slack for tenant isolation.",
        "expertInsights": "Choose schema-per-tenant for cost efficiency, DB-per-tenant for strict isolation.",
        "commonMistakes": [
          "Using shared schema without tenant IDs, risking data leaks.",
          "Over-provisioning DBs, increasing costs."
        ],
        "exercises": [
          {
            "title": "Design a Multi-Tenant Data Model",
            "prompt": "Create a schema-per-tenant PostgreSQL model for a SaaS app.",
            "difficulty": "hard",
            "hints": [
              "Use tenant_id in tables",
              "Create separate schemas"
            ],
            "solution": "schema.sql: CREATE SCHEMA tenant1; CREATE TABLE tenant1.users (id SERIAL PRIMARY KEY, tenant_id UUID, name TEXT); CREATE SCHEMA tenant2; CREATE TABLE tenant2.users (id SERIAL PRIMARY KEY, tenant_id UUID, name TEXT);"
          }
        ],
        "quiz": [
          {
            "question": "What ensures strict tenant isolation?",
            "options": [
              "DB-per-tenant",
              "Shared schema",
              "Single DB",
              "No tenant IDs"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What is cost-efficient for many tenants?",
            "options": [
              "Schema-per-tenant",
              "DB-per-tenant",
              "Single table",
              "Shared DB"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Multi-Tenancy in SaaS",
            "url": "https://aws.amazon.com/architecture/saas/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5bf",
        "lessonId": "68d1a7a6cd394e8cc4daf5ba"
      },
      {
        "level": "Advanced",
        "explanation": "Billing and metering patterns track tenant usage, enforce rate limits, and manage quotas. This lesson covers implementing billing systems and rate limiting in multi-tenant applications.",
        "examples": [
          "Metering: Track API calls per tenant.",
          "Rate Limiting: Restrict tenant to 1000 requests/hour."
        ],
        "realWorldApplication": "Used by Stripe and Twilio for usage-based billing.",
        "expertInsights": "Use time-series DBs for metering. Enforce quotas at the API gateway.",
        "commonMistakes": [
          "Not tracking usage, leading to billing disputes.",
          "Weak rate limiting, allowing abuse."
        ],
        "exercises": [
          {
            "title": "Implement Tenant Rate Limiting",
            "prompt": "Set up API rate limiting for tenants using Redis.",
            "difficulty": "hard",
            "hints": [
              "Use Redis for rate tracking",
              "Enforce per-tenant limits"
            ],
            "solution": "rate-limit.js: import redis from 'redis'; const client = redis.createClient(); app.use(async (req, res, next) => { const tenantId = req.headers['tenant-id']; const key = `rate:${tenantId}`; const count = await client.incr(key); if (count === 1) await client.expire(key, 3600); if (count > 1000) return res.status(429).json({ error: 'Rate limit exceeded' }); next(); });"
          }
        ],
        "quiz": [
          {
            "question": "What tracks tenant usage?",
            "options": [
              "Metering",
              "Logging",
              "Caching",
              "Sharding"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What prevents tenant abuse?",
            "options": [
              "Rate limiting",
              "Backups",
              "Indexing",
              "Batching"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Stripe Billing Docs",
            "url": "https://stripe.com/docs/billing",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5c0",
        "lessonId": "68d1a7a6cd394e8cc4daf5bb"
      },
      {
        "level": "Advanced",
        "explanation": "Tenant-aware observability isolates logs and metrics per tenant while controlling cross-tenant blast radius. This lesson covers setting up observability with tools like Prometheus and Grafana.",
        "examples": [
          "Logs: Tag logs with tenant_id in Fluentd.",
          "Metrics: Prometheus tenant-specific dashboards."
        ],
        "realWorldApplication": "Used by Datadog and New Relic for tenant monitoring.",
        "expertInsights": "Tag all metrics with tenant IDs. Use circuit breakers to limit blast radius.",
        "commonMistakes": [
          "Not isolating logs, leaking tenant data.",
          "Ignoring blast radius, causing cascading failures."
        ],
        "exercises": [
          {
            "title": "Set Up Tenant-Aware Observability",
            "prompt": "Configure Prometheus to collect tenant-specific metrics.",
            "difficulty": "hard",
            "hints": [
              "Tag metrics with tenant_id",
              "Use Grafana for visualization"
            ],
            "solution": "prometheus.yml: scrape_configs: - job_name: 'app' metrics_path: '/metrics' relabel_configs: - source_labels: [__meta_tenant_id] target_label: tenant_id app.js: import prom from 'prom-client'; const requests = new prom.Counter({ name: 'http_requests_total', help: 'Total requests', labelNames: ['tenant_id'] }); app.get('/', (req, res) => { requests.inc({ tenant_id: req.headers['tenant-id'] }); res.send('OK'); });"
          }
        ],
        "quiz": [
          {
            "question": "What isolates tenant metrics?",
            "options": [
              "Tagging with tenant_id",
              "Shared metrics",
              "Global dashboards",
              "Untagged logs"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What limits cross-tenant failures?",
            "options": [
              "Circuit breakers",
              "Rate limiting",
              "Backups",
              "Indexing"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "Prometheus Monitoring",
            "url": "https://prometheus.io/docs/introduction/overview/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5c1",
        "lessonId": "68d1a7a6cd394e8cc4daf5bc"
      },
      {
        "level": "Advanced",
        "explanation": "Data residency ensures tenant data complies with regional regulations, with tenant-specific backups and restores. This lesson covers configuring residency and backup strategies for SaaS systems.",
        "examples": [
          "Residency: Store EU tenant data in Frankfurt.",
          "Backup: S3 lifecycle policy per tenant."
        ],
        "realWorldApplication": "Used by AWS and Google Cloud for GDPR-compliant SaaS.",
        "expertInsights": "Use geo-replicated storage for residency. Test restores regularly.",
        "commonMistakes": [
          "Ignoring regional laws, risking fines.",
          "Not testing backups, failing restores."
        ],
        "exercises": [
          {
            "title": "Configure Tenant-Specific Backups",
            "prompt": "Set up S3 backups with tenant-specific lifecycle policies.",
            "difficulty": "hard",
            "hints": [
              "Use S3 tags for tenants",
              "Define lifecycle rules"
            ],
            "solution": "backup.tf: resource \"aws_s3_bucket\" \"tenant_backup\" { bucket = \"tenant-backups\" } resource \"aws_s3_bucket_lifecycle_configuration\" \"backup_lifecycle\" { bucket = aws_s3_bucket.tenant_backup.id rule { id = \"tenant-backup-rule\" filter { tag { key = \"tenant_id\" value = \"tenant1\" } } expiration { days = 90 } status = \"Enabled\" } }"
          }
        ],
        "quiz": [
          {
            "question": "What ensures GDPR compliance?",
            "options": [
              "Data residency",
              "Global storage",
              "Shared DB",
              "No backups"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What validates backup reliability?",
            "options": [
              "Regular restore tests",
              "Rate limiting",
              "Circuit breakers",
              "Logging"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "AWS Data Residency",
            "url": "https://aws.amazon.com/compliance/data-residency/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5c2",
        "lessonId": "68d1a7a6cd394e8cc4daf5bd"
      },
      {
        "level": "Advanced",
        "explanation": "Tenant onboarding and migration strategies enable seamless tenant integration and scaling. This lesson covers automating onboarding and migrating tenant data with minimal downtime.",
        "examples": [
          "Onboarding: API to provision tenant schema.",
          "Migration: Zero-downtime schema migration."
        ],
        "realWorldApplication": "Used by Shopify and HubSpot for tenant management.",
        "expertInsights": "Automate onboarding for scalability. Plan migrations to avoid downtime.",
        "commonMistakes": [
          "Manual onboarding, slowing growth.",
          "Not testing migrations, causing data loss."
        ],
        "exercises": [
          {
            "title": "Simulate Tenant Onboarding",
            "prompt": "Create an API endpoint to onboard a new tenant and migrate data.",
            "difficulty": "hard",
            "hints": [
              "Use REST API for onboarding",
              "Automate schema creation"
            ],
            "solution": "onboard.js: app.post('/onboard', async (req, res) => { const tenantId = req.body.tenant_id; await db.query(`CREATE SCHEMA ${tenantId}`); await db.query(`CREATE TABLE ${tenantId}.users (id SERIAL PRIMARY KEY, name TEXT)`); await migrateData(tenantId, req.body.source); res.json({ status: 'Tenant onboarded' }); }); async function migrateData(tenantId, source) { const data = await db.query(`SELECT * FROM ${source}.users`); await db.query(`INSERT INTO ${tenantId}.users SELECT * FROM ${source}.users`); }"
          }
        ],
        "quiz": [
          {
            "question": "What automates tenant setup?",
            "options": [
              "Onboarding API",
              "Manual scripts",
              "Global DB",
              "Shared schema"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What minimizes migration downtime?",
            "options": [
              "Zero-downtime strategy",
              "Full shutdown",
              "Manual copy",
              "No backups"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 120,
        "resources": [
          {
            "title": "SaaS Tenant Onboarding",
            "url": "https://www.redhat.com/en/topics/cloud/saas-tenant-onboarding",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5c3",
        "lessonId": "68d1a7a6cd394e8cc4daf5be"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Software Testing",
        "slug": "software-testing",
        "description": "Implement advanced testing techniques to reduce production incidents and ensure robust microservices and applications.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5c4"
      }
    ],
    "courses": [
      {
        "title": "Advanced Testing: Property, Fuzzing & Contract Testing",
        "slug": "advanced-testing-property-fuzzing-contract",
        "shortDescription": "An advanced course on property-based testing, fuzzing, contract testing, E2E testing, and test observability to minimize production issues.",
        "level": "Advanced",
        "longDescription": "This course covers advanced testing techniques to ensure robust applications, including property-based testing with fast-check, fuzzing, contract testing with Pact, end-to-end testing with Playwright, chaos testing, and test observability. Through hands-on exercises, real-world examples, and quizzes, you’ll add contract tests between a frontend and API and build a property-based test. The course equips you to reduce production incidents with rigorous testing practices.",
        "tags": [
          "property-based-testing",
          "fuzzing",
          "contract-testing",
          "e2e-testing",
          "chaos-testing",
          "test-observability"
        ],
        "thumbnail": "https://example.com/thumbnails/advanced-testing.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Reduce production incidents with property-based testing, fuzzing, contract testing, and observability techniques.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5c5",
        "domainId": "68d1a7a6cd394e8cc4daf5c4"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Advanced Testing Techniques",
        "slug": "advanced-testing-techniques",
        "description": "Master property-based testing, fuzzing, contract testing, E2E testing, chaos testing, and test observability.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5c6",
        "courseId": "68d1a7a6cd394e8cc4daf5c5",
        "lessonIds": [
          "68d1a7a6cd394e8cc4daf5c7",
          "68d1a7a6cd394e8cc4daf5c8",
          "68d1a7a6cd394e8cc4daf5c9",
          "68d1a7a6cd394e8cc4daf5ca",
          "68d1a7a6cd394e8cc4daf5cb"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "Property-Based Testing and Fuzzing",
        "slug": "property-based-testing-fuzzing",
        "description": "Implement property-based testing with fast-check and fuzzing strategies to uncover edge cases.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5c7",
        "moduleId": "68d1a7a6cd394e8cc4daf5c6",
        "contentId": "68d1a7a6cd394e8cc4daf5cc"
      },
      {
        "level": "Advanced",
        "title": "Contract Testing at Scale",
        "slug": "contract-testing-scale",
        "description": "Use Pact for contract testing to ensure microservices compatibility at scale.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5c8",
        "moduleId": "68d1a7a6cd394e8cc4daf5c6",
        "contentId": "68d1a7a6cd394e8cc4daf5cd"
      },
      {
        "level": "Advanced",
        "title": "End-to-End Testing at Scale",
        "slug": "e2e-testing-scale",
        "description": "Implement scalable E2E testing with Playwright, parallelization, and test data management.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5c9",
        "moduleId": "68d1a7a6cd394e8cc4daf5c6",
        "contentId": "68d1a7a6cd394e8cc4daf5ce"
      },
      {
        "level": "Advanced",
        "title": "Chaos and Failure Injection Testing",
        "slug": "chaos-failure-testing",
        "description": "Integrate chaos and failure injection tests into CI for resilience testing.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5ca",
        "moduleId": "68d1a7a6cd394e8cc4daf5c6",
        "contentId": "68d1a7a6cd394e8cc4daf5cf"
      },
      {
        "level": "Advanced",
        "title": "Test Observability",
        "slug": "test-observability",
        "description": "Implement flakiness detection, automatic retries, and backoff strategies for reliable tests.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5cb",
        "moduleId": "68d1a7a6cd394e8cc4daf5c6",
        "contentId": "68d1a7a6cd394e8cc4daf5d0"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "Property-based testing generates random inputs to verify properties, while fuzzing tests edge cases with malformed data. This lesson covers using fast-check for property-based testing and fuzzing strategies.",
        "examples": [
          "Property Test: Verify sorting function preserves input length.",
          "Fuzzing: Test API with random strings."
        ],
        "realWorldApplication": "Used by Hypothesis and fast-check adopters to catch edge-case bugs.",
        "expertInsights": "Define clear properties for testing. Use fuzzing for robustness against invalid inputs.",
        "commonMistakes": [
          "Writing vague properties, missing edge cases.",
          "Not constraining inputs, causing test noise."
        ],
        "exercises": [
          {
            "title": "Build a Property-Based Test",
            "prompt": "Write a property-based test for a sorting function using fast-check.",
            "difficulty": "medium",
            "hints": [
              "Use fast-check to generate arrays",
              "Check output length and order"
            ],
            "solution": "sort.test.js: import fc from 'fast-check'; test('sort preserves length and order', () => { fc.assert(fc.property(fc.array(fc.integer()), arr => { const sorted = sort(arr); return sorted.length === arr.length && sorted.every((v, i) => i === 0 || v >= sorted[i-1]); })); });"
          }
        ],
        "quiz": [
          {
            "question": "What generates random test inputs?",
            "options": [
              "Property-based testing",
              "Unit testing",
              "Mocking",
              "Stubbing"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What tests edge cases with malformed data?",
            "options": [
              "Fuzzing",
              "Integration testing",
              "E2E testing",
              "Load testing"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Fast-Check Documentation",
            "url": "https://fast-check.dev/docs/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5cc",
        "lessonId": "68d1a7a6cd394e8cc4daf5c7"
      },
      {
        "level": "Advanced",
        "explanation": "Contract testing with Pact ensures microservices compatibility by verifying API contracts. This lesson covers setting up Pact for consumer-driven contract testing between services.",
        "examples": [
          "Pact: Define expected API response for frontend.",
          "Contract: Validate JSON schema for API endpoint."
        ],
        "realWorldApplication": "Used by Atlassian and Uber for microservices reliability.",
        "expertInsights": "Use consumer-driven contracts to align services. Run contract tests in CI.",
        "commonMistakes": [
          "Not validating contracts, causing integration failures.",
          "Over-specifying contracts, limiting flexibility."
        ],
        "exercises": [
          {
            "title": "Add Contract Tests",
            "prompt": "Write a Pact test for a frontend-API interaction.",
            "difficulty": "hard",
            "hints": [
              "Define consumer contract",
              "Mock API response"
            ],
            "solution": "api.pact.test.js: import { Pact } from '@pact-foundation/pact'; const provider = new Pact({ consumer: 'Frontend', provider: 'API' }); test('fetch user', async () => { await provider.addInteraction({ state: 'user exists', uponReceiving: 'GET user request', withRequest: { method: 'GET', path: '/user/1' }, willRespondWith: { status: 200, body: { id: 1, name: 'John' } } }); const response = await fetch('http://localhost:1234/user/1'); expect(response.status).toBe(200); expect(await response.json()).toEqual({ id: 1, name: 'John' }); });"
          }
        ],
        "quiz": [
          {
            "question": "What ensures microservices compatibility?",
            "options": [
              "Contract testing",
              "Unit testing",
              "Load testing",
              "Fuzzing"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What tool is used for contract testing?",
            "options": [
              "Pact",
              "Playwright",
              "Fast-check",
              "Chaos Monkey"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Pact Documentation",
            "url": "https://docs.pact.io/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5cd",
        "lessonId": "68d1a7a6cd394e8cc4daf5c8"
      },
      {
        "level": "Advanced",
        "explanation": "End-to-end (E2E) testing at scale with Playwright uses parallelization and test data management to ensure application reliability. This lesson covers running Playwright tests efficiently.",
        "examples": [
          "Parallelization: Run 10 Playwright tests concurrently.",
          "Test Data: Generate unique users per test run."
        ],
        "realWorldApplication": "Used by Microsoft and Shopify for browser-based testing.",
        "expertInsights": "Parallelize tests for speed. Manage test data to avoid collisions.",
        "commonMistakes": [
          "Running tests sequentially, slowing CI.",
          "Reusing test data, causing flaky tests."
        ],
        "exercises": [
          {
            "title": "Set Up Scalable E2E Tests",
            "prompt": "Write a Playwright test suite with parallelization for a login flow.",
            "difficulty": "hard",
            "hints": [
              "Use Playwright workers",
              "Generate unique test data"
            ],
            "solution": "login.test.js: import { test } from '@playwright/test'; test.describe.parallel('Login Flow', () => { test('login succeeds', async ({ page }) => { await page.goto('/login'); await page.fill('#username', `user${Date.now()}`); await page.fill('#password', 'pass123'); await page.click('#submit'); await expect(page.locator('#welcome')).toHaveText('Welcome'); }); });"
          }
        ],
        "quiz": [
          {
            "question": "What speeds up E2E testing?",
            "options": [
              "Parallelization",
              "Sequential runs",
              "Manual testing",
              "Single browser"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What prevents E2E test collisions?",
            "options": [
              "Unique test data",
              "Shared data",
              "Hardcoded users",
              "Global state"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Playwright Documentation",
            "url": "https://playwright.dev/docs/intro",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5ce",
        "lessonId": "68d1a7a6cd394e8cc4daf5c9"
      },
      {
        "level": "Advanced",
        "explanation": "Chaos and failure injection testing simulates failures in CI to ensure system resilience. This lesson covers tools like Chaos Monkey for chaos engineering in pipelines.",
        "examples": [
          "Chaos: Terminate 10% of pods during tests.",
          "Failure: Simulate network latency in CI."
        ],
        "realWorldApplication": "Used by Netflix and AWS for resilient systems.",
        "expertInsights": "Start with controlled chaos in staging. Monitor impacts to validate resilience.",
        "commonMistakes": [
          "Not monitoring chaos tests, missing failure impacts.",
          "Overloading systems, causing false failures."
        ],
        "exercises": [
          {
            "title": "Implement Chaos Testing",
            "prompt": "Add a chaos test to CI that simulates pod failures.",
            "difficulty": "hard",
            "hints": [
              "Use Chaos Mesh",
              "Target specific pods"
            ],
            "solution": "chaos.yaml: apiVersion: chaos-mesh.org/v1alpha1 kind: PodChaos metadata: name: pod-failure spec: selector: namespaces: - default labelSelectors: app: my-app action: pod-kill schedule: '@every 10m' .github/workflows/ci.yml: jobs: chaos: runs-on: ubuntu-latest steps: - run: kubectl apply -f chaos.yaml"
          }
        ],
        "quiz": [
          {
            "question": "What tests system resilience?",
            "options": [
              "Chaos testing",
              "Unit testing",
              "Integration testing",
              "Load testing"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What simulates failures in CI?",
            "options": [
              "Failure injection",
              "Mocking",
              "Stubbing",
              "Parallelization"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Chaos Mesh Documentation",
            "url": "https://chaos-mesh.org/docs/",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5cf",
        "lessonId": "68d1a7a6cd394e8cc4daf5ca"
      },
      {
        "level": "Advanced",
        "explanation": "Test observability detects flaky tests and implements retry/backoff strategies for reliability. This lesson covers monitoring test suites and automating retries.",
        "examples": [
          "Flakiness: Detect tests failing intermittently.",
          "Retry: Automatically retry failed tests with exponential backoff."
        ],
        "realWorldApplication": "Used by GitHub and CircleCI for reliable CI pipelines.",
        "expertInsights": "Track test failure patterns. Use exponential backoff for retries to avoid overload.",
        "commonMistakes": [
          "Ignoring flaky tests, reducing confidence.",
          "Retrying without backoff, overwhelming systems."
        ],
        "exercises": [
          {
            "title": "Add Test Flakiness Detection",
            "prompt": "Implement a retry mechanism with backoff for flaky tests.",
            "difficulty": "medium",
            "hints": [
              "Use Jest retry",
              "Add exponential backoff"
            ],
            "solution": "test.config.js: module.exports = { testTimeout: 10000, retries: 3, retryDelay: (attempt) => Math.pow(2, attempt) * 1000 }; flaky.test.js: test('flaky API call', async () => { const response = await fetch('http://api/test'); expect(response.status).toBe(200); }, { retries: 3 });"
          }
        ],
        "quiz": [
          {
            "question": "What identifies unreliable tests?",
            "options": [
              "Flakiness detection",
              "Unit testing",
              "Mocking",
              "Fuzzing"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What improves test reliability?",
            "options": [
              "Exponential backoff",
              "Immediate retries",
              "Single attempt",
              "Hardcoded delays"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 90,
        "resources": [
          {
            "title": "Jest Retry Strategies",
            "url": "https://jestjs.io/docs/configuration#retries-number",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5d0",
        "lessonId": "68d1a7a6cd394e8cc4daf5cb"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  },
  {
    "domains": [
      {
        "level": "Advanced",
        "name": "Capstone Project",
        "slug": "capstone-project",
        "description": "Build, deploy, monitor, and operate a production-grade system combining all learned concepts in a real-world SaaS or microservices project.",
        "courseCount": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5d1"
      }
    ],
    "courses": [
      {
        "title": "Final Capstone: Real-World, Production-Grade System",
        "slug": "final-capstone-production-system",
        "shortDescription": "An advanced capstone course to build, deploy, and operate a production-grade SaaS or microservices application.",
        "level": "Advanced",
        "longDescription": "This capstone course guides you through building a production-grade system, either a SaaS task platform or e-commerce microservices. You’ll incorporate auth, multi-tenancy, real-time features, monitoring, Terraform infrastructure, and CI/CD with canaries. Through project development, deliverables like design docs, and quizzes, you’ll deliver a working app, threat model, and monitoring setup. The course combines all prior learnings for a comprehensive real-world project.",
        "tags": [
          "capstone",
          "saas",
          "microservices",
          "deployment",
          "monitoring",
          "ci-cd",
          "terraform"
        ],
        "thumbnail": "https://example.com/thumbnails/final-capstone.jpg",
        "levelSummary": [
          {
            "level": "Advanced",
            "overview": "Build, deploy, monitor, and operate a real product combining learnings.",
            "moduleCount": 1
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5d2",
        "domainId": "68d1a7a6cd394e8cc4daf5d1"
      }
    ],
    "modules": [
      {
        "level": "Advanced",
        "title": "Module 1 — Final Capstone: Real-World System",
        "slug": "final-capstone-real-world",
        "description": "Develop a production-grade SaaS or microservices app with auth, multi-tenancy, real-time features, monitoring, and CI/CD.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5d3",
        "courseId": "68d1a7a6cd394e8cc4daf5d2",
        "lessonIds": [
          "68d1a7a6cd394e8cc4daf5d4",
          "68d1a7a6cd394e8cc4daf5d5",
          "68d1a7a6cd394e8cc4daf5d6",
          "68d1a7a6cd394e8cc4daf5d7",
          "68d1a7a6cd394e8cc4daf5d8",
          "68d1a7a6cd394e8cc4daf5d9"
        ]
      }
    ],
    "lessons": [
      {
        "level": "Advanced",
        "title": "Project Planning and Architecture Design",
        "slug": "project-planning-architecture",
        "description": "Plan your capstone project, choose an option, and design the high-level architecture.",
        "order": 1,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5d4",
        "moduleId": "68d1a7a6cd394e8cc4daf5d3",
        "contentId": "68d1a7a6cd394e8cc4daf5da"
      },
      {
        "level": "Advanced",
        "title": "Implementing Core Features and Multi-Tenancy",
        "slug": "core-features-multi-tenancy",
        "description": "Build authentication, multi-tenant architecture, and core features like task management or inventory.",
        "order": 2,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5d5",
        "moduleId": "68d1a7a6cd394e8cc4daf5d3",
        "contentId": "68d1a7a6cd394e8cc4daf5db"
      },
      {
        "level": "Advanced",
        "title": "Real-Time and Event-Driven Components",
        "slug": "real-time-event-driven",
        "description": "Integrate real-time notifications, offline sync with CRDTs, and event-sourcing for orders.",
        "order": 3,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5d6",
        "moduleId": "68d1a7a6cd394e8cc4daf5d3",
        "contentId": "68d1a7a6cd394e8cc4daf5dc"
      },
      {
        "level": "Advanced",
        "title": "Monitoring, Billing, and SLOs",
        "slug": "monitoring-billing-slos",
        "description": "Set up monitoring, SLOs, billing with Stripe sandbox, and chaos tests.",
        "order": 4,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5d7",
        "moduleId": "68d1a7a6cd394e8cc4daf5d3",
        "contentId": "68d1a7a6cd394e8cc4daf5dd"
      },
      {
        "level": "Advanced",
        "title": "Infrastructure as Code and CI/CD",
        "slug": "iac-cicd",
        "description": "Implement Terraform infrastructure and CI/CD with canaries for deployment.",
        "order": 5,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5d8",
        "moduleId": "68d1a7a6cd394e8cc4daf5d3",
        "contentId": "68d1a7a6cd394e8cc4daf5de"
      },
      {
        "level": "Advanced",
        "title": "Project Deliverables and Presentation",
        "slug": "project-deliverables-presentation",
        "description": "Create architecture doc, threat model, demo, and README; present the project.",
        "order": 6,
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5d9",
        "moduleId": "68d1a7a6cd394e8cc4daf5d3",
        "contentId": "68d1a7a6cd394e8cc4daf5df"
      }
    ],
    "learningContents": [
      {
        "level": "Advanced",
        "explanation": "Planning the capstone project involves selecting an option (SaaS Task Platform or E-commerce Microservices), defining requirements, and designing high-level architecture. This lesson covers project scoping and creating an initial design document.",
        "examples": [
          "SaaS Task Platform: Multi-tenant task management with auth and real-time updates.",
          "Architecture: Microservices with API gateway and database."
        ],
        "realWorldApplication": "Similar to Trello or Shopify for SaaS and e-commerce.",
        "expertInsights": "Scope project to key features. Use UML for architecture diagrams.",
        "commonMistakes": [
          "Over-scoping, leading to incomplete projects.",
          "Skipping design doc, causing disorganization."
        ],
        "exercises": [
          {
            "title": "Draft Project Architecture",
            "prompt": "Create a high-level architecture diagram and doc for your chosen project option.",
            "difficulty": "medium",
            "hints": [
              "Include components like auth, database, frontend",
              "Use draw.io for diagrams"
            ],
            "solution": "arch.md: # Capstone Architecture\n- Frontend: React with Next.js\n- Backend: Node.js microservices\n- Database: PostgreSQL for tasks/orders\n- Real-time: WebSocket for notifications\nDiagram: [API Gateway -> Auth Service -> Task Service -> DB]"
          }
        ],
        "quiz": [
          {
            "question": "What is a key capstone deliverable?",
            "options": [
              "Architecture doc",
              "UI prototype",
              "Database schema",
              "All of the above"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What uses CRDTs in SaaS?",
            "options": [
              "Offline sync",
              "Billing",
              "Scaling",
              "Deployment"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 180,
        "resources": [
          {
            "title": "System Design Primer",
            "url": "https://github.com/donnemartin/system-design-primer",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5da",
        "lessonId": "68d1a7a6cd394e8cc4daf5d4"
      },
      {
        "level": "Advanced",
        "explanation": "Implementing core features and multi-tenancy involves building authentication, tenant isolation, and basic functionality like task creation or inventory management. This lesson covers integrating auth and multi-tenant logic.",
        "examples": [
          "Auth: OAuth2 with JWT for tenant-specific access.",
          "Multi-Tenant: Use tenant_id in database queries."
        ],
        "realWorldApplication": "Used in Asana for task management and WooCommerce for inventory.",
        "expertInsights": "Use JWT claims for tenant info. Enforce isolation in all queries.",
        "commonMistakes": [
          "Not validating tenant access, risking data leaks.",
          "Hardcoding auth logic, reducing flexibility."
        ],
        "exercises": [
          {
            "title": "Implement Auth and Multi-Tenancy",
            "prompt": "Add authentication and tenant isolation to your capstone backend.",
            "difficulty": "hard",
            "hints": [
              "Use JWT middleware",
              "Filter queries by tenant_id"
            ],
            "solution": "auth.js: import jwt from 'jsonwebtoken'; app.use((req, res, next) => { const token = req.headers.authorization; const decoded = jwt.verify(token, 'secret'); req.tenantId = decoded.tenant_id; next(); }); app.get('/tasks', async (req, res) => { const tasks = await db.query('SELECT * FROM tasks WHERE tenant_id = $1', [req.tenantId]); res.json(tasks); });"
          }
        ],
        "quiz": [
          {
            "question": "What secures tenant data?",
            "options": [
              "Multi-tenancy isolation",
              "Global access",
              "No auth",
              "Shared DB"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What verifies user tokens?",
            "options": [
              "JWT",
              "Session cookies",
              "API keys",
              "All of the above"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 180,
        "resources": [
          {
            "title": "JWT Documentation",
            "url": "https://jwt.io/introduction",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5db",
        "lessonId": "68d1a7a6cd394e8cc4daf5d5"
      },
      {
        "level": "Advanced",
        "explanation": "Real-time and event-driven components use WebSocket for notifications and event-sourcing for state management. This lesson covers adding real-time updates and event-sourcing to your project.",
        "examples": [
          "WebSocket: ws.send('New task');",
          "Event-Sourcing: Store TaskCreated events."
        ],
        "realWorldApplication": "Used in Trello for real-time updates and Shopify for order events.",
        "expertInsights": "Use WebSocket for low-latency. Combine event-sourcing with CQRS.",
        "commonMistakes": [
          "Not handling WebSocket disconnects, losing updates.",
          "Overusing events, complicating debugging."
        ],
        "exercises": [
          {
            "title": "Add Real-Time Notifications",
            "prompt": "Implement WebSocket notifications for new tasks.",
            "difficulty": "hard",
            "hints": [
              "Use ws library",
              "Broadcast on create"
            ],
            "solution": "ws-server.js: import WebSocket from 'ws'; const wss = new WebSocket.Server({ port: 8080 }); wss.on('connection', ws => { ws.on('message', message => wss.clients.forEach(client => client.send(message))); });"
          }
        ],
        "quiz": [
          {
            "question": "What enables real-time updates?",
            "options": [
              "WebSocket",
              "HTTP polling",
              "Both a and b",
              "Database triggers"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What stores system state as events?",
            "options": [
              "Event-sourcing",
              "CQRS",
              "Sharding",
              "Caching"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 180,
        "resources": [
          {
            "title": "WebSocket Guide",
            "url": "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5dc",
        "lessonId": "68d1a7a6cd394e8cc4daf5d6"
      },
      {
        "level": "Advanced",
        "explanation": "Monitoring with SLOs and billing integration (e.g., Stripe sandbox) ensures system reliability and monetization. Chaos tests validate resilience. This lesson covers setting up monitoring, SLOs, and chaos engineering.",
        "examples": [
          "SLO: 99.9% uptime for tasks.",
          "Billing: Stripe checkout for subscriptions."
        ],
        "realWorldApplication": "Used by Asana for monitoring and Stripe for billing.",
        "expertInsights": "Define SLOs based on user impact. Use Stripe for secure billing.",
        "commonMistakes": [
          "Not setting SLOs, ignoring reliability.",
          "Real Stripe in sandbox, causing charges."
        ],
        "exercises": [
          {
            "title": "Set Up Monitoring and Billing",
            "prompt": "Integrate Stripe sandbox and define SLOs with Prometheus.",
            "difficulty": "hard",
            "hints": [
              "Use Stripe test keys",
              "Define SLO metrics"
            ],
            "solution": "billing.js: import Stripe from 'stripe'; const stripe = new Stripe('sk_test_123'); app.post('/subscribe', async (req, res) => { const session = await stripe.checkout.sessions.create({ payment_method_types: ['card'], mode: 'subscription', line_items: [{ price: 'price_123', quantity: 1 }] }); res.json(session); });"
          }
        ],
        "quiz": [
          {
            "question": "What measures system reliability?",
            "options": [
              "SLOs",
              "Billing",
              "Auth",
              "UI"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What tests system resilience?",
            "options": [
              "Chaos tests",
              "Unit tests",
              "Integration tests",
              "E2E tests"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 180,
        "resources": [
          {
            "title": "Stripe Sandbox Guide",
            "url": "https://stripe.com/docs/test-mode",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5dd",
        "lessonId": "68d1a7a6cd394e8cc4daf5d7"
      },
      {
        "level": "Advanced",
        "explanation": "Infrastructure as Code (IaC) with Terraform automates cloud resource provisioning, while CI/CD ensures automated deployments with canaries. This lesson covers writing Terraform configs and setting up CI/CD pipelines.",
        "examples": [
          "Terraform: resource 'aws_s3_bucket' 'my_bucket' { bucket = 'app-bucket' }",
          "CI/CD: GitHub Actions for Terraform apply."
        ],
        "realWorldApplication": "Used by HashiCorp and Vercel for automated infra.",
        "expertInsights": "Use Terraform modules for reusability. Test CI/CD with staging.",
        "commonMistakes": [
          "Hardcoding Terraform values, reducing flexibility.",
          "Skipping CI/CD testing, causing deployment issues."
        ],
        "exercises": [
          {
            "title": "Set Up IaC and CI/CD",
            "prompt": "Write Terraform for an S3 bucket and CI/CD for deployment.",
            "difficulty": "hard",
            "hints": [
              "Use aws_s3_bucket resource",
              "Add Terraform to GitHub Actions"
            ],
            "solution": "main.tf: provider \"aws\" { region = \"us-east-1\" } resource \"aws_s3_bucket\" \"app\" { bucket = \"my-saas-app\" } .github/workflows/deploy.yml: name: Deploy on: push: branches: [main] jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 - uses: hashicorp/terraform-github-actions@v0.15.0 with: tf_actions_version: 1.0.0 tf_actions_subcommand: 'apply' tf_actions_working_dir: '.'"
          }
        ],
        "quiz": [
          {
            "question": "What automates cloud resources?",
            "options": [
              "Terraform",
              "Manual setup",
              "GitHub Pages",
              "Local scripts"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What enables safe IaC deployments?",
            "options": [
              "CI/CD pipelines",
              "Manual apply",
              "No testing",
              "Hardcoded values"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 180,
        "resources": [
          {
            "title": "Terraform Documentation",
            "url": "https://www.terraform.io/docs",
            "type": "doc"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5de",
        "lessonId": "68d1a7a6cd394e8cc4daf5d8"
      },
      {
        "level": "Advanced",
        "explanation": "Delivering a working demo, README, architecture doc, and threat model ensures a complete capstone project. This lesson covers compiling deliverables, presenting the project, and self-evaluating against the rubric.",
        "examples": [
          "README: Installation, usage, architecture overview.",
          "Demo: Live deployed app URL."
        ],
        "realWorldApplication": "Used in open-source projects and professional portfolios for showcasing work.",
        "expertInsights": "Make README clear and comprehensive. Include diagrams in docs.",
        "commonMistakes": [
          "Incomplete README, confusing users.",
          "Not including threat model, missing security."
        ],
        "exercises": [
          {
            "title": "Compile Project Deliverables",
            "prompt": "Create a README, design doc, threat model, and demo for your capstone.",
            "difficulty": "hard",
            "hints": [
              "Use Markdown for docs",
              "Deploy to Vercel for demo"
            ],
            "solution": "README.md: # Capstone SaaS App\n## Installation\nnpm install\n## Usage\nnpm start\n## Architecture\n[Diagram]\n## Threat Model\nSTRIDE analysis: [Details]\nDemo: https://my-app.vercel.app"
          }
        ],
        "quiz": [
          {
            "question": "What is a key capstone deliverable?",
            "options": [
              "README and demo",
              "Local code only",
              "No docs",
              "Un deployed app"
            ],
            "correctOption": [
              0
            ]
          },
          {
            "question": "What evaluates project security?",
            "options": [
              "Threat model",
              "UI tests",
              "Billing",
              "Scaling"
            ],
            "correctOption": [
              0
            ]
          }
        ],
        "estimatedTime": 180,
        "resources": [
          {
            "title": "Effective README Guide",
            "url": "https://www.makeareadme.com/",
            "type": "article"
          }
        ],
        "createdAt": "2025-09-16T00:00:00.000Z",
        "_id": "68d1a7a6cd394e8cc4daf5df",
        "lessonId": "68d1a7a6cd394e8cc4daf5d9"
      }
    ],
    "meta": {
      "generatedAt": "2025-09-16T00:00:00.000Z",
      "version": "1.0"
    }
  }
]